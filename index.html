<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Regex UI Lab</title>

    <!-- SEO & Social Meta Tags -->
    <meta name="description" content="å°ˆç‚º RisuAI/SillyTavern è¨­è¨ˆçš„ Regex UI è¦–è¦ºåŒ–é–‹ç™¼å·¥å…·ã€‚æ”¯æ´ä¸€éµ CSS è®Šæ•¸æå–ã€å³æ™‚é è¦½èˆ‡å’’èªåº«ç®¡ç†ã€‚">
    <meta property="og:title" content="Regex UI Lab - è¦–è¦ºåŒ–é–‹ç™¼ç¥å™¨">
    <meta property="og:description" content="å¯è¦–åŒ–ç·¨è¼¯ã€CSS è®Šæ•¸è‡ªå‹•ç…‰æˆã€å³æ™‚é è¦½ã€‚è®“è§’è‰²å¡é–‹ç™¼è®Šå¾—åƒé­”æ³•ä¸€æ¨£ç°¡å–®ã€‚">
    <meta property="og:type" content="website">
    <meta name="theme-color" content="#1e1e2e">

    <!-- å…§å»º Favicon (ç‡’ç“¶åœ–ç¤º) -->
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ§ª</text></svg>">

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/monaco-editor@0.45.0/min/vs/loader.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;700&display=swap');

        /* Monaco Editor å®¹å™¨æ¨£å¼ */
        .monaco-container {
            width: 100%;
            height: 500px;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            overflow: hidden;
            position: relative;
        }

        .monaco-fullscreen-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            z-index: 100;
            cursor: pointer;
            color: #ccc;
            opacity: 0.6;
            background: rgba(0, 0, 0, 0.5);
            padding: 6px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .monaco-fullscreen-btn:hover {
            opacity: 1;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
        }

        .monaco-container.fullscreen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 99999 !important;
            border-radius: 0 !important;
        }

        .monaco-container.fullscreen .monaco-fullscreen-btn {
            top: 20px;
            right: 20px;
        }

        /* ä»‹é¢è®Šæ•¸ */
        :root {
            --bg-dark: #11111b;
            --bg-panel: #1e1e2e;
            --bg-input: #181825;
            --border: #313244;
            --text-main: #cdd6f4;
            --text-dim: #bac2de;
            --accent: #f5c2e7;
            /* ç²‰è‰² */
            --accent-2: #89b4fa;
            /* è—è‰² */
            --accent-3: #a6e3a1;
            /* ç¶ è‰² */
            --accent-4: #fab387;
            /* æ©˜è‰² */
            --highlight: #f38ba8;
            /* ç´…è‰² */
        }

        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-main);
            overflow: hidden;
            height: 100vh;
            /* å¼·åˆ¶æ»¿ç‰ˆ */
        }

        /* æ²è»¸ç¾åŒ– */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-input);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #585b70;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #45475a;
        }

        /* è¼¸å…¥æ¡†é€šç”¨æ¨£å¼ */
        .input-group label {
            display: flex;
            align-items: center;
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            letter-spacing: 0.05em;
        }

        .input-dark {
            background-color: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text-dim);
            width: 100%;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.5;
            transition: border-color 0.2s, box-shadow 0.2s;
            resize: vertical;
        }

        .input-dark:focus {
            outline: none;
            border-color: var(--accent-2);
            box-shadow: 0 0 0 3px rgba(137, 180, 250, 0.1);
            color: #fff;
        }

        /* æ¨™ç±¤é åˆ‡æ›æ¨£å¼ */
        .tab-btn {
            padding: 6px 12px;
            font-size: 0.85rem;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
            color: #6c7086;
            background: transparent;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        .tab-btn.active {
            background: var(--bg-input);
            border-color: var(--border);
            border-bottom-color: var(--bg-input);
            font-weight: bold;
        }

        /* [æ–°å¢] ç°¡æ˜“æ¨¡å¼çµ„ Tabï¼ˆCSS/HTMLï¼‰- è—ç´«è‰²ç³» */
        .tab-btn.tab-simple {
            color: #89b4fa;
        }

        .tab-btn.tab-simple:hover {
            color: #b4befe;
            background: rgba(137, 180, 250, 0.1);
        }

        .tab-btn.tab-simple.active {
            color: #89b4fa;
            border-color: #89b4fa;
            border-bottom-color: var(--bg-input);
        }

        /* [æ–°å¢] Regex æ¨¡å¼çµ„ Tabï¼ˆRegex/åŠ‡æƒ…ï¼‰- æ©˜ç¶ è‰²ç³» */
        .tab-btn.tab-regex {
            color: #fab387;
        }

        .tab-btn.tab-regex:hover {
            color: #f9e2af;
            background: rgba(250, 179, 135, 0.1);
        }

        .tab-btn.tab-regex.active {
            color: #a6e3a1;
            border-color: #a6e3a1;
            border-bottom-color: var(--bg-input);
        }

        /* [æ–°å¢] Tab åˆ†éš”ç·š */
        .tab-divider {
            width: 1px;
            height: 20px;
            background: #45475a;
            margin: auto 6px;
        }

        .tab-content {
            display: none;
            /* ç§»é™¤ height: 100% ä»¥å…è¨±å…§éƒ¨ flex æ­£å¸¸é‹ä½œ */
        }

        .tab-content.active {
            display: block;
        }

        /* é è¦½å€ Iframe å®¹å™¨ */
        .preview-wrapper {
            background-image: radial-gradient(#313244 1px, transparent 1px);
            background-size: 20px 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 2rem;
            height: 100%;
            overflow: auto;
            -webkit-overflow-scrolling: touch;
        }

        iframe {
            background: white;
            border: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transition: width 0.3s ease, height 0.3s ease;
            min-height: 400px;
        }

        /* è®Šæ•¸æ§åˆ¶é …æ¨£å¼ */
        .var-control-item {
            background: var(--bg-input);
            border: 1px solid var(--border);
            padding: 0.4rem 0.6rem;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .var-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .var-name {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--accent-4);
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 280px;
            /* æ”¾å¯¬é¡¯ç¤ºå¯¬åº¦ */
        }

        .var-name:hover {
            text-decoration: underline;
            color: #fff;
        }

        .newly-added {
            animation: flash-green 1s ease-out;
        }

        @keyframes flash-green {
            0% {
                background-color: rgba(166, 227, 161, 0.5);
            }

            100% {
                background-color: var(--bg-input);
            }
        }

        /* Snippet Chips */
        .snippet-chip {
            font-size: 0.75rem;
            background-color: #313244;
            color: #cdd6f4;
            padding: 4px 8px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-right: 4px;
            margin-bottom: 4px;
        }

        .snippet-chip:hover {
            background-color: var(--accent-2);
            color: #11111b;
            transform: translateY(-1px);
        }

        .snippet-delete {
            opacity: 0.7;
            font-size: 11px;
            padding: 4px;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .snippet-delete:hover {
            opacity: 1;
            color: #d20f39;
            background-color: rgba(210, 15, 57, 0.1);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 50;
            backdrop-filter: blur(2px);
        }

        .modal-box {
            background: var(--bg-panel);
            padding: 1.5rem;
            border-radius: 0.75rem;
            width: 90%;
            max-width: 400px;
            border: 1px solid var(--border);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
            animation: modalPop 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes modalPop {
            from {
                transform: scale(0.95);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* é é¢åˆ†é æ¨£å¼ */
        .page-tabs {
            display: flex;
            gap: 4px;
            padding: 6px;
            background: var(--bg-input);
            border-radius: 6px;
            margin-bottom: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .page-tab {
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            background: transparent;
            color: var(--text-dim);
            border: 1px solid transparent;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .page-tab:hover {
            background: rgba(137, 180, 250, 0.1);
            border-color: var(--border);
        }

        .page-tab.active {
            background: var(--accent-2);
            color: var(--bg-dark);
            font-weight: 600;
        }

        .page-tab .delete-btn {
            opacity: 0;
            font-size: 0.7rem;
            padding: 2px 4px;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .page-tab:hover .delete-btn {
            opacity: 0.6;
        }

        .page-tab .delete-btn:hover {
            opacity: 1;
            background: rgba(243, 139, 168, 0.3);
            color: var(--highlight);
        }

        .page-tab-add {
            padding: 4px 10px;
            background: var(--accent-3);
            color: var(--bg-dark);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
            border: none;
            transition: all 0.2s;
        }

        .page-tab-add:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(166, 227, 161, 0.3);
        }

        /* å…¨åŸŸå¾½ç« æ¨£å¼ */
        .global-badge {
            font-size: 0.65rem;
            margin-right: 2px;
        }

        /* é€£æ¥å¾½ç« æ¨£å¼ */
        .linked-badge {
            font-size: 0.6rem;
            margin-right: 2px;
            opacity: 0.7;
        }

        /* Regex Tab æ¨£å¼ */
        .regex-container {
            display: flex;
            height: 100%;
            gap: 12px;
        }

        .regex-list-panel {
            width: 200px;
            min-width: 160px;
            display: flex;
            flex-direction: column;
            background: rgba(30, 30, 46, 0.5);
            border-radius: 8px;
            overflow: hidden;
        }

        .regex-list-header {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            border-bottom: 1px solid var(--border);
        }

        .regex-rule-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .regex-rule-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            margin-bottom: 4px;
            background: var(--bg-panel);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
            border: 1px solid transparent;
        }

        .regex-rule-item:hover {
            background: rgba(137, 180, 250, 0.1);
        }

        .regex-rule-item.active {
            background: rgba(137, 180, 250, 0.2);
            border-color: rgba(137, 180, 250, 0.3);
        }

        .regex-rule-item .rule-name {
            flex: 1;
            font-size: 0.85rem;
            color: #cdd6f4;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .regex-rule-item .rule-toggle {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .regex-add-btn-container {
            padding: 8px;
            border-top: 1px solid var(--border);
        }

        .regex-add-btn {
            width: 100%;
            padding: 8px;
            background: linear-gradient(135deg, rgba(137, 180, 250, 0.2), rgba(180, 190, 254, 0.2));
            border: 1px solid rgba(137, 180, 250, 0.3);
            border-radius: 6px;
            color: #89b4fa;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .regex-add-btn:hover {
            background: linear-gradient(135deg, rgba(137, 180, 250, 0.3), rgba(180, 190, 254, 0.3));
        }

        .regex-editor-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 12px;
            background: rgba(30, 30, 46, 0.5);
            border-radius: 8px;
            overflow-y: auto;
        }

        .regex-editor-row {
            display: flex;
            gap: 12px;
        }

        .regex-field {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .regex-field label {
            font-size: 0.75rem;
            color: #a6adc8;
        }

        .regex-textarea-small {
            height: 60px;
            resize: vertical;
            font-family: 'Fira Code', monospace;
            font-size: 0.85rem;
        }

        .regex-textarea-large {
            flex: 1;
            min-height: 150px;
            resize: vertical;
            font-family: 'Fira Code', monospace;
            font-size: 0.85rem;
        }

        /* Monaco ç·¨è¼¯å™¨å®¹å™¨ - Regex/åŠ‡æƒ… Tab å°ˆç”¨ */
        .monaco-container-small {
            width: 100%;
            height: 80px;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            overflow: hidden;
        }

        .monaco-container-flex {
            position: relative;
            width: 100%;
            flex: 1;
            min-height: 200px;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            overflow: hidden;
        }

        /* å…¨è¢å¹•æ¨£å¼ - é©ç”¨æ–¼æ‰€æœ‰ Monaco å®¹å™¨ */
        .monaco-container-flex.fullscreen,
        .monaco-container-small.fullscreen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 99999 !important;
            border-radius: 0 !important;
        }

        .monaco-container-flex.fullscreen .monaco-fullscreen-btn,
        .monaco-container-small.fullscreen .monaco-fullscreen-btn {
            top: 20px;
            right: 20px;
        }

        /* æ–°å¢è¦å‰‡é¸å–® */
        .add-rule-menu {
            position: fixed;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            z-index: 9999;
            min-width: 180px;
            padding: 4px;
            display: none;
        }

        .add-rule-menu.show {
            display: block;
        }

        .add-rule-menu-item {
            padding: 10px 14px;
            cursor: pointer;
            color: #cdd6f4;
            font-size: 0.9rem;
            border-radius: 4px;
            transition: background 0.15s ease;
        }

        .add-rule-menu-item:hover {
            background: rgba(137, 180, 250, 0.15);
        }

        .add-rule-submenu {
            position: absolute;
            left: 100%;
            bottom: 0;
            /* ğŸ”§ ä¿®å¾©ï¼šå‘ä¸Šå±•é–‹é¿å…è¶…å‡ºè¢å¹•åº•éƒ¨ */
            padding-left: 8px;
            background: transparent;
            display: none;
        }

        .add-rule-submenu-inner {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            min-width: 140px;
            padding: 4px;
            max-height: 200px;
            overflow-y: auto;
        }

        .add-rule-menu-item.has-submenu:hover .add-rule-submenu {
            display: block;
        }

        /* è¦å‰‡åˆªé™¤æŒ‰éˆ•æ¨£å¼ */
        .regex-rule-item .rule-delete-btn {
            opacity: 0;
            width: 24px;
            height: 24px;
            padding: 0;
            background: transparent;
            border: none;
            color: #f38ba8;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .regex-rule-item:hover .rule-delete-btn {
            opacity: 1;
        }

        .regex-rule-item .rule-delete-btn:hover {
            background: rgba(243, 139, 168, 0.2);
        }

        /* åŠ‡æƒ… Tab æ¨£å¼ */
        .story-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 8px;
        }

        .story-header {
            padding: 8px 12px;
            background: rgba(30, 30, 46, 0.5);
            border-radius: 8px 8px 0 0;
        }

        .story-textarea {
            flex: 1;
            width: 100%;
            min-height: 300px;
            padding: 16px;
            background: rgba(30, 30, 46, 0.5);
            border: 1px solid var(--border);
            border-radius: 0 0 8px 8px;
            color: #cdd6f4;
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            resize: none;
        }

        .story-textarea:focus {
            outline: none;
            border-color: rgba(137, 180, 250, 0.5);
        }

        .story-textarea::placeholder {
            color: #6c7086;
        }

        /* åˆ†é é¸å–®æ¨£å¼ */
        .tab-menu {
            position: fixed;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            z-index: 9999;
            min-width: 160px;
            padding: 4px;
            display: none;
        }

        .tab-menu.show {
            display: block;
            animation: menuPop 0.15s ease-out;
        }

        @keyframes menuPop {
            from {
                opacity: 0;
                transform: scale(0.95) translateY(-5px);
            }

            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .tab-menu-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            color: var(--text);
            font-size: 0.85rem;
            transition: all 0.15s;
        }

        .tab-menu-item:hover {
            background: rgba(137, 180, 250, 0.15);
        }

        .tab-menu-item.danger:hover {
            background: rgba(243, 139, 168, 0.2);
            color: var(--highlight);
        }

        .tab-menu-divider {
            height: 1px;
            background: var(--border);
            margin: 4px 0;
        }

        .tab-menu-sub {
            position: relative;
        }

        .tab-menu-sub::after {
            content: 'â–¶';
            margin-left: auto;
            font-size: 0.6rem;
            opacity: 0.5;
        }

        .tab-submenu {
            position: absolute;
            left: 100%;
            top: -4px;
            padding-top: 4px;
            padding-left: 8px;
            /* é€æ˜æ©‹æ¥å€åŸŸï¼Œç¢ºä¿æ»‘é¼ ç§»å‹•æ™‚ä¸æœƒè„«é›¢ hover */
            background: transparent;
            display: none;
        }

        .tab-submenu-inner {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 6px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            min-width: 140px;
            padding: 4px;
        }

        .tab-menu-sub:hover .tab-submenu {
            display: block;
        }

        .tab-submenu-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-dim);
            font-size: 0.8rem;
            transition: all 0.15s;
        }

        .tab-submenu-item:hover {
            background: rgba(137, 180, 250, 0.15);
            color: var(--text);
        }

        .tab-submenu-item.active {
            background: rgba(166, 227, 161, 0.2);
            color: var(--accent-3);
        }
    </style>
</head>

<body class="h-screen flex flex-col md:flex-row overflow-hidden">

    <!-- å·¦å´é¢æ¿ï¼šç·¨è¼¯å™¨ -->
    <div id="editorPanel"
        class="w-full md:w-5/12 h-[55vh] md:h-full flex flex-col border-r border-[#313244] bg-[#1e1e2e] shrink-0 md:shrink">

        <!-- Header -->
        <div class="h-14 px-4 border-b border-[#313244] flex justify-between items-center bg-[#11111b] shrink-0">
            <h1 class="text-lg font-bold text-[#f5c2e7] tracking-wide truncate">
                <i class="fas fa-flask mr-2"></i>Regex UI Lab <span class="text-xs text-[#6c7086] ml-1">v6.2.1</span>
            </h1>
            <div class="flex gap-2 items-center">
                <!-- æ‰‹æ©Ÿç‰ˆè¦–åœ–åˆ‡æ›æŒ‰éˆ• -->
                <div class="md:hidden flex gap-1 mr-2">
                    <button onclick="setMobileView('editor')" id="mobileViewEditor"
                        class="px-2 py-1 text-[10px] rounded bg-[#89b4fa] text-[#11111b] font-bold"
                        title="ç·¨è¼¯å™¨è¦–åœ–">ğŸ“</button>
                    <button onclick="setMobileView('preview')" id="mobileViewPreview"
                        class="px-2 py-1 text-[10px] rounded bg-[#313244] text-[#a6adc8] hover:bg-[#45475a]"
                        title="é è¦½è¦–åœ–">ğŸ‘ï¸</button>
                    <button onclick="setMobileView('both')" id="mobileViewBoth"
                        class="px-2 py-1 text-[10px] rounded bg-[#313244] text-[#a6adc8] hover:bg-[#45475a]"
                        title="åˆ†å‰²è¦–åœ–">â¬œ</button>
                </div>
                <button onclick="copyMergedCode()"
                    class="px-3 py-1.5 bg-[#313244] hover:bg-[#89b4fa] hover:text-[#11111b] text-[#cdd6f4] text-xs font-bold rounded transition flex items-center gap-2 whitespace-nowrap">
                    <i class="fas fa-file-export"></i> åˆä½µè¤‡è£½
                </button>
                <button onclick="openSettingsModal()"
                    class="px-2 py-1.5 bg-[#313244] hover:bg-[#f9e2af] hover:text-[#11111b] text-[#cdd6f4] text-sm rounded transition"
                    title="è¨­å®š">
                    âš™ï¸
                </button>
            </div>
        </div>

        <!-- Scrollable Content -->
        <div class="flex-1 overflow-y-auto p-4 space-y-4 custom-scrollbar">

            <!-- 0. Dynamic Variables Control (å¯æ”¶åˆ) -->
            <details open class="bg-[#181825] rounded border border-[#313244]">
                <summary
                    class="p-3 cursor-pointer select-none hover:bg-[#1e1e2e] transition flex justify-between items-center">
                    <div class="flex items-center gap-2">
                        <label class="text-[#89b4fa] mb-0 text-sm cursor-pointer">
                            <i class="fas fa-sliders-h w-5"></i> è®Šæ•¸æ§åˆ¶å°
                        </label>
                        <button onclick="event.stopPropagation(); showHelp('varControl')"
                            class="text-[#6c7086] hover:text-[#89b4fa] text-xs transition" title="èªªæ˜">â“</button>
                    </div>
                    <span class="text-[10px] text-[#6c7086]">é»æ“Šæ”¶åˆ/å±•é–‹</span>
                </summary>
                <div class="p-3 pt-0 space-y-2">
                    <div class="flex justify-between items-center">
                        <div class="flex gap-1 items-center">
                            <!-- æç…‰åˆ†é¡é¸æ“‡ -->
                            <div class="relative">
                                <button id="extractFilterBtn" onclick="toggleExtractFilter()"
                                    class="text-xs bg-[#313244] hover:bg-[#45475a] px-2 py-1.5 rounded text-[#a6adc8] transition"
                                    title="é¸æ“‡æç…‰é¡å‹">
                                    <i class="fas fa-filter"></i>
                                </button>
                                <div id="extractFilterPanel"
                                    class="hidden absolute left-0 top-full mt-1 bg-[#1e1e2e] border border-[#313244] rounded-lg p-2 z-50 shadow-xl min-w-[150px]">
                                    <div class="text-[10px] text-[#6c7086] mb-2 border-b border-[#313244] pb-1">æç…‰é¡å‹éæ¿¾
                                    </div>
                                    <label
                                        class="flex items-center gap-2 text-xs text-[#cdd6f4] py-1 cursor-pointer hover:bg-[#313244] px-1 rounded">
                                        <input type="checkbox" id="extractColor" checked class="accent-[#f5c2e7]"> ğŸ¨ é¡è‰²
                                    </label>
                                    <label
                                        class="flex items-center gap-2 text-xs text-[#cdd6f4] py-1 cursor-pointer hover:bg-[#313244] px-1 rounded">
                                        <input type="checkbox" id="extractSize" checked class="accent-[#89b4fa]"> ğŸ“ å°ºå¯¸
                                        (px/em/rem/%)
                                    </label>
                                    <label
                                        class="flex items-center gap-2 text-xs text-[#cdd6f4] py-1 cursor-pointer hover:bg-[#313244] px-1 rounded">
                                        <input type="checkbox" id="extractAngle" checked class="accent-[#a6e3a1]"> ğŸ“ è§’åº¦
                                        (deg)
                                    </label>
                                    <label
                                        class="flex items-center gap-2 text-xs text-[#cdd6f4] py-1 cursor-pointer hover:bg-[#313244] px-1 rounded">
                                        <input type="checkbox" id="extractViewport" checked class="accent-[#f9e2af]"> ğŸ“±
                                        è¦–çª— (vh/vw)
                                    </label>
                                </div>
                            </div>
                            <!-- ç…‰é‡‘è¡“æŒ‰éˆ• -->
                            <button onclick="autoExtractVariables()"
                                class="text-xs bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-500 hover:to-blue-500 px-3 py-1.5 rounded text-white shadow-lg transform hover:scale-105 transition font-bold"
                                title="è‡ªå‹•æƒæ CSS ä¸¦æå–è®Šæ•¸">
                                <i class="fas fa-magic mr-1"></i>æ™ºæ…§æç…‰
                            </button>
                            <!-- ç‡’éŒ„å„²å­˜æŒ‰éˆ• -->
                            <button onclick="burnVariablesToCSS()"
                                class="text-xs bg-gradient-to-r from-green-600 to-teal-600 hover:from-green-500 hover:to-teal-500 px-3 py-1.5 rounded text-white shadow-lg transform hover:scale-105 transition font-bold"
                                title="å°‡è®Šæ•¸å€¼ç‡’éŒ„å› CSS ä¸¦æ¸…ç©ºæ§åˆ¶å°">
                                <i class="fas fa-save mr-1"></i>ç‡’éŒ„å„²å­˜
                            </button>
                        </div>
                    </div>
                    <!-- æœå°‹è¼¸å…¥æ¡† -->
                    <div class="relative">
                        <input type="text" id="varSearchInput" placeholder="ğŸ” æœå°‹è®Šæ•¸..."
                            oninput="filterVariables(this.value)"
                            class="w-full bg-[#313244] text-[#cdd6f4] border border-[#45475a] rounded px-2 py-1 text-xs placeholder-[#6c7086]">
                    </div>
                    <div id="variablesContainer" class="space-y-2 max-h-[250px] overflow-y-auto pr-1 custom-scrollbar">
                        <div class="text-xs text-[#6c7086] italic text-center py-6" id="noVarsMsg">
                            å°šæœªæœ‰è®Šæ•¸ã€‚<br>é»æ“Šã€Œ<i class="fas fa-magic text-purple-400"></i> æ™ºæ…§æç…‰ã€<br>è‡ªå‹•åˆ†æ CSS ä¸¦ç”Ÿæˆè®Šæ•¸ï¼
                        </div>
                    </div>
                </div>
            </details>

            <!-- ğŸ§ª RISU è®Šæ•¸æ¨¡æ“¬å€ (å¯æ”¶åˆ) -->
            <details open class="bg-[#181825] rounded border border-[#313244]">
                <summary
                    class="p-3 cursor-pointer select-none hover:bg-[#1e1e2e] transition flex justify-between items-center">
                    <div class="flex items-center gap-2">
                        <label class="text-[#f5c2e7] mb-0 text-sm font-bold cursor-pointer">
                            <i class="fas fa-flask w-5"></i> RISU è®Šæ•¸æ¨¡æ“¬
                        </label>
                        <button onclick="event.stopPropagation(); showHelp('risuVars')"
                            class="text-[#6c7086] hover:text-[#f5c2e7] text-xs transition" title="èªªæ˜">â“</button>
                    </div>
                    <span class="text-[10px] text-[#6c7086]">é»æ“Šæ”¶åˆ/å±•é–‹</span>
                </summary>
                <div class="p-3 pt-0 space-y-2">
                    <!-- æ“ä½œæŒ‰éˆ•åˆ— -->
                    <div class="flex gap-1 flex-wrap">
                        <!-- æƒææŒ‰éˆ•ï¼ˆå¸¶ä¸‹æ‹‰é¸å–®ï¼‰ -->
                        <div class="relative inline-block" id="scanBtnContainer">
                            <button onclick="scanCurrentTabVariables()"
                                class="text-xs bg-[#45475a] hover:bg-[#585b70] px-2 py-1 rounded-l text-[#cdd6f4] transition"
                                title="æƒæç•¶å‰ Tab/è¦å‰‡çš„ RISU è®Šæ•¸">
                                ğŸ“¡ ç•¶å‰
                            </button><button onclick="toggleScanMenu(event)"
                                class="text-xs bg-[#45475a] hover:bg-[#585b70] px-1 py-1 rounded-r text-[#cdd6f4] transition border-l border-[#313244]"
                                title="æ›´å¤šæƒæé¸é …">
                                â–¼
                            </button>
                            <div id="scanDropdownMenu" class="hidden absolute left-0 top-full mt-1 bg-[#1e1e2e] border border-[#45475a] rounded shadow-lg z-50 min-w-[120px]">
                                <button onclick="scanCurrentTabVariables(); hideScanMenu();"
                                    class="w-full text-left text-xs px-3 py-2 text-[#cdd6f4] hover:bg-[#45475a] transition">
                                    ğŸ“¡ æƒæç•¶å‰
                                </button>
                                <button onclick="smartScanAll(); hideScanMenu();"
                                    class="w-full text-left text-xs px-3 py-2 text-[#a6e3a1] hover:bg-[#45475a] transition">
                                    ğŸ“¡ å…¨æƒ
                                </button>
                            </div>
                        </div>
                        <button onclick="openRisuVarModal()"
                            class="text-xs bg-[#45475a] hover:bg-[#585b70] px-2 py-1 rounded text-[#cdd6f4] transition"
                            title="æ‰‹å‹•æ·»åŠ æ¨¡æ“¬è®Šæ•¸">
                            â• æ‰‹å‹•
                        </button>
                        <button onclick="clearRisuVars()"
                            class="text-xs bg-[#45475a] hover:bg-[#585b70] px-2 py-1 rounded text-[#cdd6f4] transition"
                            title="æ¸…ç©ºæ‰€æœ‰æ¨¡æ“¬è®Šæ•¸">
                            ğŸ—‘ï¸ æ¸…ç©º
                        </button>
                        <input type="file" id="customImageInput" accept="image/*" class="hidden"
                            onchange="handleCustomImageUpload(this)">
                        <button onclick="document.getElementById('customImageInput').click()"
                            class="text-xs bg-[#45475a] hover:bg-[#585b70] px-2 py-1 rounded text-[#cdd6f4] transition"
                            title="ä¸Šå‚³è‡ªè¨‚æ¸¬è©¦åœ–ç‰‡">
                            ğŸ“¤ ä¸Šå‚³åœ–ç‰‡
                        </button>
                        <span id="uploadedImageCount" class="text-[10px] text-[#6c7086] self-center"></span>
                    </div>
                    <!-- æœå°‹è¼¸å…¥æ¡† -->
                    <div class="relative">
                        <input type="text" id="risuVarSearchInput" placeholder="ğŸ” æœå°‹è®Šæ•¸..."
                            oninput="filterRisuVariables(this.value)"
                            class="w-full bg-[#313244] text-[#cdd6f4] border border-[#45475a] rounded px-2 py-1 text-xs placeholder-[#6c7086]">
                    </div>
                    <!-- è®Šæ•¸åˆ—è¡¨ -->
                    <div id="risuVarsContainer" class="space-y-1 max-h-[200px] overflow-y-auto pr-1 custom-scrollbar">
                        <div class="text-xs text-[#6c7086] italic text-center py-4" id="noRisuVarsMsg">
                            å°šæœªæƒæè®Šæ•¸ã€‚<br>é»æ“Šã€ŒğŸ“¡ æƒæã€åˆ†æ HTML ä¸­çš„ RISU è®Šæ•¸
                        </div>
                    </div>
                </div>
            </details>

            <!-- æ‰‹å‹•æ·»åŠ è®Šæ•¸ Modal -->
            <div id="risuVarModal" class="hidden fixed inset-0 bg-black/50 z-50 flex items-center justify-center">
                <div class="bg-[#1e1e2e] border border-[#313244] rounded-lg p-4 w-80 shadow-xl">
                    <h3 class="text-[#f5c2e7] font-bold mb-3"><i class="fas fa-plus-circle mr-2"></i>æ–°å¢æ¨¡æ“¬è®Šæ•¸</h3>
                    <div class="space-y-3">
                        <div>
                            <label class="text-xs text-[#6c7086] block mb-1">è®Šæ•¸åç¨±</label>
                            <input type="text" id="risuVarName"
                                class="w-full bg-[#313244] text-[#cdd6f4] border border-[#45475a] rounded px-2 py-1.5 text-sm"
                                placeholder="ä¾‹å¦‚ï¼šcharacter_smile">
                        </div>
                        <div>
                            <label class="text-xs text-[#6c7086] block mb-1">è®Šæ•¸é¡å‹</label>
                            <select id="risuVarType"
                                onchange="toggleRisuVarValueInput()"
                                class="w-full bg-[#313244] text-[#cdd6f4] border border-[#45475a] rounded px-2 py-1.5 text-sm">
                                <option value="string">ğŸ“ ä¸€èˆ¬å­—ä¸²</option>
                                <option value="asset">ğŸ–¼ï¸ åœ–ç‰‡è³‡ç”¢</option>
                            </select>
                        </div>
                        <div id="risuVarValueContainer">
                            <label class="text-xs text-[#6c7086] block mb-1">é è¨­å€¼</label>
                            <input type="text" id="risuVarValue"
                                class="w-full bg-[#313244] text-[#cdd6f4] border border-[#45475a] rounded px-2 py-1.5 text-sm"
                                placeholder="ä¾‹å¦‚ï¼š1">
                        </div>
                        <div id="risuVarAssetContainer" class="hidden">
                            <label class="text-xs text-[#6c7086] block mb-1">æ¸¬è©¦åœ–ç‰‡</label>
                            <select id="risuVarAssetValue"
                                class="w-full bg-[#313244] text-[#cdd6f4] border border-[#45475a] rounded px-2 py-1.5 text-sm">
                                <option value="800x600">ğŸ“ 800x600 (é è¨­)</option>
                                <option value="1280x800">ğŸ“ 1280x800</option>
                                <option value="1920x1080">ğŸ“ 1920x1080</option>
                                <option value="400x400">ğŸ“ 400x400 (æ­£æ–¹å½¢)</option>
                            </select>
                            <p class="text-[10px] text-[#6c7086] mt-1">
                                ğŸ’¡ ä¹Ÿå¯ä½¿ç”¨ã€ŒğŸ“¤ ä¸Šå‚³åœ–ç‰‡ã€å…ˆä¸Šå‚³è‡ªè¨‚åœ–ç‰‡
                            </p>
                        </div>
                    </div>
                    <div class="flex justify-end gap-2 mt-4">
                        <button onclick="closeRisuVarModal()"
                            class="px-3 py-1.5 text-xs bg-[#45475a] hover:bg-[#585b70] rounded text-[#cdd6f4]">å–æ¶ˆ</button>
                        <button onclick="addRisuSimVar()"
                            class="px-3 py-1.5 text-xs bg-[#a6e3a1] hover:bg-[#94e2d5] rounded text-[#11111b] font-bold">æ–°å¢</button>
                    </div>
                </div>
            </div>

            <!-- Snippet Library with Tabs -->
            <div class="space-y-2">
                <!-- åˆ†é æ¨™ç±¤ -->
                <div class="flex items-center justify-between mb-1">
                    <div class="flex gap-1 items-center">
                        <button id="snippetTabCss" onclick="switchSnippetTab('css')"
                            class="text-xs px-2 py-1 rounded-t bg-[#313244] text-[#a6e3a1] font-bold border-b-2 border-[#a6e3a1]">
                            <i class="fas fa-code mr-1"></i>CSS ç‰‡æ®µ
                        </button>
                        <button id="snippetTabResponsive" onclick="switchSnippetTab('responsive')"
                            class="text-xs px-2 py-1 rounded-t bg-[#1e1e2e] text-[#6c7086] hover:text-white transition">
                            <i class="fas fa-mobile-alt mr-1"></i>éŸ¿æ‡‰å¼è¼”åŠ©
                        </button>
                        <button onclick="showHelp('snippets')"
                            class="text-[#6c7086] hover:text-[#a6e3a1] text-xs transition ml-1" title="èªªæ˜">â“</button>
                    </div>
                    <!-- åŒ¯å…¥/åŒ¯å‡º/æ–°å¢ï¼ˆåƒ…åœ¨ CSS ç‰‡æ®µåˆ†é é¡¯ç¤ºï¼‰-->
                    <div id="snippetActions" class="flex gap-1">
                        <button onclick="exportSnippets()"
                            class="text-xs text-[#89b4fa] hover:text-white bg-[#313244] px-2 py-0.5 rounded transition"
                            title="åŒ¯å‡ºè‡ªè¨‚å’’èª">
                            <i class="fas fa-download"></i>
                        </button>
                        <label
                            class="text-xs text-[#f9e2af] hover:text-white bg-[#313244] px-2 py-0.5 rounded transition cursor-pointer"
                            title="åŒ¯å…¥å’’èª">
                            <i class="fas fa-upload"></i>
                            <input type="file" accept=".json" onchange="importSnippets(event)" class="hidden">
                        </label>
                        <button onclick="openSnippetModal()"
                            class="text-xs text-[#a6e3a1] hover:text-white bg-[#313244] px-2 py-0.5 rounded transition"
                            title="æ–°å¢è‡ªå®šç¾©å’’èª">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                </div>

                <!-- CSS ç‰‡æ®µå…§å®¹ -->
                <div id="snippetContainer" class="p-2 bg-[#181825] rounded border border-[#313244] min-h-[80px]">
                    <!-- Snippets injected by JS -->
                </div>

                <!-- éŸ¿æ‡‰å¼è¼”åŠ©å…§å®¹ï¼ˆé è¨­éš±è—ï¼‰-->
                <div id="responsiveContainer"
                    class="hidden p-2 bg-[#181825] rounded border border-[#313244] min-h-[80px]">
                    <div class="text-xs text-[#6c7086] mb-2 flex items-center gap-2">
                        <i class="fas fa-info-circle"></i>
                        <span id="responsiveHint">å…ˆç”¨ã€Œé¸å–ã€æ¨¡å¼é¸å–å…ƒç´ ï¼Œå†é»æ“Šä¸‹æ–¹æŒ‰éˆ•</span>
                    </div>

                    <!-- æ‰‹æ©Ÿç‰ˆæ•ˆæœ -->
                    <div class="mb-2">
                        <div class="text-[10px] text-[#89b4fa] mb-1 font-bold">ğŸ“± æ‰‹æ©Ÿç‰ˆ (â‰¤768px)</div>
                        <div class="flex flex-wrap gap-1">
                            <button onclick="insertResponsiveStyle('hide', 768)" class="snippet-chip !text-[10px]">ğŸ™ˆ
                                éš±è—</button>
                            <button onclick="insertResponsiveStyle('smallText', 768)"
                                class="snippet-chip !text-[10px]">ğŸ”¤ ç¸®å°å­—é«”</button>
                            <button onclick="insertResponsiveStyle('fullWidth', 768)"
                                class="snippet-chip !text-[10px]">â†”ï¸ æ»¿ç‰ˆå¯¬åº¦</button>
                            <button onclick="insertResponsiveStyle('column', 768)" class="snippet-chip !text-[10px]">â¬‡ï¸
                                ç›´å‘æ’åˆ—</button>
                            <button onclick="insertResponsiveStyle('centerText', 768)"
                                class="snippet-chip !text-[10px]">ğŸ“‹ ç½®ä¸­æ–‡å­—</button>
                            <button onclick="insertResponsiveStyle('noPadding', 768)"
                                class="snippet-chip !text-[10px]">ğŸ“ ç§»é™¤å…§è·</button>
                        </div>
                    </div>

                    <!-- å¹³æ¿ç‰ˆæ•ˆæœ -->
                    <div class="mb-2">
                        <div class="text-[10px] text-[#f9e2af] mb-1 font-bold">ğŸ“² å¹³æ¿ç‰ˆ (769px~1024px)</div>
                        <div class="flex flex-wrap gap-1">
                            <button onclick="insertResponsiveStyle('hide', 1024, 769)"
                                class="snippet-chip !text-[10px] !bg-[#3b3553]">ğŸ™ˆ éš±è—</button>
                            <button onclick="insertResponsiveStyle('twoColumn', 1024, 769)"
                                class="snippet-chip !text-[10px] !bg-[#3b3553]">ğŸ”² å…©æ¬„</button>
                            <button onclick="insertResponsiveStyle('smallerText', 1024, 769)"
                                class="snippet-chip !text-[10px] !bg-[#3b3553]">ğŸ”¤ ç¨å¾®ç¸®å°</button>
                        </div>
                    </div>

                    <!-- è‡ªè¨‚æ–·é» -->
                    <div class="text-[10px] text-[#6c7086] mt-2 pt-2 border-t border-[#313244]">
                        ğŸ’¡ æç¤ºï¼šæ’å…¥å¾Œå¯åœ¨ CSS ç·¨è¼¯å™¨ä¸­èª¿æ•´æ•¸å€¼
                    </div>
                </div>
            </div>

            <!-- 2. Output Editor (CSS & HTML) -->
            <div class="space-y-0 flex-1 flex flex-col">
                <div class="flex items-end justify-between mb-1">
                    <div class="flex items-center gap-2">
                        <label class="text-[#cdd6f4] mb-0 text-sm font-bold">
                            <i class="fas fa-code w-5"></i> ç·¨è¼¯å™¨
                        </label>
                        <button onclick="showHelp('editor')"
                            class="text-[#6c7086] hover:text-[#cdd6f4] text-xs transition" title="èªªæ˜">â“</button>
                    </div>
                    <div class="flex items-center">
                        <!-- ç°¡æ˜“æ¨¡å¼çµ„ -->
                        <button class="tab-btn tab-simple active" onclick="switchTab('css')">CSS</button>
                        <button class="tab-btn tab-simple" onclick="switchTab('html')">HTML</button>
                        <!-- åˆ†éš”ç·š -->
                        <div class="tab-divider"></div>
                        <!-- Regex æ¨¡å¼çµ„ -->
                        <button class="tab-btn tab-regex" onclick="switchTab('regex')">Regex</button>
                        <button class="tab-btn tab-regex" onclick="switchTab('story')">åŠ‡æƒ…</button>
                    </div>
                </div>

                <!-- CSS Tab -->
                <div id="tab-css" class="tab-content active relative">
                    <!-- CSS åˆ†çµ„åˆ†é  -->
                    <div id="cssTabsContainer" class="page-tabs">
                        <!-- å‹•æ…‹æ¸²æŸ“ -->
                    </div>
                    <div id="cssEditorContainer" class="monaco-container">
                        <div class="monaco-fullscreen-btn" onclick="toggleFullscreen('css')" title="å…¨è¢å¹• (ESC é€€å‡º)">
                            <i class="fas fa-expand"></i>
                        </div>
                    </div>
                    <!-- æç…‰é¸å–æŒ‰éˆ• -->
                    <button onclick="extractSelectedCSS()"
                        class="absolute bottom-2 right-2 text-xs bg-gradient-to-r from-purple-500/80 to-indigo-500/80 hover:from-purple-400 hover:to-indigo-400 text-white/90 px-3 py-1.5 rounded-lg shadow-lg transition flex items-center gap-1 backdrop-blur-sm z-10"
                        title="å¾é¸å–çš„ CSS ç‰‡æ®µä¸­æç…‰è®Šæ•¸">
                        <i class="fas fa-flask"></i> æç…‰é¸å–
                    </button>
                </div>

                <!-- HTML Tab -->
                <div id="tab-html" class="tab-content">
                    <!-- é é¢åˆ†é  -->
                    <div id="pageTabsContainer" class="page-tabs">
                        <!-- å‹•æ…‹æ¸²æŸ“ -->
                    </div>
                    <div id="htmlEditorContainer" class="monaco-container">
                        <div class="monaco-fullscreen-btn" onclick="toggleFullscreen('html')" title="å…¨è¢å¹• (ESC é€€å‡º)">
                            <i class="fas fa-expand"></i>
                        </div>
                    </div>
                </div>

                <!-- Regex Tab -->
                <div id="tab-regex" class="tab-content">
                    <div class="regex-container">
                        <!-- å·¦å´ï¼šè¦å‰‡åˆ—è¡¨ -->
                        <div class="regex-list-panel">
                            <div class="regex-list-header">
                                <span class="text-[#89b4fa] font-bold text-sm">ğŸ“‹ è¦å‰‡åˆ—è¡¨</span>
                                <div class="flex gap-1 ml-auto">
                                    <button onclick="importRegexRules()"
                                        class="text-xs px-2 py-1 rounded bg-[#45475a] text-[#a6e3a1] hover:bg-[#45475a]/80"
                                        title="åŒ¯å…¥ RISU Regex JSON">ğŸ“¥</button>
                                    <button onclick="exportRegexRules()"
                                        class="text-xs px-2 py-1 rounded bg-[#45475a] text-[#f9e2af] hover:bg-[#45475a]/80"
                                        title="åŒ¯å‡ºç‚º RISU Regex JSON">ğŸ“¤</button>
                                </div>
                            </div>
                            <div id="regexRuleList" class="regex-rule-list">
                                <!-- å‹•æ…‹æ¸²æŸ“ -->
                            </div>
                            <div class="regex-add-btn-container">
                                <button onclick="showAddRuleMenu(event)" class="regex-add-btn">
                                    + æ–°å¢ â–¼
                                </button>
                            </div>
                        </div>

                        <!-- å³å´ï¼šè¦å‰‡ç·¨è¼¯å™¨ -->
                        <div class="regex-editor-panel">
                            <!-- åç¨±ã€é¡å‹ã€æ¨™èªŒ -->
                            <div class="regex-editor-row">
                                <div class="regex-field flex-1">
                                    <label>åç¨±</label>
                                    <input type="text" id="ruleNameInput" class="input-dark" placeholder="è¦å‰‡åç¨±">
                                </div>
                                <div class="regex-field" style="width: 130px;">
                                    <label>é¡å‹</label>
                                    <select id="ruleTypeSelect" class="input-dark">
                                        <option value="editdisplay">ä¿®æ”¹é¡¯ç¤º</option>
                                        <option value="editinput">ä¿®æ”¹è¼¸å…¥</option>
                                        <option value="editoutput">ä¿®æ”¹è¼¸å‡º</option>
                                        <option value="editrequest">ä¿®æ”¹è«‹æ±‚</option>
                                        <option value="edittranslate">ä¿®æ”¹ç¿»è­¯</option>
                                        <option value="disabled">é—œé–‰</option>
                                    </select>
                                </div>
                                <div class="regex-field" style="width: 60px;">
                                    <label>æ¨™èªŒ</label>
                                    <input type="text" id="ruleFlagsInput" class="input-dark text-center" value="gi">
                                </div>
                            </div>

                            <!-- IN (Pattern) - Monaco Editor -->
                            <div class="regex-field">
                                <label>IN (Regex Pattern)</label>
                                <div id="regexPatternEditorContainer" class="monaco-container-small"></div>
                            </div>

                            <!-- OUT (HTML+CSS) - Monaco Editor -->
                            <div class="regex-field flex-1">
                                <label>OUT (HTML + CSS)</label>
                                <div id="regexOutputEditorContainer" class="monaco-container-flex">
                                    <div class="monaco-fullscreen-btn" onclick="toggleFullscreen('regexOutput')"
                                        title="å…¨è¢å¹• (ESC é€€å‡º)">
                                        <i class="fas fa-expand"></i>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- èˆŠç‰ˆ Regex å…§å®¹ï¼ˆä¿ç•™ä¾›å…¼å®¹ï¼Œéš±è—ï¼‰ -->
                <div style="display: none;">
                    <div class="flex gap-2">
                        <input type="text" id="regexInput" class="input-dark flex-1"
                            value="<\s*imgs*=\s*[â€&quot;'](.*?)[â€&quot;']\s*>">
                        <input type="text" id="regexFlags" class="input-dark w-16 text-center" value="gi" title="Flags">
                    </div>
                    <div class="space-y-2">
                        <label class="text-[#fab387]">æ¨¡æ“¬åŠ‡æƒ… (Test Data)</label>
                        <textarea id="testInput" class="input-dark min-h-[200px]" placeholder="æ¨¡æ“¬ AI è¼¸å‡ºçš„å…§å®¹...">
<imgs="Happy_Ending">
</textarea>
                    </div>
                </div> <!-- çµæŸéš±è— div -->
            </div>

            <!-- åŠ‡æƒ… Tab -->
            <div id="tab-story" class="tab-content">
                <div class="story-container">
                    <div class="story-header">
                        <span class="text-[#f9e2af] font-bold text-sm">ğŸ“ æ¸¬è©¦åŠ‡æƒ…</span>
                        <span class="text-[#6c7086] text-xs ml-2">æ¨¡æ“¬ AI è¼¸å‡ºçš„å…§å®¹ï¼Œç”¨æ–¼æ¸¬è©¦ Regex è¦å‰‡</span>
                    </div>
                    <div id="storyEditorContainer" class="monaco-container-flex">
                        <div class="monaco-fullscreen-btn" onclick="toggleFullscreen('story')" title="å…¨è¢å¹• (ESC é€€å‡º)">
                            <i class="fas fa-expand"></i>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>
    </div>

    <!-- å³å´é¢æ¿ï¼šé è¦½ -->
    <div id="previewPanel" class="w-full md:w-7/12 h-[45vh] md:h-full flex flex-col bg-[#11111b]">
        <!-- Preview Header - æ‰‹æ©Ÿç‰ˆé›™è¡Œä½ˆå±€ -->
        <div
            class="px-3 md:px-4 py-2 md:h-14 border-b border-[#313244] flex flex-col md:flex-row md:justify-between md:items-center shrink-0 gap-2 md:gap-0">
            <!-- ç¬¬ä¸€è¡Œï¼šæ¨™é¡Œ + è¿”å›æŒ‰éˆ•ï¼ˆæ‰‹æ©Ÿç‰ˆï¼‰ + æ¨¡å¼åˆ‡æ› -->
            <div class="flex items-center justify-between md:justify-start gap-2 md:gap-3">
                <!-- æ‰‹æ©Ÿç‰ˆè¿”å›ç·¨è¼¯å™¨æŒ‰éˆ• -->
                <button onclick="setMobileView('editor')"
                    class="md:hidden px-2 py-1 text-[10px] rounded bg-[#313244] text-[#89b4fa] hover:bg-[#45475a]"
                    title="è¿”å›ç·¨è¼¯å™¨">
                    <i class="fas fa-arrow-left"></i> ğŸ“
                </button>
                <span class="text-[#89b4fa] text-sm font-bold">
                    <i class="fas fa-eye mr-1 md:mr-2"></i><span class="hidden md:inline">å³æ™‚</span>é è¦½
                </span>
                <button onclick="showHelp('preview')" class="text-[#6c7086] hover:text-[#89b4fa] text-xs transition"
                    title="èªªæ˜">â“</button>
                <!-- é è¦½æ¨¡å¼åˆ‡æ› -->
                <div class="flex items-center gap-1 md:gap-2 md:ml-4 bg-[#1e1e2e] px-2 py-1 rounded-lg text-xs">
                    <span class="text-[#6c7086] hidden md:inline">æ¨¡å¼:</span>
                    <button id="modeSimple" onclick="setPreviewMode('simple')"
                        class="px-2 py-0.5 rounded bg-[#89b4fa] text-[#11111b] font-bold">ç°¡æ˜“</button>
                    <button id="modeRegex" onclick="setPreviewMode('regex')"
                        class="px-2 py-0.5 rounded text-[#6c7086] hover:text-white">Regex</button>
                    <!-- [ä¿®æ”¹] èƒŒæ™¯è‰²é¸æ“‡å™¨ï¼šè‰²ç›¤ -->
                    <span class="text-[#45475a] mx-1">|</span>
                    <input type="color" id="previewBgPicker" value="#ffffff" onchange="setPreviewBgColor(this.value)"
                        class="w-5 h-5 rounded border border-[#45475a] cursor-pointer bg-transparent" title="é è¦½å€èƒŒæ™¯è‰²">
                </div>
                <!-- é•·æŒ‰/é›™æ“Šå®šä½æç¤º(æ‰‹æ©Ÿç‰ˆ) -->
                <span class="flex md:hidden text-[#6c7086] items-center gap-1 text-[10px]" title="é•·æŒ‰å®šä½ CSSï¼Œé›™æ“Šå®šä½ HTML">
                    <i class="fas fa-hand-pointer text-[#89b4fa]"></i>
                    <span>é•·æŒ‰â†’<span class="text-[#89b4fa]">CSS</span></span>
                    <span class="text-[#fab387]">é›™æ“Šâ†’HTML</span>
                </span>
            </div>
            <!-- ç¬¬äºŒè¡Œï¼ˆæ‰‹æ©Ÿç‰ˆï¼‰/ å³å´ï¼ˆæ¡Œæ©Ÿç‰ˆï¼‰ï¼šå·¥å…·åˆ— -->
            <div class="flex items-center gap-2 md:gap-3 justify-between md:justify-end">
                <!-- Ctrl+é»æ“Šæç¤ºï¼ˆæ¡Œæ©Ÿç‰ˆï¼‰+ Undo/Redo -->
                <div class="flex items-center gap-2 bg-[#1e1e2e] px-2 py-1 rounded-lg text-xs">
                    <span class="hidden md:flex text-[#6c7086] items-center gap-1" title="Ctrl+é»æ“Šå®šä½ CSSï¼ŒAlt+é»æ“Šå®šä½ HTML">
                        <i class="fas fa-mouse-pointer text-[#89b4fa]"></i>
                        <span>Ctrlâ†’<span class="text-[#89b4fa]">CSS</span></span>
                        <span class="text-[#fab387]">Altâ†’HTML</span>
                    </span>
                    <span class="hidden md:inline text-[#313244]">|</span>
                    <!-- Undo/Redo æŒ‰éˆ• -->
                    <button id="undoCssBtn" onclick="undoCssChange()"
                        class="px-1.5 py-0.5 rounded text-[#6c7086] hover:text-white hover:bg-[#45475a] transition opacity-40"
                        title="å¾©åŸæ§åˆ¶æŸ„æ“ä½œ (Ctrl+Z)" disabled>
                        <i class="fas fa-undo text-[10px]"></i>
                    </button>
                    <button id="redoCssBtn" onclick="redoCssChange()"
                        class="px-1.5 py-0.5 rounded text-[#6c7086] hover:text-white hover:bg-[#45475a] transition opacity-40"
                        title="é‡åšæ§åˆ¶æŸ„æ“ä½œ (Ctrl+Y)" disabled>
                        <i class="fas fa-redo text-[10px]"></i>
                    </button>
                </div>
                <!-- è£ç½®é è¨­æŒ‰éˆ• + å¯¬åº¦/é«˜åº¦æ»‘æ¡¿ -->
                <div class="flex items-center gap-1 md:gap-2 bg-[#1e1e2e] px-2 py-1 rounded-lg text-xs">
                    <button onclick="setDeviceSize(375, 667)"
                        class="device-btn px-1 md:px-1.5 py-0.5 rounded hover:bg-[#45475a] transition"
                        title="iPhone SE (375Ã—667)">
                        <i class="fas fa-mobile-alt text-[#a6e3a1]"></i>
                    </button>
                    <button onclick="setDeviceSize(428, 926)"
                        class="device-btn px-1 md:px-1.5 py-0.5 rounded hover:bg-[#45475a] transition"
                        title="iPhone Pro Max (428Ã—926)">
                        <i class="fas fa-mobile text-[#89b4fa]"></i>
                    </button>
                    <button onclick="setDeviceSize(768, 1024)"
                        class="hidden md:inline-block device-btn px-1.5 py-0.5 rounded hover:bg-[#45475a] transition"
                        title="iPad (768Ã—1024)">
                        <i class="fas fa-tablet-alt text-[#f9e2af]"></i>
                    </button>
                    <button onclick="setDeviceSize(1024, 768)"
                        class="hidden md:inline-block device-btn px-1.5 py-0.5 rounded hover:bg-[#45475a] transition"
                        title="æ¡Œæ©Ÿ (1024Ã—768)">
                        <i class="fas fa-desktop text-[#f5c2e7]"></i>
                    </button>
                    <span class="text-[#313244] hidden md:inline">|</span>
                    <span class="text-[#6c7086] hidden md:inline">W</span>
                    <input type="range" id="widthRange" min="280" max="1200" value="400"
                        class="w-12 md:w-16 h-1 bg-[#313244] rounded-lg appearance-none cursor-pointer">
                    <span id="widthDisplay" class="text-[#a6adc8] text-[10px] md:text-xs w-8 md:w-12">400px</span>
                    <span class="text-[#313244] hidden md:inline">|</span>
                    <span class="text-[#6c7086] hidden md:inline">H</span>
                    <input type="range" id="heightRange" min="400" max="1200" value="700"
                        class="hidden md:inline-block w-16 h-1 bg-[#313244] rounded-lg appearance-none cursor-pointer">
                    <span id="heightDisplay" class="hidden md:inline-block text-[#a6adc8] w-12">700px</span>
                </div>
            </div>
        </div>

        <!-- Preview Content -->
        <div class="flex-1 overflow-hidden relative">
            <div class="preview-wrapper h-full">
                <iframe id="previewFrame" style="width: 400px; height: 700px;"></iframe>
            </div>

            <!-- Box Model è³‡è¨Šé¢æ¿ -->
            <div id="boxModelPanel"
                class="absolute bottom-0 left-0 right-0 bg-[#1e1e2e]/95 border-t border-[#313244] p-3 hidden backdrop-blur-sm">
                <div class="flex items-center justify-between mb-2">
                    <div class="flex items-center gap-2">
                        <i class="fas fa-cube text-[#89b4fa]"></i>
                        <span id="boxModelSelector" class="text-xs font-mono text-[#a6e3a1]">.element</span>
                    </div>
                    <button onclick="hideBoxModelPanel()" class="text-[#6c7086] hover:text-white text-xs">
                        <i class="fas fa-times"></i>
                    </button>
                </div>

                <!-- Box Model è¦–è¦ºåŒ– -->
                <div class="flex gap-4 items-center">
                    <!-- å·¦å´ï¼šBox Model åœ–ç¤º -->
                    <div class="box-model-diagram relative text-[10px] font-mono" style="width: 180px; height: 120px;">
                        <!-- Margin å€åŸŸï¼ˆæ©˜è‰²ï¼‰ -->
                        <div
                            class="absolute inset-0 bg-[#fab387]/20 border border-[#fab387]/50 rounded flex items-center justify-center">
                            <span class="absolute top-0.5 left-1/2 -translate-x-1/2 text-[#fab387]"
                                id="bm-margin-top">-</span>
                            <span class="absolute bottom-0.5 left-1/2 -translate-x-1/2 text-[#fab387]"
                                id="bm-margin-bottom">-</span>
                            <span class="absolute left-0.5 top-1/2 -translate-y-1/2 text-[#fab387]"
                                id="bm-margin-left">-</span>
                            <span class="absolute right-0.5 top-1/2 -translate-y-1/2 text-[#fab387]"
                                id="bm-margin-right">-</span>

                            <!-- Padding å€åŸŸï¼ˆç¶ è‰²ï¼‰ -->
                            <div
                                class="absolute inset-4 bg-[#a6e3a1]/20 border border-[#a6e3a1]/50 rounded flex items-center justify-center">
                                <span class="absolute top-0.5 left-1/2 -translate-x-1/2 text-[#a6e3a1]"
                                    id="bm-padding-top">-</span>
                                <span class="absolute bottom-0.5 left-1/2 -translate-x-1/2 text-[#a6e3a1]"
                                    id="bm-padding-bottom">-</span>
                                <span class="absolute left-0.5 top-1/2 -translate-y-1/2 text-[#a6e3a1]"
                                    id="bm-padding-left">-</span>
                                <span class="absolute right-0.5 top-1/2 -translate-y-1/2 text-[#a6e3a1]"
                                    id="bm-padding-right">-</span>

                                <!-- Content å€åŸŸï¼ˆè—è‰²ï¼‰ -->
                                <div
                                    class="absolute inset-3 bg-[#89b4fa]/30 border border-[#89b4fa] rounded flex items-center justify-center">
                                    <span class="text-[#89b4fa] text-[9px]" id="bm-size">- Ã— -</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- å³å´ï¼šå±¬æ€§åˆ—è¡¨ -->
                    <div class="flex-1 grid grid-cols-2 gap-x-4 gap-y-1 text-xs">
                        <div class="flex justify-between">
                            <span class="text-[#6c7086]">position</span>
                            <span class="text-[#cdd6f4] font-mono" id="bm-position">-</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-[#6c7086]">border-radius</span>
                            <span class="text-[#cdd6f4] font-mono" id="bm-border-radius">-</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="snippetModal" class="modal-overlay">
        <div class="modal-box space-y-4">
            <div class="flex justify-between items-center border-b border-[#313244] pb-2">
                <h3 class="text-[#a6e3a1] font-bold">æ–°å¢è‡ªå®šç¾©å’’èª</h3>
                <button onclick="closeSnippetModal()" class="text-[#6c7086] hover:text-white"><i
                        class="fas fa-times"></i></button>
            </div>
            <div class="space-y-3">
                <div class="space-y-1">
                    <label class="text-xs text-[#bac2de]">å’’èªåç¨±</label>
                    <input type="text" id="newSnippetName" class="input-dark py-1" placeholder="ä¾‹å¦‚ï¼šå‘¼å¸ç‡ˆæ•ˆæœ">
                </div>
                <div class="space-y-1">
                    <label class="text-xs text-[#bac2de]">CSS ä»£ç¢¼</label>
                    <textarea id="newSnippetCode" class="input-dark h-24"
                        placeholder="ä¾‹å¦‚ï¼šanimation: pulse 2s infinite;"></textarea>
                </div>
            </div>
            <div class="flex justify-end gap-2 pt-2">
                <button onclick="closeSnippetModal()"
                    class="px-3 py-1.5 text-xs text-[#bac2de] hover:text-white rounded border border-[#313244]">å–æ¶ˆ</button>
                <button onclick="confirmAddSnippet()"
                    class="px-3 py-1.5 text-xs bg-[#313244] hover:bg-[#a6e3a1] hover:text-[#11111b] text-[#a6e3a1] font-bold rounded">ç¢ºèªæ–°å¢</button>
            </div>
        </div>
    </div>

    <div id="confirmModal" class="modal-overlay">
        <div class="modal-box space-y-4 border-red-900/50" style="border-color: #5c2b2b;">
            <div class="flex justify-between items-center border-b border-[#313244] pb-2">
                <h3 class="text-[#f38ba8] font-bold"><i class="fas fa-exclamation-triangle mr-2"></i>ç¢ºèªåˆªé™¤</h3>
                <button onclick="closeConfirmModal()" class="text-[#6c7086] hover:text-white"><i
                        class="fas fa-times"></i></button>
            </div>
            <p class="text-sm text-[#cdd6f4]">
                æ‚¨ç¢ºå®šè¦å°‡æ­¤å’’èªæ°¸ä¹…åˆªé™¤å—ï¼Ÿ<br>
                <span class="text-xs text-[#6c7086]">æ­¤æ“ä½œç„¡æ³•å¾©åŸã€‚</span>
            </p>
            <div class="flex justify-end gap-2 pt-2">
                <button onclick="closeConfirmModal()"
                    class="px-3 py-1.5 text-xs text-[#bac2de] hover:text-white rounded border border-[#313244]">å–æ¶ˆ</button>
                <button onclick="performDeleteSnippet()"
                    class="px-3 py-1.5 text-xs bg-[#d20f39] hover:bg-[#ff3355] text-white font-bold rounded shadow-lg shadow-red-900/20">ç¢ºèªåˆªé™¤</button>
            </div>
        </div>
    </div>

    <!-- ç‡’éŒ„ç¢ºèª Modal -->
    <div id="burnConfirmModal" class="modal-overlay">
        <div class="modal-box space-y-4" style="border-color: #2d5a2d;">
            <div class="flex justify-between items-center border-b border-[#313244] pb-2">
                <h3 class="text-[#a6e3a1] font-bold"><i class="fas fa-fire mr-2"></i>ç¢ºèªç‡’éŒ„å„²å­˜</h3>
                <button onclick="closeBurnConfirmModal()" class="text-[#6c7086] hover:text-white"><i
                        class="fas fa-times"></i></button>
            </div>
            <p id="burnConfirmMessage" class="text-sm text-[#cdd6f4]">
                ç¢ºå®šè¦ç‡’éŒ„å„²å­˜å—ï¼Ÿ<br><br>
                é€™å°‡æœƒï¼š<br>
                1. å°‡è®Šæ•¸çš„å€¼å¯«å…¥ CSS<br>
                2. æ¸…ç©ºè®Šæ•¸æ§åˆ¶å°<br><br>
                <span class="text-xs text-[#6c7086]">æ­¤æ“ä½œç„¡æ³•å¾©åŸã€‚</span>
            </p>
            <div class="flex justify-end gap-2 pt-2">
                <button onclick="closeBurnConfirmModal()"
                    class="px-3 py-1.5 text-xs text-[#bac2de] hover:text-white rounded border border-[#313244]">å–æ¶ˆ</button>
                <button onclick="performBurnVariables()"
                    class="px-3 py-1.5 text-xs bg-gradient-to-r from-green-600 to-teal-600 hover:from-green-500 hover:to-teal-500 text-white font-bold rounded shadow-lg">ç¢ºèªç‡’éŒ„</button>
            </div>
        </div>
    </div>

    <!-- åŒ¯å…¥è¦å‰‡ç¢ºèª Modal -->
    <div id="importConfirmModal" class="modal-overlay">
        <div class="modal-box space-y-4" style="border-color: #4a5568;">
            <div class="flex justify-between items-center border-b border-[#313244] pb-2">
                <h3 class="text-[#89b4fa] font-bold"><i class="fas fa-file-import mr-2"></i>åŒ¯å…¥ Regex è¦å‰‡</h3>
                <button onclick="closeImportConfirmModal()" class="text-[#6c7086] hover:text-white"><i
                        class="fas fa-times"></i></button>
            </div>
            <p id="importConfirmMessage" class="text-sm text-[#cdd6f4]">
                <!-- å‹•æ…‹å¡«å…¥è¦å‰‡æ•¸é‡ -->
            </p>
            <p class="text-xs text-[#6c7086]">
                <i class="fas fa-info-circle mr-1"></i>æç¤ºï¼šåªæœ‰ã€Œä¿®æ”¹é¡¯ç¤ºã€é¡å‹çš„è¦å‰‡æœƒé è¨­åœ¨é è¦½å€é¡¯ç¤ºï¼Œå…¶ä»–é¡å‹éœ€æ‰‹å‹•å‹¾é¸ã€‚
            </p>
            <div class="flex justify-end gap-2 pt-2">
                <button onclick="closeImportConfirmModal()"
                    class="px-3 py-1.5 text-xs text-[#bac2de] hover:text-white rounded border border-[#313244]">å–æ¶ˆ</button>
                <button onclick="performImportRules('merge')"
                    class="px-3 py-1.5 text-xs bg-[#45475a] hover:bg-[#89b4fa] hover:text-[#11111b] text-[#89b4fa] font-bold rounded">åˆä½µåŒ¯å…¥</button>
                <button onclick="performImportRules('replace')"
                    class="px-3 py-1.5 text-xs bg-[#f38ba8] hover:bg-[#ff6b8a] text-white font-bold rounded shadow-lg">è¦†è“‹ç¾æœ‰</button>
            </div>
        </div>
    </div>

    <!-- èªªæ˜ Modal -->
    <div id="helpModal" class="modal-overlay">
        <div class="modal-box space-y-3" style="max-width: 480px; max-height: 70vh; overflow-y: auto;">
            <div class="flex justify-between items-center border-b border-[#313244] pb-2">
                <h3 id="helpModalTitle" class="text-[#89b4fa] font-bold"><i class="fas fa-question-circle mr-2"></i>èªªæ˜
                </h3>
                <button onclick="closeHelpModal()" class="text-[#6c7086] hover:text-white"><i
                        class="fas fa-times"></i></button>
            </div>
            <div id="helpModalContent" class="text-sm text-[#cdd6f4] leading-relaxed">
                <!-- å‹•æ…‹è¼‰å…¥èªªæ˜å…§å®¹ -->
            </div>
            <div class="flex justify-end pt-2 border-t border-[#313244]">
                <button onclick="closeHelpModal()"
                    class="px-3 py-1.5 text-xs bg-[#45475a] hover:bg-[#585b70] rounded text-[#cdd6f4]">é—œé–‰</button>
            </div>
        </div>
    </div>

    <!-- åˆä½µè¤‡è£½ Modal -->
    <div id="mergeModal" class="modal-overlay">
        <div class="modal-box space-y-4" style="max-width: 420px;">
            <div class="flex justify-between items-center border-b border-[#313244] pb-2">
                <h3 class="text-[#89b4fa] font-bold"><i class="fas fa-file-export mr-2"></i>åˆä½µè¤‡è£½</h3>
                <button onclick="closeMergeModal()" class="text-[#6c7086] hover:text-white"><i
                        class="fas fa-times"></i></button>
            </div>

            <!-- é é¢é¸æ“‡ -->
            <div class="space-y-2">
                <label class="text-xs text-[#a6adc8] font-medium">ğŸ“„ é¸æ“‡ HTML é é¢</label>
                <select id="mergePageSelect" onchange="updateMergePreview()"
                    class="w-full bg-[#313244] text-[#cdd6f4] border border-[#45475a] rounded px-3 py-2 text-sm">
                    <!-- å‹•æ…‹å¡«å…¥ -->
                </select>
            </div>

            <!-- CSS é¸é … -->
            <div class="space-y-2">
                <label class="text-xs text-[#a6adc8] font-medium">ğŸ¨ CSS é¸é …</label>
                <div class="space-y-2 bg-[#1e1e2e] rounded p-3">
                    <label
                        class="flex items-center gap-2 text-sm text-[#cdd6f4] cursor-pointer hover:bg-[#313244] px-2 py-1 rounded transition">
                        <input type="checkbox" id="mergeGlobalCss" checked onchange="updateMergePreview()"
                            class="accent-[#89b4fa] w-4 h-4">
                        <span>ğŸŒ åŒ…å«å…¨åŸŸ CSS</span>
                    </label>
                    <label
                        class="flex items-center gap-2 text-sm text-[#cdd6f4] cursor-pointer hover:bg-[#313244] px-2 py-1 rounded transition">
                        <input type="checkbox" id="mergeLinkedCss" checked onchange="updateMergePreview()"
                            class="accent-[#89b4fa] w-4 h-4">
                        <span>ğŸ”— åŒ…å«é€£çµ CSS</span>
                    </label>
                </div>
            </div>

            <!-- é è¦½å€ -->
            <div class="space-y-2">
                <label class="text-xs text-[#a6adc8] font-medium">ğŸ“ å°‡æœƒåˆä½µ</label>
                <div id="mergePreview"
                    class="bg-[#1e1e2e] rounded p-3 text-xs text-[#6c7086] space-y-1 max-h-32 overflow-y-auto">
                    <!-- å‹•æ…‹å¡«å…¥ -->
                </div>
            </div>

            <!-- æŒ‰éˆ• -->
            <div class="flex justify-end gap-2 pt-2 border-t border-[#313244]">
                <button onclick="closeMergeModal()"
                    class="px-3 py-1.5 text-xs text-[#bac2de] hover:text-white rounded border border-[#313244]">å–æ¶ˆ</button>
                <button onclick="performMergedCopy()"
                    class="px-4 py-1.5 text-xs bg-[#89b4fa] hover:bg-[#a6c8ff] text-[#11111b] font-bold rounded shadow-lg flex items-center gap-2">
                    <i class="fas fa-copy"></i> è¤‡è£½
                </button>
            </div>
        </div>
    </div>

    <!-- è¨­å®š Modal -->
    <div id="settingsModal" class="modal-overlay">
        <div class="modal-box space-y-4" style="max-width: 480px;">
            <div class="flex justify-between items-center border-b border-[#313244] pb-2">
                <h3 class="text-[#f9e2af] font-bold"><i class="fas fa-cog mr-2"></i>è¨­å®š</h3>
                <button onclick="closeSettingsModal()" class="text-[#6c7086] hover:text-white"><i
                        class="fas fa-times"></i></button>
            </div>

            <!-- è¼¸å‡ºè™•ç† -->
            <div class="space-y-2">
                <label class="text-xs text-[#a6e3a1] font-bold flex items-center gap-1">
                    <span>ğŸ“</span> è¼¸å‡ºè™•ç†
                </label>
                <div class="bg-[#11111b] rounded p-3 space-y-2">
                    <label class="flex items-center gap-3 cursor-pointer">
                        <input type="checkbox" id="settingCleanEmptyLines" checked class="w-4 h-4 accent-[#89b4fa]"
                            onchange="toggleSetting('cleanEmptyLines')">
                        <div>
                            <span class="text-[#cdd6f4] text-sm">è‡ªå‹•æ¸…ç†ç©ºè¡Œ</span>
                            <p class="text-[#6c7086] text-xs">åˆä½µè¤‡è£½å’Œ Regex åŒ¯å‡ºæ™‚ç§»é™¤ç©ºç™½è¡Œ</p>
                        </div>
                    </label>
                </div>
            </div>

            <!-- å·¥ä½œç‹€æ…‹ -->
            <div class="space-y-2">
                <label class="text-xs text-[#89b4fa] font-bold flex items-center gap-1">
                    <span>ğŸ’¾</span> å·¥ä½œç‹€æ…‹
                </label>
                <div class="bg-[#11111b] rounded p-3 space-y-3">
                    <div class="flex gap-2">
                        <button onclick="importWorkspace()"
                            class="flex-1 px-3 py-2 text-xs bg-[#45475a] hover:bg-[#6c7086] text-[#cdd6f4] rounded flex items-center justify-center gap-2">
                            <span>ğŸ“¥</span> åŒ¯å…¥é€²åº¦
                        </button>
                        <button onclick="exportWorkspace()"
                            class="flex-1 px-3 py-2 text-xs bg-[#45475a] hover:bg-[#6c7086] text-[#cdd6f4] rounded flex items-center justify-center gap-2">
                            <span>ğŸ“¤</span> åŒ¯å‡ºé€²åº¦
                        </button>
                    </div>
                    <label class="flex items-center gap-3 cursor-pointer">
                        <input type="checkbox" id="settingIncludeImages" class="w-4 h-4 accent-[#89b4fa]"
                            onchange="toggleSetting('includeImages')">
                        <div>
                            <span class="text-[#cdd6f4] text-sm">åŒ…å«ä¸Šå‚³çš„åœ–ç‰‡</span>
                            <p class="text-[#6c7086] text-xs">åŒ¯å‡ºæ™‚ä¸€ä½µä¿å­˜åœ–ç‰‡ï¼ˆæª”æ¡ˆæœƒè¼ƒå¤§ï¼‰</p>
                        </div>
                    </label>
                    <p class="text-[#6c7086] text-xs">
                        ä¿å­˜/æ¢å¾©æ‰€æœ‰ç·¨è¼¯å™¨å…§å®¹ã€CSS åˆ†çµ„ã€HTML é é¢ã€Regex è¦å‰‡ç­‰
                    </p>
                </div>
            </div>
            <!-- å¿«æ·éµ/æ‰‹å‹¢æ“ä½œ -->
            <div class="space-y-2">
                <label class="text-xs text-[#fab387] font-bold flex items-center gap-1">
                    <span class="hidden md:inline">âŒ¨ï¸ å¿«æ·éµ</span>
                    <span class="md:hidden">ğŸ‘† æ‰‹å‹¢æ“ä½œ</span>
                </label>
                <div class="bg-[#11111b] rounded p-3">
                    <!-- æ¡Œé¢ç‰ˆï¼šéµç›¤å¿«æ·éµ -->
                    <ul class="text-[#a6adc8] text-xs space-y-1.5 hidden md:block">
                        <li class="flex justify-between"><span><kbd
                                    class="bg-[#313244] px-1.5 py-0.5 rounded">ESC</kbd></span> <span
                                class="text-[#6c7086]">é€€å‡ºå…¨è¢å¹•</span></li>
                        <li class="flex justify-between"><span><kbd
                                    class="bg-[#313244] px-1.5 py-0.5 rounded">Ctrl+Z</kbd></span> <span
                                class="text-[#6c7086]">æ’¤éŠ·</span></li>
                        <li class="flex justify-between"><span><kbd
                                    class="bg-[#313244] px-1.5 py-0.5 rounded">Ctrl+Y</kbd></span> <span
                                class="text-[#6c7086]">é‡åš</span></li>
                        <li class="flex justify-between"><span><kbd
                                    class="bg-[#313244] px-1.5 py-0.5 rounded">Ctrl+é»æ“Š</kbd></span> <span
                                class="text-[#6c7086]">å®šä½ CSS</span></li>
                        <li class="flex justify-between"><span><kbd
                                    class="bg-[#313244] px-1.5 py-0.5 rounded">Alt+é»æ“Š</kbd></span> <span
                                class="text-[#6c7086]">å®šä½ HTML</span></li>
                    </ul>
                    <!-- æ‰‹æ©Ÿç‰ˆï¼šè§¸æ§æ‰‹å‹¢ -->
                    <ul class="text-[#a6adc8] text-xs space-y-1.5 md:hidden">
                        <li class="flex justify-between"><span class="bg-[#313244] px-1.5 py-0.5 rounded">ğŸ‘† é•·æŒ‰</span>
                            <span class="text-[#6c7086]">å®šä½ CSS</span>
                        </li>
                        <li class="flex justify-between"><span class="bg-[#313244] px-1.5 py-0.5 rounded">ğŸ‘† é›™æ“Š</span>
                            <span class="text-[#6c7086]">å®šä½ HTML</span>
                        </li>
                    </ul>
                </div>
            </div>

            <!-- æŒ‰éˆ• -->
            <div class="flex justify-end pt-2 border-t border-[#313244]">
                <button onclick="closeSettingsModal()"
                    class="px-4 py-1.5 text-xs bg-[#45475a] hover:bg-[#6c7086] text-[#cdd6f4] rounded">
                    é—œé–‰
                </button>
            </div>
        </div>
    </div>

    <!-- HTML åˆ†é é¸å–® -->
    <div id="htmlTabMenu" class="tab-menu">
        <div class="tab-menu-item" onclick="menuRenamePage()">
            <span>ğŸ“</span> é‡å‘½å
        </div>
        <div class="tab-menu-item tab-menu-sub">
            <span>ğŸ”—</span> é€£æ¥ CSS
            <div class="tab-submenu" id="htmlCssSubmenu">
                <!-- å‹•æ…‹ç”Ÿæˆ CSS é¸é … -->
            </div>
        </div>
        <div class="tab-menu-divider"></div>
        <div class="tab-menu-item danger" onclick="menuDeletePage()">
            <span>ğŸ—‘ï¸</span> åˆªé™¤
        </div>
    </div>

    <!-- CSS åˆ†é é¸å–® -->
    <div id="cssTabMenu" class="tab-menu">
        <div class="tab-menu-item" onclick="menuRenameCss()">
            <span>ğŸ“</span> é‡å‘½å
        </div>
        <div class="tab-menu-item" onclick="menuToggleGlobal()">
            <span id="globalToggleIcon">ğŸŒ</span> <span id="globalToggleText">è¨­ç‚ºå…¨åŸŸ</span>
        </div>
        <div class="tab-menu-divider"></div>
        <div class="tab-menu-item danger" onclick="menuDeleteCss()">
            <span>ğŸ—‘ï¸</span> åˆªé™¤
        </div>
    </div>

    <!-- Regex æ–°å¢è¦å‰‡é¸å–® -->
    <div id="addRuleMenu" class="add-rule-menu">
        <div class="add-rule-menu-item" onclick="addNewRule()">
            <span>ğŸ“</span> æ–°å»ºç©ºç™½è¦å‰‡
        </div>
        <div class="add-rule-menu-item has-submenu" style="position: relative;">
            <span>ğŸ“¦</span> å¾ HTML æå–
            <span style="margin-left: auto; font-size: 0.7rem;">â–¶</span>
            <div class="add-rule-submenu" id="extractHtmlSubmenu">
                <div class="add-rule-submenu-inner">
                    <!-- å‹•æ…‹ç”Ÿæˆ HTML é é¢åˆ—è¡¨ -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Monaco Editor ç›¸é—œè®Šæ•¸ ---
        let cssEditor = null;
        let htmlEditor = null;
        let regexPatternEditor = null;  // Regex IN ç·¨è¼¯å™¨
        let regexOutputEditor = null;   // Regex OUT ç·¨è¼¯å™¨
        let storyEditor = null;         // åŠ‡æƒ… Tab ç·¨è¼¯å™¨
        let monacoReady = false;
        let currentMobileView = 'editor'; // 'editor' | 'preview' | 'both'

        // --- CSS åˆ†çµ„ç®¡ç† ---
        let cssGroups = [
            { id: 'css-1', name: 'å…¨åŸŸæ¨£å¼', content: '', isGlobal: true }
        ];
        let activeCssId = 'css-1';
        let cssCounter = 1;

        // --- å¤šé é¢ç®¡ç† ---
        let htmlPages = [
            { id: 'page-1', name: 'é¦–é ', content: '', linkedCss: null }  // linkedCss: null è¡¨ç¤ºåªç”¨å…¨åŸŸ CSS
        ];
        let activePageId = 'page-1';
        let pageCounter = 1;

        // --- åˆ†é é¸å–®ç‹€æ…‹ ---
        let menuTargetId = null;  // ç•¶å‰é¸å–®æ“ä½œçš„ç›®æ¨™ ID
        let menuType = null;      // 'html' æˆ– 'css'

        // --- Regex è¦å‰‡ç®¡ç† ---
        let regexRules = [
            {
                id: 'rule-1',
                name: 'æ–°è¦å‰‡',
                type: 'editdisplay',
                pattern: '',
                flags: 'gi',
                output: '',
                enabled: true
            }
        ];
        let activeRuleId = 'rule-1';
        let ruleCounter = 1;

        // --- æ‡‰ç”¨ç¨‹å¼è¨­å®š ---
        let appSettings = {
            cleanEmptyLines: true,   // åˆä½µè¤‡è£½/åŒ¯å‡ºæ™‚æ¸…ç†ç©ºè¡Œ
            includeImages: false     // åŒ¯å‡ºé€²åº¦æ™‚åŒ…å«åœ–ç‰‡
        };

        // é¡¯ç¤º HTML åˆ†é é¸å–®
        function showHtmlTabMenu(pageId, event) {
            event.stopPropagation();
            menuTargetId = pageId;
            menuType = 'html';

            const menu = document.getElementById('htmlTabMenu');
            const page = htmlPages.find(p => p.id === pageId);

            // æ›´æ–° CSS é€£æ¥å­é¸å–®
            const submenu = document.getElementById('htmlCssSubmenu');
            let submenuHtml = `<div class="tab-submenu-inner">`;

            submenuHtml += `<div class="tab-submenu-item ${!page.linkedCss ? 'active' : ''}" onclick="linkCssToPage(null)">
                <span>âŒ</span> ç„¡ï¼ˆåƒ…ç”¨å…¨åŸŸï¼‰
            </div>`;

            cssGroups.filter(c => !c.isGlobal).forEach(css => {
                const isActive = page.linkedCss === css.id;
                submenuHtml += `<div class="tab-submenu-item ${isActive ? 'active' : ''}" onclick="linkCssToPage('${css.id}')">
                    <span>ğŸ“„</span> ${css.name}
                </div>`;
            });

            if (cssGroups.filter(c => !c.isGlobal).length === 0) {
                submenuHtml += `<div class="tab-submenu-item" style="opacity: 0.5; cursor: default;">
                    <span>ğŸ’¡</span> ç„¡ç¨ç«‹ CSS
                </div>`;
            }

            submenuHtml += `</div>`; // é—œé–‰ tab-submenu-inner

            submenu.innerHTML = submenuHtml;

            // å®šä½é¸å–®
            positionMenu(menu, event);
        }

        // é¡¯ç¤º CSS åˆ†é é¸å–®
        function showCssTabMenu(cssId, event) {
            event.stopPropagation();
            menuTargetId = cssId;
            menuType = 'css';

            const menu = document.getElementById('cssTabMenu');
            const css = cssGroups.find(c => c.id === cssId);

            // æ›´æ–°å…¨åŸŸåˆ‡æ›æ–‡å­—
            document.getElementById('globalToggleIcon').textContent = css.isGlobal ? 'ğŸ“„' : 'ğŸŒ';
            document.getElementById('globalToggleText').textContent = css.isGlobal ? 'è¨­ç‚ºç¨ç«‹' : 'è¨­ç‚ºå…¨åŸŸ';

            // å®šä½é¸å–®
            positionMenu(menu, event);
        }

        // å®šä½é¸å–®
        function positionMenu(menu, event) {
            menu.classList.add('show');

            const rect = event.target.closest('.page-tab').getBoundingClientRect();
            let left = rect.left;
            let top = rect.bottom + 4;

            // ç¢ºä¿é¸å–®ä¸è¶…å‡ºè¦–çª—
            if (left + menu.offsetWidth > window.innerWidth) {
                left = window.innerWidth - menu.offsetWidth - 10;
            }
            if (top + menu.offsetHeight > window.innerHeight) {
                top = rect.top - menu.offsetHeight - 4;
            }

            menu.style.left = left + 'px';
            menu.style.top = top + 'px';
        }

        // éš±è—æ‰€æœ‰é¸å–®
        function hideAllMenus() {
            document.querySelectorAll('.tab-menu').forEach(menu => {
                menu.classList.remove('show');
            });
            menuTargetId = null;
            menuType = null;
        }

        // é»æ“Šå…¶ä»–åœ°æ–¹é—œé–‰é¸å–®
        document.addEventListener('click', hideAllMenus);

        // --- é¸å–®æ“ä½œå‡½æ•¸ ---

        // HTML: é‡å‘½å
        function menuRenamePage() {
            // ğŸ”§ ä¿®å¾©ï¼šå…ˆä¿å­˜ targetIdï¼Œå› ç‚º hideAllMenus() æœƒæ¸…ç©º menuTargetId
            const targetId = menuTargetId;
            hideAllMenus();
            if (!targetId) return;
            renamePage(targetId);
        }

        // HTML: åˆªé™¤
        function menuDeletePage() {
            // ğŸ”§ ä¿®å¾©ï¼šå…ˆä¿å­˜ targetIdï¼Œå› ç‚º hideAllMenus() æœƒæ¸…ç©º menuTargetId
            const targetId = menuTargetId;
            hideAllMenus();
            if (!targetId) return;
            deletePage(targetId);
        }

        // HTML: é€£æ¥ CSS
        function linkCssToPage(cssId) {
            // ğŸ”§ ä¿®å¾©ï¼šå…ˆä¿å­˜ targetIdï¼Œå› ç‚º hideAllMenus() æœƒæ¸…ç©º menuTargetId
            const targetId = menuTargetId;
            hideAllMenus();
            if (!targetId) return;

            const page = htmlPages.find(p => p.id === targetId);
            if (page) {
                page.linkedCss = cssId;
                renderPageTabs();
                render();
            }
        }

        // CSS: é‡å‘½å
        function menuRenameCss() {
            const targetId = menuTargetId;
            hideAllMenus();
            if (!targetId) return;
            renameCss(targetId);
        }

        // CSS: åˆ‡æ›å…¨åŸŸ
        function menuToggleGlobal() {
            const targetId = menuTargetId;
            hideAllMenus();
            if (!targetId) return;
            toggleCssGlobal(targetId);
        }

        // CSS: åˆªé™¤
        function menuDeleteCss() {
            const targetId = menuTargetId;
            hideAllMenus();
            if (!targetId) return;
            deleteCss(targetId);
        }

        // ============================================
        // Regex è¦å‰‡ç®¡ç†å‡½æ•¸
        // ============================================

        // æ¸²æŸ“è¦å‰‡åˆ—è¡¨
        function renderRuleList() {
            const container = document.getElementById('regexRuleList');
            if (!container) return;

            container.innerHTML = regexRules.map(rule => `
                <div class="regex-rule-item ${rule.id === activeRuleId ? 'active' : ''}" 
                     onclick="switchRule('${rule.id}')">
                    <input type="checkbox" class="rule-toggle" 
                           ${rule.enabled ? 'checked' : ''} 
                           onclick="event.stopPropagation(); toggleRuleEnabled('${rule.id}')">
                    <span class="rule-name">${rule.name || 'æœªå‘½å'}</span>
                    <button class="rule-delete-btn" onclick="event.stopPropagation(); deleteRule('${rule.id}')" title="åˆªé™¤è¦å‰‡">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                </div>
            `).join('');
        }

        // å„²å­˜ç•¶å‰ç·¨è¼¯çš„è¦å‰‡
        function saveCurrentRule() {
            const rule = regexRules.find(r => r.id === activeRuleId);
            if (!rule) return;

            rule.name = document.getElementById('ruleNameInput').value;
            rule.type = document.getElementById('ruleTypeSelect').value;
            rule.flags = document.getElementById('ruleFlagsInput').value;
            // ä½¿ç”¨ Monaco ç·¨è¼¯å™¨å–å¾—å…§å®¹
            rule.pattern = regexPatternEditor ? regexPatternEditor.getValue() : '';
            rule.output = regexOutputEditor ? regexOutputEditor.getValue() : '';

            renderRuleList();
        }

        // è¼‰å…¥è¦å‰‡åˆ°ç·¨è¼¯å™¨
        function loadRuleToEditor(rule) {
            document.getElementById('ruleNameInput').value = rule.name || '';
            document.getElementById('ruleTypeSelect').value = rule.type || 'editdisplay';
            document.getElementById('ruleFlagsInput').value = rule.flags || 'gi';
            // ä½¿ç”¨ Monaco ç·¨è¼¯å™¨è¨­å®šå…§å®¹
            if (regexPatternEditor) regexPatternEditor.setValue(rule.pattern || '');
            if (regexOutputEditor) regexOutputEditor.setValue(rule.output || '');
        }

        // åˆ‡æ›è¦å‰‡
        function switchRule(ruleId) {
            saveCurrentRule();
            activeRuleId = ruleId;
            const rule = regexRules.find(r => r.id === ruleId);
            if (rule) {
                loadRuleToEditor(rule);
            }
            renderRuleList();
        }

        // åˆ‡æ›è¦å‰‡å•Ÿç”¨ç‹€æ…‹
        function toggleRuleEnabled(ruleId) {
            const rule = regexRules.find(r => r.id === ruleId);
            if (rule) {
                rule.enabled = !rule.enabled;
                renderRuleList();
                // ğŸ”§ ä¿®å¾©ï¼šå‹¾é¸/å–æ¶ˆå‹¾é¸æ™‚åˆ·æ–°é è¦½
                if (previewMode === 'regex') {
                    render();
                }
            }
        }

        // æ–°å¢ç©ºç™½è¦å‰‡
        function addNewRule() {
            hideAddRuleMenu();
            ruleCounter++;
            const newRule = {
                id: `rule-${Date.now()}`,
                name: `è¦å‰‡ ${ruleCounter}`,
                type: 'editdisplay',
                pattern: '',
                flags: 'gi',
                output: '',
                enabled: true
            };
            regexRules.push(newRule);
            activeRuleId = newRule.id;
            loadRuleToEditor(newRule);
            renderRuleList();
        }

        // å¾ HTML æå–è¦å‰‡
        function extractRuleFromHtml(pageId) {
            hideAddRuleMenu();
            const page = htmlPages.find(p => p.id === pageId);
            if (!page) return;

            // åˆä½µ CSSï¼šå…¨åŸŸ CSS + é€£æ¥çš„ç¨ç«‹ CSS
            let combinedCss = '';
            cssGroups.filter(c => c.isGlobal).forEach(c => {
                combinedCss += c.content + '\n';
            });
            if (page.linkedCss) {
                const linkedCss = cssGroups.find(c => c.id === page.linkedCss);
                if (linkedCss) {
                    combinedCss += linkedCss.content + '\n';
                }
            }

            // çµ„åˆè¼¸å‡º
            const output = `<style>\n${combinedCss}</style>\n${page.content}`;

            ruleCounter++;
            const newRule = {
                id: `rule-${Date.now()}`,
                name: page.name,
                type: 'editdisplay',
                pattern: '',
                flags: 'gi',
                output: output,
                enabled: true
            };
            regexRules.push(newRule);
            activeRuleId = newRule.id;
            loadRuleToEditor(newRule);
            renderRuleList();
        }

        // åˆªé™¤è¦å‰‡
        function deleteRule(ruleId) {
            if (regexRules.length <= 1) {
                alert('è‡³å°‘éœ€è¦ä¿ç•™ä¸€æ¢è¦å‰‡');
                return;
            }
            const index = regexRules.findIndex(r => r.id === ruleId);
            if (index !== -1) {
                regexRules.splice(index, 1);
                if (activeRuleId === ruleId) {
                    activeRuleId = regexRules[0].id;
                    loadRuleToEditor(regexRules[0]);
                }
                renderRuleList();
            }
        }

        // ===== RISU Regex åŒ¯å…¥åŒ¯å‡ºåŠŸèƒ½ =====

        // åŒ¯å‡ºè¦å‰‡ç‚º RISU æ ¼å¼
        function exportRegexRules() {
            // å…ˆå„²å­˜ç•¶å‰ç·¨è¼¯çš„è¦å‰‡
            saveCurrentRule();

            // å…§éƒ¨é¡å‹ â†’ RISU é¡å‹çš„æ˜ å°„ (è™•ç† RISU ä½¿ç”¨ä¸åŒåç¨±çš„æƒ…æ³)
            const internalToRisuType = {
                'editdisplay': 'editdisplay',
                'editinput': 'editinput',
                'editoutput': 'editoutput',
                'editrequest': 'editprocess',   // æˆ‘å€‘çš„ editrequest = RISU çš„ editprocess (ä¿®æ”¹è«‹æ±‚)
                'edittranslate': 'edittrans',   // æˆ‘å€‘çš„ edittranslate = RISU çš„ edittrans (ä¿®æ”¹ç¿»è­¯)
                'disabled': 'disabled'
            };

            // è½‰æ›ç‚º RISU æ ¼å¼
            // æ³¨æ„ï¼šenabled åªå½±éŸ¿æœ¬å·¥å…·çš„é è¦½é¡¯ç¤ºï¼Œä¸å½±éŸ¿åŒ¯å‡ºçš„ type
            // åŒ¯å‡ºæ™‚æ ¹æ“š type === 'disabled' åˆ¤æ–·æ˜¯å¦ç‚ºé—œé–‰ç‹€æ…‹
            const risuData = {
                type: "regex",
                data: regexRules.map(rule => {
                    // è½‰æ›é¡å‹ç‚º RISU æ ¼å¼
                    const risuType = internalToRisuType[rule.type] || rule.type;
                    
                    return {
                        comment: rule.name || 'æœªå‘½åè¦å‰‡',
                        in: rule.pattern || '',
                        out: cleanEmptyLines(rule.output || ''),
                        type: risuType,
                        ableFlag: false,
                        flag: rule.flags || 'gi'
                    };
                })
            };

            // ä¸‹è¼‰ JSON æª”æ¡ˆ
            const blob = new Blob([JSON.stringify(risuData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'regexscript_export.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            alert(`âœ… å·²åŒ¯å‡º ${regexRules.length} æ¢è¦å‰‡ï¼`);
        }

        // åŒ¯å…¥ RISU æ ¼å¼è¦å‰‡
        function importRegexRules() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';

            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const data = JSON.parse(text);

                    // é©—è­‰æ ¼å¼
                    if (data.type !== 'regex' || !Array.isArray(data.data)) {
                        alert('âŒ ç„¡æ•ˆçš„ RISU Regex æ ¼å¼ï¼\n\nè«‹ç¢ºä¿ JSON åŒ…å« "type": "regex" å’Œ "data" é™£åˆ—ã€‚');
                        return;
                    }

                    // RISU é¡å‹ â†’ å…§éƒ¨é¡å‹çš„æ˜ å°„ (è™•ç† RISU ä½¿ç”¨ä¸åŒåç¨±çš„æƒ…æ³)
                    const risuToInternalType = {
                        'editdisplay': 'editdisplay',
                        'editinput': 'editinput',
                        'editoutput': 'editoutput',
                        'editprocess': 'editrequest',   // RISU çš„ editprocess = æˆ‘å€‘çš„ editrequest (ä¿®æ”¹è«‹æ±‚)
                        'editrequest': 'editrequest',   // ç›¸å®¹èˆŠæ ¼å¼
                        'edittrans': 'edittranslate',   // RISU çš„ edittrans = æˆ‘å€‘çš„ edittranslate (ä¿®æ”¹ç¿»è­¯)
                        'edittranslate': 'edittranslate', // ç›¸å®¹èˆŠæ ¼å¼
                        'disabled': 'disabled'
                    };
                    
                    // è½‰æ›ç‚ºå…§éƒ¨æ ¼å¼
                    const importedRules = data.data.map((item, i) => {
                        // ä½¿ç”¨æ˜ å°„è¡¨è½‰æ›é¡å‹ï¼Œå¦‚æœæ‰¾ä¸åˆ°å‰‡é è¨­ç‚º editdisplay
                        let ruleType = risuToInternalType[item.type] || 'editdisplay';
                        
                        // æ ¹æ“šé¡å‹æ±ºå®šæ˜¯å¦åœ¨é è¦½å€é¡¯ç¤º
                        // åªæœ‰ editdisplay (ä¿®æ”¹é¡¯ç¤º) é¡å‹é è¨­å•Ÿç”¨ï¼Œå…¶ä»–é¡å‹é è¨­ä¸å•Ÿç”¨
                        const shouldEnableInPreview = (ruleType === 'editdisplay');
                        
                        return {
                            id: `rule-${Date.now()}-${i}`,
                            name: item.comment || 'åŒ¯å…¥çš„è¦å‰‡',
                            type: ruleType,
                            pattern: item.in || '',
                            flags: item.flag || 'gi',
                            output: item.out || '',
                            enabled: shouldEnableInPreview
                        };
                    });

                    // æš«å­˜å¾…åŒ¯å…¥çš„è¦å‰‡ï¼Œç­‰å¾…ç”¨æˆ¶ç¢ºèª
                    window.pendingImportRules = importedRules;
                    
                    // é¡¯ç¤ºç¢ºèª Modal
                    const displayCount = importedRules.filter(r => r.type === 'editdisplay').length;
                    const otherCount = importedRules.length - displayCount;
                    document.getElementById('importConfirmMessage').innerHTML = 
                        `ğŸ“¥ ç™¼ç¾ <strong>${importedRules.length}</strong> æ¢è¦å‰‡<br><br>` +
                        `â€¢ ä¿®æ”¹é¡¯ç¤ºï¼š${displayCount} æ¢ï¼ˆæœƒåœ¨é è¦½å€é¡¯ç¤ºï¼‰<br>` +
                        `â€¢ å…¶ä»–é¡å‹ï¼š${otherCount} æ¢ï¼ˆé è¨­ä¸é¡¯ç¤ºï¼‰`;
                    document.getElementById('importConfirmModal').style.display = 'flex';

                } catch (err) {
                    alert(`âŒ åŒ¯å…¥å¤±æ•—ï¼š${err.message}`);
                }
            };

            input.click();
        }

        // é—œé–‰åŒ¯å…¥ç¢ºèª Modal
        function closeImportConfirmModal() {
            document.getElementById('importConfirmModal').style.display = 'none';
            window.pendingImportRules = null;
        }

        // åŸ·è¡ŒåŒ¯å…¥æ“ä½œ
        function performImportRules(mode) {
            const importedRules = window.pendingImportRules;
            if (!importedRules) return;

            if (mode === 'replace') {
                regexRules = importedRules;
                ruleCounter = importedRules.length;
            } else {
                regexRules = regexRules.concat(importedRules);
                ruleCounter = regexRules.length;
            }

            // è¼‰å…¥ç¬¬ä¸€æ¢è¦å‰‡
            if (regexRules.length > 0) {
                activeRuleId = regexRules[0].id;
                loadRuleToEditor(regexRules[0]);
            }

            renderRuleList();
            closeImportConfirmModal();

            alert(`âœ… å·²${mode === 'replace' ? 'è¦†è“‹' : 'åˆä½µ'}åŒ¯å…¥ ${importedRules.length} æ¢è¦å‰‡ï¼`);
        }

        // é¡¯ç¤ºæ–°å¢è¦å‰‡é¸å–®
        function showAddRuleMenu(event) {
            event.stopPropagation();
            const menu = document.getElementById('addRuleMenu');

            // æ›´æ–° HTML æå–å­é¸å–®
            const submenuInner = document.querySelector('#extractHtmlSubmenu .add-rule-submenu-inner');
            submenuInner.innerHTML = htmlPages.map(page => {
                const linkedCssName = page.linkedCss ?
                    (cssGroups.find(c => c.id === page.linkedCss)?.name || '') : '';
                return `<div class="add-rule-menu-item" onclick="extractRuleFromHtml('${page.id}')">
                    <span>ğŸ“„</span> ${page.name}${linkedCssName ? ` (ğŸ”—${linkedCssName})` : ''}
                </div>`;
            }).join('');

            // å®šä½é¸å–®
            const rect = event.target.getBoundingClientRect();
            menu.style.left = rect.left + 'px';
            menu.style.bottom = (window.innerHeight - rect.top + 5) + 'px';
            menu.style.top = 'auto';
            menu.classList.add('show');
        }

        // éš±è—æ–°å¢è¦å‰‡é¸å–®
        function hideAddRuleMenu() {
            document.getElementById('addRuleMenu').classList.remove('show');
        }

        // è¦å‰‡ç·¨è¼¯å™¨è‡ªå‹•å„²å­˜
        ['ruleNameInput', 'ruleTypeSelect', 'ruleFlagsInput', 'rulePatternInput', 'ruleOutputInput'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('input', saveCurrentRule);
                el.addEventListener('change', saveCurrentRule);
            }
        });

        // é»æ“Šå…¶ä»–åœ°æ–¹é—œé–‰é¸å–®
        document.addEventListener('click', function (e) {
            if (!e.target.closest('.add-rule-menu') && !e.target.closest('.regex-add-btn')) {
                hideAddRuleMenu();
            }
        });

        // --- æ‰‹æ©Ÿç‰ˆè¦–åœ–åˆ‡æ› ---
        function setMobileView(mode) {
            currentMobileView = mode;
            const editorPanel = document.getElementById('editorPanel');
            const previewPanel = document.getElementById('previewPanel');

            // é‡ç½®æ‰€æœ‰ class
            editorPanel.classList.remove('hidden', 'h-full', 'h-[55vh]');
            previewPanel.classList.remove('hidden', 'h-full', 'h-[45vh]');

            if (mode === 'editor') {
                // åªé¡¯ç¤ºç·¨è¼¯å™¨
                editorPanel.classList.add('h-full');
                previewPanel.classList.add('hidden');
            } else if (mode === 'preview') {
                // åªé¡¯ç¤ºé è¦½
                editorPanel.classList.add('hidden');
                previewPanel.classList.add('h-full');
            } else { // 'both'
                // åˆ†å‰²è¦–åœ–
                editorPanel.classList.add('h-[55vh]');
                previewPanel.classList.add('h-[45vh]');
            }

            // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            updateMobileViewButtons(mode);

            // é‡æ–°è¨ˆç®— Monaco editor å°ºå¯¸
            setTimeout(() => {
                if (cssEditor) cssEditor.layout();
                if (htmlEditor) htmlEditor.layout();
            }, 100);
        }

        function updateMobileViewButtons(mode) {
            const editorBtn = document.getElementById('mobileViewEditor');
            const previewBtn = document.getElementById('mobileViewPreview');
            const bothBtn = document.getElementById('mobileViewBoth');

            const activeClass = 'bg-[#89b4fa] text-[#11111b] font-bold';
            const inactiveClass = 'bg-[#313244] text-[#a6adc8] hover:bg-[#45475a]';

            [editorBtn, previewBtn, bothBtn].forEach(btn => {
                if (btn) {
                    btn.className = btn.className.replace(/bg-\[#[^\]]+\]|text-\[#[^\]]+\]|font-bold|hover:bg-\[#[^\]]+\]/g, '').trim();
                }
            });

            if (editorBtn) editorBtn.className = `px-2 py-1 text-[10px] rounded ${mode === 'editor' ? activeClass : inactiveClass}`;
            if (previewBtn) previewBtn.className = `px-2 py-1 text-[10px] rounded ${mode === 'preview' ? activeClass : inactiveClass}`;
            if (bothBtn) bothBtn.className = `px-2 py-1 text-[10px] rounded ${mode === 'both' ? activeClass : inactiveClass}`;
        }

        // --- èªªæ˜ç³»çµ± ---
        const helpContents = {
            varControl: {
                title: 'è®Šæ•¸æ§åˆ¶å°',
                content: `
                    <div class="space-y-3">
                        <p><b>åŠŸèƒ½ï¼š</b>å°‡ CSS ä¸­çš„æ•¸å€¼ï¼ˆé¡è‰²ã€å°ºå¯¸ç­‰ï¼‰æç…‰æˆå¯èª¿æ•´çš„è®Šæ•¸ï¼Œæ–¹ä¾¿å³æ™‚èª¿æ•´æ¨£å¼ã€‚</p>
                        <hr class="border-[#313244]">
                        <p><b>æ“ä½œæ–¹å¼ï¼š</b></p>
                        <ul class="list-disc list-inside space-y-1 text-[#a6adc8]">
                            <li><b>æ™ºæ…§æç…‰ï¼š</b>è‡ªå‹•åˆ†æ CSSï¼Œå°‡æ•¸å€¼è½‰æ›æˆ CSS è®Šæ•¸</li>
                            <li><b>ç¯„åœæ»‘æ¡¿ï¼š</b>å·¦å³æ‹–å‹•èª¿æ•´æ•¸å€¼ï¼Œå³æ™‚é è¦½æ•ˆæœ</li>
                            <li><b>ğŸ” æ”¾å¤§é¡ï¼š</b>é»æ“Šè·³è½‰åˆ° CSS ç·¨è¼¯å™¨ä¸­è©²è®Šæ•¸çš„ä½ç½®</li>
                            <li><b>ğŸ”¥ ç‡’éŒ„ï¼š</b>å°‡ç›®å‰è®Šæ•¸å€¼æ°¸ä¹…å¯«å…¥ CSS</li>
                        </ul>
                        <hr class="border-[#313244]">
                        <p><b>æç…‰ç¯©é¸ï¼š</b>é»æ“Šã€Œ<i class="fas fa-filter"></i>ã€æ¼æ–—åœ–ç¤ºå¯é¸æ“‡è¦æç…‰çš„é¡å‹ï¼ˆé¡è‰²ã€å°ºå¯¸ã€è§’åº¦ç­‰ï¼‰</p>
                        <p class="text-[#6c7086] text-xs">æç¤ºï¼šè®Šæ•¸æœƒæŒ‰ CSS é¸æ“‡å™¨åˆ†çµ„ï¼Œé»æ“Šåˆ†çµ„æ¨™é¡Œå¯å±•é–‹/æ”¶åˆ</p>
                    </div>
                `
            },
            risuVars: {
                title: 'RISU è®Šæ•¸æ¨¡æ“¬',
                content: `
                    <div class="space-y-3">
                        <p><b>åŠŸèƒ½ï¼š</b>æ¨¡æ“¬ RisuAI å¹³å°çš„ CBS è®Šæ•¸ç³»çµ±ï¼Œè®“ä½ ä¸ç”¨ä¸Šå‚³åˆ°å¹³å°å°±èƒ½é è¦½è®Šæ•¸æ•ˆæœã€‚</p>
                        <hr class="border-[#313244]">
                        <p><b>æ“ä½œæ–¹å¼ï¼š</b></p>
                        <ul class="list-disc list-inside space-y-1 text-[#a6adc8]">
                            <li><b>ğŸ“¡ æƒæï¼š</b>è‡ªå‹•åˆ†æ HTML/CSS ä¸­çš„ RISU è®Šæ•¸èªæ³•</li>
                            <li><b>â• æ‰‹å‹•ï¼š</b>æ‰‹å‹•æ·»åŠ æ¨¡æ“¬è®Šæ•¸ä¸¦è¨­å®šæ¸¬è©¦å€¼</li>
                            <li><b>ğŸ—‘ï¸ æ¸…é™¤ï¼š</b>æ¸…ç©ºæ‰€æœ‰æ¨¡æ“¬è®Šæ•¸</li>
                            <li><b>ğŸ“¤ ä¸Šå‚³åœ–ç‰‡ï¼š</b>ä¸Šå‚³è‡ªè¨‚åœ–ç‰‡ç”¨æ–¼åœ–ç‰‡è³‡ç”¢é è¦½</li>
                            <li><b>ğŸ” æ”¾å¤§é¡ï¼š</b>é»æ“Šè·³è½‰åˆ°ç·¨è¼¯å™¨ä¸­è©²è®Šæ•¸çš„ä½ç½®</li>
                        </ul>
                        <hr class="border-[#313244]">
                        <p><b>æ”¯æ´çš„èªæ³•ï¼š</b></p>
                        <ul class="list-disc list-inside space-y-1 text-[#a6adc8] text-xs">
                            <li>{{getvar::è®Šæ•¸å}}ã€{{gettempvar::è®Šæ•¸å}}</li>
                            <li>{{image::è³‡ç”¢å}}ã€{{img::è³‡ç”¢å}}ã€{{bg::è³‡ç”¢å}}</li>
                            <li>{{#if æ¢ä»¶}}...{{/if}}ã€{{#if_pure ...}}</li>
                            <li>{{equal::A::B}}ã€{{greater::A::B}} ç­‰æ¯”è¼ƒå‡½æ•¸</li>
                        </ul>
                    </div>
                `
            },
            snippets: {
                title: 'CSS ç‰‡æ®µ/éŸ¿æ‡‰å¼è¼”åŠ©',
                content: `
                    <div class="space-y-3">
                        <p><b>åŠŸèƒ½ï¼š</b>å¿«é€Ÿæ’å…¥å¸¸ç”¨ CSS ç¨‹å¼ç¢¼ç‰‡æ®µï¼Œè¼”åŠ©å»ºç«‹éŸ¿æ‡‰å¼è¨­è¨ˆã€‚</p>
                        <hr class="border-[#313244]">
                        <p><b>CSS ç‰‡æ®µï¼š</b></p>
                        <ul class="list-disc list-inside space-y-1 text-[#a6adc8]">
                            <li>é»æ“Šç‰‡æ®µæ¨™ç±¤ï¼Œè‡ªå‹•åœ¨æ¸¸æ¨™ä½ç½®æ’å…¥ç¨‹å¼ç¢¼</li>
                            <li>å¯è‡ªè¨‚ç‰‡æ®µä¸¦åŒ¯å…¥/åŒ¯å‡º</li>
                        </ul>
                        <hr class="border-[#313244]">
                        <p><b>éŸ¿æ‡‰å¼è¼”åŠ©ï¼š</b></p>
                        <ul class="list-disc list-inside space-y-1 text-[#a6adc8]">
                            <li>å…ˆç”¨ã€ŒCtrl+é»æ“Šã€åœ¨é è¦½å€é¸å–å…ƒç´ </li>
                            <li>é»æ“Šæ•ˆæœæŒ‰éˆ•ï¼ˆå¦‚ã€Œéš±è—ã€ã€Œæ»¿ç‰ˆå¯¬åº¦ã€ï¼‰ï¼Œè‡ªå‹•ç”¢ç”Ÿ @media è¦å‰‡</li>
                            <li>æ‰‹æ©Ÿç‰ˆï¼šâ‰¤768pxã€å¹³æ¿ç‰ˆï¼š769px~1024px</li>
                        </ul>
                    </div>
                `
            },
            preview: {
                title: 'å³æ™‚é è¦½',
                content: `
                    <div class="space-y-3">
                        <p><b>åŠŸèƒ½ï¼š</b>å³æ™‚é¡¯ç¤º HTML/CSS çš„æ¸²æŸ“çµæœã€‚</p>
                        <hr class="border-[#313244]">
                        <p><b>é è¦½æ¨¡å¼ï¼š</b></p>
                        <ul class="list-disc list-inside space-y-1 text-[#a6adc8]">
                            <li><b>ç°¡æ˜“ï¼š</b>ç›´æ¥æ¸²æŸ“ HTML/CSS ç·¨è¼¯å™¨å…§å®¹</li>
                            <li><b>Regexï¼š</b>ä½¿ç”¨æ­£è¦è¡¨é”å¼è™•ç†æ¸¬è©¦è³‡æ–™å¾Œæ¸²æŸ“</li>
                        </ul>
                        <hr class="border-[#313244]">
                        <p><b>é¸å–èˆ‡å®šä½åŠŸèƒ½ï¼š</b></p>
                        <ul class="list-disc list-inside space-y-1 text-[#a6adc8]">
                            <li><b>Ctrl+é»æ“Šï¼š</b>é¸å–å…ƒç´ ä¸¦å®šä½ CSS è¦å‰‡</li>
                            <li><b>Alt+é»æ“Šï¼š</b>å®šä½ HTML å…ƒç´ ä½ç½®</li>
                            <li>é¸å–å¾Œå¯æ‹–å‹•æ§åˆ¶æŸ„èª¿æ•´å¤§å°/é‚Šè·</li>
                            <li>é¸å–å¾Œå¯ç”¨ã€ŒéŸ¿æ‡‰å¼è¼”åŠ©ã€å¿«é€Ÿæ·»åŠ æ–·é»æ¨£å¼</li>
                        </ul>
                        <hr class="border-[#313244]">
                        <p><b>é è¦½å°ºå¯¸ï¼š</b>æ‹–å‹•å³å´æ»‘æ¡¿èª¿æ•´é è¦½å¯¬åº¦ï¼ˆæ¨¡æ“¬ä¸åŒè£ç½®ï¼‰</p>
                    </div>
                `
            },
            editor: {
                title: 'ç·¨è¼¯å™¨',
                content: `
                    <div class="space-y-3">
                        <p><b>åŠŸèƒ½ï¼š</b>ç·¨å¯« CSSã€HTML å’Œè¨­å®š Regex è¦å‰‡ã€‚</p>
                        <hr class="border-[#313244]">
                        <p><b>åˆ†é èªªæ˜ï¼š</b></p>
                        <ul class="list-disc list-inside space-y-1 text-[#a6adc8]">
                            <li><b>CSSï¼š</b>æ¨£å¼ç·¨è¼¯å™¨ï¼ˆæ”¯æ´åŒæ™‚æ”¾å…¥CSS+HTMLï¼‰</li>
                            <li><b>HTMLï¼š</b>HTML æ¨¡æ¿ç·¨è¼¯å™¨</li>
                            <li><b>Regexï¼š</b>è¨­å®šæ­£è¦è¡¨é”å¼å’Œæ¸¬è©¦è³‡æ–™</li>
                        </ul>
                        <hr class="border-[#313244]">
                        <p><b>å¿«æ·éµï¼š</b></p>
                        <ul class="list-disc list-inside space-y-1 text-[#a6adc8]">
                            <li><b>ESCï¼š</b>é€€å‡ºå…¨è¢å¹•</li>
                            <li><b>Ctrl+Zï¼š</b>å¾©åŸï¼ˆç·¨è¼¯å™¨å…§ / è®Šæ•¸æ§åˆ¶å°ï¼‰</li>
                            <li><b>Ctrl+Yï¼š</b>é‡åš</li>
                        </ul>
                        <hr class="border-[#313244]">
                        <p><b>æç…‰é¸å–ï¼š</b>åœ¨ CSS ç·¨è¼¯å™¨ä¸­é¸å–ä¸€æ®µç¨‹å¼ç¢¼å¾Œï¼Œé»æ“Šå³ä¸‹è§’çš„ã€Œæç…‰é¸å–ã€æŒ‰éˆ•ï¼Œå¯å–®ç¨å°é¸å–çš„ç‰‡æ®µé€²è¡Œè®Šæ•¸æç…‰ã€‚</p>
                        <p class="text-[#6c7086] text-xs">æç¤ºï¼šCSS ç·¨è¼¯å™¨æœƒè‡ªå‹•åµæ¸¬ &lt;style&gt; æ¨™ç±¤ä¸¦æ‹†åˆ†</p>
                    </div>
                `
            }
        };

        function showHelp(topic) {
            const help = helpContents[topic];
            if (!help) return;

            document.getElementById('helpModalTitle').innerHTML =
                '<i class="fas fa-question-circle mr-2"></i>' + help.title;
            document.getElementById('helpModalContent').innerHTML = help.content;
            document.getElementById('helpModal').style.display = 'flex';
        }

        function closeHelpModal() {
            document.getElementById('helpModal').style.display = 'none';
        }

        // --- è£ç½®å°ºå¯¸è¨­å®š ---
        function setDeviceSize(width, height) {
            const frame = document.getElementById('previewFrame');
            const wRange = document.getElementById('widthRange');
            const hRange = document.getElementById('heightRange');
            const wDisplay = document.getElementById('widthDisplay');
            const hDisplay = document.getElementById('heightDisplay');

            if (frame) {
                frame.style.width = width + 'px';
                frame.style.height = height + 'px';
            }
            if (wRange) wRange.value = width;
            if (hRange) hRange.value = height;
            if (wDisplay) wDisplay.textContent = width + 'px';
            if (hDisplay) hDisplay.textContent = height + 'px';
        }
        // --- CSS åˆ†çµ„ç®¡ç†å‡½æ•¸ ---

        // æ¸²æŸ“ CSS åˆ†é 
        function renderCssTabs() {
            const container = document.getElementById('cssTabsContainer');
            if (!container) return;

            let html = '';
            cssGroups.forEach(css => {
                const isActive = css.id === activeCssId;
                const globalBadge = css.isGlobal
                    ? '<span class="global-badge" title="å…¨åŸŸ CSS">ğŸŒ</span>'
                    : '';
                html += `
                    <button class="page-tab ${isActive ? 'active' : ''}" 
                            onclick="switchCss('${css.id}')"
                            ondblclick="showCssTabMenu('${css.id}', event)"
                            title="é»æ“Šåˆ‡æ›ï¼Œé›™æ“Šé–‹å•Ÿé¸å–®">
                        ${globalBadge}
                        <span>${css.name}</span>
                    </button>
                `;
            });
            html += `<button class="page-tab-add" onclick="addNewCss()" title="æ–°å¢ CSS">+ æ–°å¢</button>`;

            container.innerHTML = html;
        }

        // å„²å­˜ç•¶å‰ CSS å…§å®¹
        function saveCurrentCss() {
            if (!cssEditor) return;
            const css = cssGroups.find(c => c.id === activeCssId);
            if (css) {
                css.content = cssEditor.getValue();
            }
        }

        // åˆ‡æ› CSS
        function switchCss(cssId) {
            if (cssId === activeCssId) return;

            // å„²å­˜ç•¶å‰ CSS
            saveCurrentCss();

            // åˆ‡æ›åˆ°æ–° CSS
            activeCssId = cssId;
            const css = cssGroups.find(c => c.id === cssId);
            if (css && cssEditor) {
                cssEditor.setValue(css.content);
            }

            // æ›´æ–°åˆ†é  UI
            renderCssTabs();

            // è§¸ç™¼é è¦½æ›´æ–°
            if (typeof render === 'function') {
                render();
            }
        }

        // æ–°å¢ CSS
        function addNewCss() {
            cssCounter++;
            const newId = 'css-' + cssCounter;
            const newName = 'CSS ' + cssCounter;

            // å„²å­˜ç•¶å‰ CSS
            saveCurrentCss();

            // æ–°å¢ CSSï¼ˆé è¨­ç‚ºç¨ç«‹ CSSï¼‰
            cssGroups.push({
                id: newId,
                name: newName,
                content: '/* ' + newName + ' */\n\n',
                isGlobal: false
            });

            // åˆ‡æ›åˆ°æ–° CSS
            activeCssId = newId;
            if (cssEditor) {
                cssEditor.setValue('/* ' + newName + ' */\n\n');
            }

            renderCssTabs();
        }

        // é‡å‘½å CSS
        function renameCss(cssId) {
            const css = cssGroups.find(c => c.id === cssId);
            if (!css) return;

            const newName = prompt('è¼¸å…¥æ–°åç¨±ï¼š', css.name);
            if (newName && newName.trim()) {
                css.name = newName.trim();
                renderCssTabs();
            }
        }

        // åˆªé™¤ CSS
        function deleteCss(cssId) {
            if (cssGroups.length <= 1) {
                alert('è‡³å°‘éœ€è¦ä¿ç•™ä¸€å€‹ CSSï¼');
                return;
            }

            const css = cssGroups.find(c => c.id === cssId);
            if (!css) return;

            if (!confirm(`ç¢ºå®šè¦åˆªé™¤ã€Œ${css.name}ã€å—ï¼Ÿ`)) return;

            // åˆªé™¤ CSS
            const index = cssGroups.findIndex(c => c.id === cssId);
            cssGroups.splice(index, 1);

            // å¦‚æœåˆªé™¤çš„æ˜¯ç•¶å‰ CSSï¼Œåˆ‡æ›åˆ°ç¬¬ä¸€å€‹
            if (activeCssId === cssId) {
                activeCssId = cssGroups[0].id;
                if (cssEditor) {
                    cssEditor.setValue(cssGroups[0].content);
                }
            }

            renderCssTabs();
            if (typeof render === 'function') {
                render();
            }
        }

        // åˆ‡æ›å…¨åŸŸç‹€æ…‹
        function toggleCssGlobal(cssId) {
            const css = cssGroups.find(c => c.id === cssId);
            if (!css) return;

            css.isGlobal = !css.isGlobal;
            renderCssTabs();

            // è§¸ç™¼é è¦½æ›´æ–°
            if (typeof render === 'function') {
                render();
            }
        }

        // --- å¤šé é¢ç®¡ç†å‡½æ•¸ ---

        // æ¸²æŸ“é é¢åˆ†é 
        function renderPageTabs() {
            const container = document.getElementById('pageTabsContainer');
            if (!container) return;

            let html = '';
            htmlPages.forEach(page => {
                const isActive = page.id === activePageId;
                // é¡¯ç¤ºé€£æ¥çš„ CSSï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
                const linkedCss = page.linkedCss ? cssGroups.find(c => c.id === page.linkedCss) : null;
                const linkedBadge = linkedCss
                    ? `<span class="linked-badge" title="é€£æ¥ï¼š${linkedCss.name}">ğŸ”—</span>`
                    : '';
                html += `
                    <button class="page-tab ${isActive ? 'active' : ''}" 
                            onclick="switchPage('${page.id}')"
                            ondblclick="showHtmlTabMenu('${page.id}', event)"
                            title="é»æ“Šåˆ‡æ›ï¼Œé›™æ“Šé–‹å•Ÿé¸å–®">
                        ${linkedBadge}
                        <span>${page.name}</span>
                    </button>
                `;
            });
            html += `<button class="page-tab-add" onclick="addNewPage()" title="æ–°å¢é é¢">+ æ–°å¢</button>`;

            container.innerHTML = html;
        }

        // å„²å­˜ç•¶å‰é é¢å…§å®¹
        function saveCurrentPage() {
            if (!htmlEditor) return;
            const page = htmlPages.find(p => p.id === activePageId);
            if (page) {
                page.content = htmlEditor.getValue();
            }
        }

        // åˆ‡æ›é é¢
        function switchPage(pageId) {
            if (pageId === activePageId) return;

            // å„²å­˜ç•¶å‰é é¢
            saveCurrentPage();

            // åˆ‡æ›åˆ°æ–°é é¢
            activePageId = pageId;
            const page = htmlPages.find(p => p.id === pageId);
            if (page && htmlEditor) {
                htmlEditor.setValue(page.content);
            }

            // æ›´æ–°åˆ†é  UI
            renderPageTabs();

            // è§¸ç™¼é è¦½æ›´æ–°
            if (typeof render === 'function') {
                render();
            }
        }

        // æ–°å¢é é¢
        function addNewPage() {
            pageCounter++;
            const newId = 'page-' + pageCounter;
            const newName = 'é é¢ ' + pageCounter;

            // å„²å­˜ç•¶å‰é é¢
            saveCurrentPage();

            // æ–°å¢é é¢
            htmlPages.push({
                id: newId,
                name: newName,
                content: `<!-- ${newName} -->\n<div class="container">\n    <h1>${newName}</h1>\n    <p>åœ¨æ­¤ç·¨è¼¯æ‚¨çš„å…§å®¹...</p>\n</div>`
            });

            // åˆ‡æ›åˆ°æ–°é é¢
            activePageId = newId;
            if (htmlEditor) {
                htmlEditor.setValue(htmlPages[htmlPages.length - 1].content);
            }

            // æ›´æ–° UI
            renderPageTabs();

            // è§¸ç™¼é è¦½
            if (typeof render === 'function') {
                render();
            }
        }

        // é‡å‘½åé é¢
        function renamePage(pageId) {
            const page = htmlPages.find(p => p.id === pageId);
            if (!page) return;

            const newName = prompt('è¼¸å…¥æ–°çš„é é¢åç¨±ï¼š', page.name);
            if (newName && newName.trim()) {
                page.name = newName.trim();
                renderPageTabs();
            }
        }

        // åˆªé™¤é é¢
        function deletePage(pageId) {
            if (htmlPages.length <= 1) {
                alert('è‡³å°‘ä¿ç•™ä¸€å€‹é é¢ï¼');
                return;
            }

            const page = htmlPages.find(p => p.id === pageId);
            if (!page) return;

            if (!confirm(`ç¢ºå®šè¦åˆªé™¤ã€Œ${page.name}ã€å—ï¼Ÿ`)) return;

            const index = htmlPages.findIndex(p => p.id === pageId);
            htmlPages.splice(index, 1);

            // å¦‚æœåˆªé™¤çš„æ˜¯ç•¶å‰é é¢ï¼Œåˆ‡æ›åˆ°ç¬¬ä¸€å€‹
            if (pageId === activePageId) {
                activePageId = htmlPages[0].id;
                if (htmlEditor) {
                    htmlEditor.setValue(htmlPages[0].content);
                }
            }

            // æ›´æ–° UI
            renderPageTabs();

            // è§¸ç™¼é è¦½
            if (typeof render === 'function') {
                render();
            }
        }


        // --- é è¦½æ¨¡å¼ ---
        let previewMode = 'simple'; // 'simple' = ç›´æ¥é è¦½, 'regex' = Regex æ¨¡å¼

        function setPreviewMode(mode) {
            previewMode = mode;
            const simpleBtn = document.getElementById('modeSimple');
            const regexBtn = document.getElementById('modeRegex');

            if (mode === 'simple') {
                simpleBtn.className = 'px-2 py-0.5 rounded bg-[#89b4fa] text-[#11111b] font-bold';
                regexBtn.className = 'px-2 py-0.5 rounded text-[#6c7086] hover:text-white';
            } else {
                simpleBtn.className = 'px-2 py-0.5 rounded text-[#6c7086] hover:text-white';
                regexBtn.className = 'px-2 py-0.5 rounded bg-[#f9e2af] text-[#11111b] font-bold';
            }
            render();
        }

        // --- é¸å–æ¨¡å¼ï¼ˆæ°¸ä¹…é–‹å•Ÿï¼Œä½¿ç”¨ Ctrl+é»æ“Šï¼‰ ---
        let selectMode = true;

        function toggleSelectMode() {
            selectMode = !selectMode;
            const btn = document.getElementById('selectModeBtn');

            if (selectMode) {
                btn.className = 'px-2 py-0.5 rounded bg-[#a6e3a1] text-[#11111b] font-bold transition flex items-center gap-1';
                btn.innerHTML = '<i class="fas fa-mouse-pointer"></i> é¸å–ä¸­';
            } else {
                btn.className = 'px-2 py-0.5 rounded text-[#6c7086] hover:text-white transition flex items-center gap-1';
                btn.innerHTML = '<i class="fas fa-mouse-pointer"></i> é¸å–';
            }
            render(); // é‡æ–°æ¸²æŸ“ä»¥æ³¨å…¥/ç§»é™¤äº’å‹•è…³æœ¬
        }

        // ç›£è½ä¾†è‡ª iframe çš„è¨Šæ¯
        window.addEventListener('message', function (event) {
            if (!event.data || !event.data.type) return;

            // å…ƒç´ è¢«é¸å–
            if (event.data.type === 'ELEMENT_SELECTED') {
                const { selector, tagName, classList, pseudoElement, hasInlineStyle, inlineStylePreview, boxModel } = event.data;
                console.log('é¸ä¸­å…ƒç´ :', selector, 'å½å…ƒç´ :', pseudoElement, 'Inline:', hasInlineStyle);

                // æ›´æ–° lastSelectedSelector ä¾›éŸ¿æ‡‰å¼è¼”åŠ©ä½¿ç”¨
                lastSelectedSelector = selector;
                updateResponsiveHint();

                // åœ¨ CSS ç·¨è¼¯å™¨ä¸­å®šä½å°æ‡‰è¦å‰‡
                locateCSSRule(selector, pseudoElement, tagName, hasInlineStyle, inlineStylePreview);

                // é¡¯ç¤º Box Model è³‡è¨Šé¢æ¿
                if (boxModel) {
                    showBoxModelPanel(selector, pseudoElement, boxModel);
                }

                // ğŸ”— é¸å–é€£å‹•ï¼šå±•é–‹å°æ‡‰çš„è®Šæ•¸åˆ†çµ„
                if (customVars.length > 0) {
                    expandVarGroup(selector);
                }
            }

            // æ¨£å¼å³æ™‚æ›´æ–°ï¼ˆæ‹–æ›³ä¸­ï¼‰
            if (event.data.type === 'STYLE_UPDATE') {
                const { selector, updates } = event.data;
                // å³æ™‚æ›´æ–° Box Model é¢æ¿ä¸­çš„æ•¸å€¼
                if (updates.width) {
                    document.getElementById('bm-size').textContent = updates.width.replace('px', '') + ' Ã— ' + (updates.height || document.getElementById('bm-size').textContent.split(' Ã— ')[1]);
                }
                if (updates.height) {
                    const currentWidth = document.getElementById('bm-size').textContent.split(' Ã— ')[0];
                    document.getElementById('bm-size').textContent = currentWidth + ' Ã— ' + updates.height.replace('px', '');
                }
                if (updates.marginTop) document.getElementById('bm-margin-top').textContent = updates.marginTop;
                if (updates.marginBottom) document.getElementById('bm-margin-bottom').textContent = updates.marginBottom;
                if (updates.marginLeft) document.getElementById('bm-margin-left').textContent = updates.marginLeft;
                if (updates.marginRight) document.getElementById('bm-margin-right').textContent = updates.marginRight;
            }

            // æ¨£å¼è®Šæ›´æäº¤ï¼ˆæ‹–æ›³çµæŸï¼‰
            if (event.data.type === 'STYLE_COMMIT') {
                const { selector, boxModel } = event.data;
                console.log('æ¨£å¼è®Šæ›´å·²æäº¤:', selector, boxModel);

                // æ›´æ–° Box Model é¢æ¿çš„å®Œæ•´æ•¸å€¼
                if (boxModel) {
                    document.getElementById('bm-size').textContent = boxModel.width + ' Ã— ' + boxModel.height;
                    document.getElementById('bm-margin-top').textContent = boxModel.marginTop;
                    document.getElementById('bm-margin-right').textContent = boxModel.marginRight;
                    document.getElementById('bm-margin-bottom').textContent = boxModel.marginBottom;
                    document.getElementById('bm-margin-left').textContent = boxModel.marginLeft;
                }

                // åŒæ­¥åˆ° CSS ç·¨è¼¯å™¨
                syncStyleToCSS(selector, boxModel);
            }

            // Alt+é»æ“Šï¼šå®šä½ HTML å…ƒç´ 
            if (event.data.type === 'HTML_LOCATE') {
                const { selector, tagName, classList, id, outerHtml } = event.data;
                console.log('Alt+é»æ“Šï¼šå®šä½ HTML å…ƒç´ ', selector, tagName);
                locateHTMLElement(selector, tagName, classList, id, outerHtml);
            }
        });

        // åœ¨ HTML ç·¨è¼¯å™¨ä¸­å®šä½å…ƒç´ 
        // æœå°‹é‚è¼¯ï¼šæ ¹æ“šé è¦½æ¨¡å¼ï¼ˆsimple/regexï¼‰æ±ºå®šæœå°‹ç¯„åœ
        function locateHTMLElement(selector, tagName, classList, id, outerHtml) {
            // å»ºç«‹å¤šç¨®æœå°‹æ¨¡å¼
            let searchPatterns = [];

            // 1. å„ªå…ˆç”¨ ID æœå°‹
            if (id) {
                searchPatterns.push(`id="${id}"`);
                searchPatterns.push(`id='${id}'`);
            }

            // 2. ç”¨ class æœå°‹
            if (classList && classList.length > 0) {
                classList.forEach(cls => {
                    searchPatterns.push(`class="${cls}`);
                    searchPatterns.push(`class='${cls}`);
                    searchPatterns.push(`"${cls}"`);
                });
                if (classList.length > 1) {
                    searchPatterns.push(`class="${classList.join(' ')}"`);
                }
            }

            // 3. ç”¨æ¨™ç±¤+class æœå°‹
            if (classList && classList.length > 0) {
                searchPatterns.push(`<${tagName} class="${classList[0]}`);
                searchPatterns.push(`<${tagName} class='${classList[0]}`);
            }

            // 4. åªç”¨æ¨™ç±¤ï¼ˆæœ€å¾Œæ‰‹æ®µï¼‰
            searchPatterns.push(`<${tagName}`);

            // è¼”åŠ©å‡½æ•¸ï¼šåœ¨æŒ‡å®šç·¨è¼¯å™¨ä¸­æœå°‹
            function searchInEditor(editor, editorName, patterns) {
                if (!editor) return null;
                const content = editor.getValue();

                for (const pattern of patterns) {
                    const index = content.indexOf(pattern);
                    if (index !== -1) {
                        const textBefore = content.substring(0, index);
                        const lines = textBefore.split('\n');
                        return {
                            editor, editorName,
                            lineNumber: lines.length,
                            column: lines[lines.length - 1].length + 1,
                            patternLength: pattern.length,
                            pattern
                        };
                    }
                }
                return null;
            }

            // é¡¯ç¤ºæœå°‹çµæœçš„è¼”åŠ©å‡½æ•¸
            function showResult(result) {
                result.editor.setSelection({
                    startLineNumber: result.lineNumber,
                    startColumn: result.column,
                    endLineNumber: result.lineNumber,
                    endColumn: result.column + result.patternLength
                });
                result.editor.revealLineInCenter(result.lineNumber);
                if (result.editorName !== activeEditorTab) {
                    switchTab(result.editorName);
                }
                result.editor.focus();
                console.log(`ğŸ” HTML å®šä½æˆåŠŸï¼ˆ${result.editorName}ï¼‰ï¼šç¬¬ ${result.lineNumber} è¡Œï¼Œæ¨¡å¼: "${result.pattern}"`);
            }

            let result = null;

            // ===== æ ¹æ“šé è¦½æ¨¡å¼æ±ºå®šæœå°‹ç¯„åœ =====
            if (previewMode === 'regex') {
                // Regex æ¨¡å¼ï¼šå…ˆæœå°‹ç•¶å‰ OUT ç·¨è¼¯å™¨
                result = searchInEditor(regexOutputEditor, 'regex', searchPatterns);
                if (result) {
                    showResult(result);
                    return;
                }

                // æœå°‹æ‰€æœ‰å…¶ä»– editdisplay è¦å‰‡
                saveCurrentRule();
                const displayRules = regexRules.filter(r => r.type === 'editdisplay');
                for (const rule of displayRules) {
                    if (rule.id === activeRuleId) continue;
                    const content = rule.output || '';
                    
                    for (const pattern of searchPatterns) {
                        const index = content.indexOf(pattern);
                        if (index !== -1) {
                            // æ‰¾åˆ°äº†ï¼åˆ‡æ›åˆ°è©²è¦å‰‡
                            switchTab('regex');
                            switchRule(rule.id);
                            setTimeout(() => {
                                if (regexOutputEditor) {
                                    const newContent = regexOutputEditor.getValue();
                                    const newIndex = newContent.indexOf(pattern);
                                    if (newIndex !== -1) {
                                        const textBefore = newContent.substring(0, newIndex);
                                        const lines = textBefore.split('\n');
                                        regexOutputEditor.setSelection({
                                            startLineNumber: lines.length,
                                            startColumn: lines[lines.length - 1].length + 1,
                                            endLineNumber: lines.length,
                                            endColumn: lines[lines.length - 1].length + 1 + pattern.length
                                        });
                                        regexOutputEditor.revealLineInCenter(lines.length);
                                        regexOutputEditor.focus();
                                    }
                                }
                            }, 50);
                            console.log(`ğŸ” åœ¨ Regex è¦å‰‡ã€Œ${rule.name}ã€ä¸­æ‰¾åˆ° HTML å…ƒç´ ï¼Œå·²è‡ªå‹•åˆ‡æ›`);
                            return;
                        }
                    }
                }
                
                console.log('ğŸ” Regex æ¨¡å¼ï¼šåœ¨æ‰€æœ‰è¦å‰‡ä¸­éƒ½æ‰¾ä¸åˆ°å°æ‡‰çš„å…ƒç´ ');
                return;
            }

            // ===== ç°¡æ˜“æ¨¡å¼ï¼šå…ˆæœç•¶å‰ Tabï¼Œå†æœå…¶ä»– Tab =====
            if (activeEditorTab === 'regex') {
                // ç•¶å‰åœ¨ Regex Tab ä½†æ˜¯ç°¡æ˜“æ¨¡å¼ï¼šå„ªå…ˆæœ HTMLï¼Œå†æœ CSS
                result = searchInEditor(htmlEditor, 'html', searchPatterns);
                if (!result) {
                    result = searchInEditor(cssEditor, 'css', searchPatterns);
                }
            } else {
                // ç•¶å‰åœ¨ CSS/HTML/Story Tabï¼šå…ˆæœç•¶å‰ Tab
                result = searchInEditor(getCurrentEditor(), activeEditorTab, searchPatterns);

                // å¦‚æœæ²’æ‰¾åˆ°ï¼Œæœ HTML Tabï¼ˆå¦‚æœä¸æ˜¯ç•¶å‰ Tabï¼‰
                if (!result && activeEditorTab !== 'html') {
                    result = searchInEditor(htmlEditor, 'html', searchPatterns);
                }
                // å¦‚æœé‚„æ²’æ‰¾åˆ°ï¼Œæœ CSS Tabï¼ˆå¦‚æœä¸æ˜¯ç•¶å‰ Tabï¼‰
                if (!result && activeEditorTab !== 'css') {
                    result = searchInEditor(cssEditor, 'css', searchPatterns);
                }
            }

            if (result) {
                showResult(result);
                return;
            }

            // å‚™ç”¨æ–¹æ¡ˆï¼šç”¨ outerHtml çš„é–‹å§‹éƒ¨åˆ†æœå°‹
            if (outerHtml && htmlEditor) {
                const shortHtml = outerHtml.substring(0, 50);
                const html = htmlEditor.getValue();
                const index = html.indexOf(shortHtml);
                if (index !== -1) {
                    const textBefore = html.substring(0, index);
                    const lines = textBefore.split('\n');
                    htmlEditor.revealLineInCenter(lines.length);
                    if (activeEditorTab !== 'html') switchTab('html');
                    htmlEditor.focus();
                    console.log(`ğŸ” HTML å®šä½ï¼ˆå‚™ç”¨æ–¹æ¡ˆï¼‰ï¼šç¬¬ ${lines.length} è¡Œ`);
                    return;
                }
            }

            console.log('ğŸ” ç°¡æ˜“æ¨¡å¼ï¼šåœ¨ HTML/CSS ä¸­æ‰¾ä¸åˆ°å°æ‡‰çš„å…ƒç´ ');
        }

        // ===== CSS æ­·å²è¨˜éŒ„ç³»çµ±ï¼ˆæ”¯æ´æ§åˆ¶æŸ„æ“ä½œçš„ Undo/Redoï¼‰=====
        let cssHistory = [];      // Undo å †ç–Š
        let cssRedoHistory = [];  // Redo å †ç–Š
        const MAX_CSS_HISTORY = 30;
        let isCssUndoing = false;

        // å„²å­˜ CSS å¿«ç…§
        function saveCssSnapshot() {
            if (isCssUndoing || !cssEditor) return;
            const currentCss = cssEditor.getValue();
            // é¿å…å„²å­˜é‡è¤‡çš„ç‹€æ…‹
            if (cssHistory.length > 0 && cssHistory[cssHistory.length - 1] === currentCss) return;
            cssHistory.push(currentCss);
            cssRedoHistory = []; // æ–°æ“ä½œæ™‚æ¸…ç©º redo å †ç–Š
            if (cssHistory.length > MAX_CSS_HISTORY) cssHistory.shift();
            updateUndoRedoButtons();
            console.log('CSS å¿«ç…§å·²å„²å­˜ï¼Œæ­·å²è¨˜éŒ„æ•¸:', cssHistory.length);
        }

        // Undo CSS è®Šæ›´
        function undoCssChange() {
            if (cssHistory.length === 0 || !cssEditor) {
                console.log('ç„¡ CSS æ­·å²è¨˜éŒ„å¯å¾©åŸ');
                return false;
            }
            isCssUndoing = true;
            const currentCss = cssEditor.getValue();
            cssRedoHistory.push(currentCss); // å„²å­˜ç•¶å‰ç‹€æ…‹åˆ° redo
            const previousCss = cssHistory.pop();
            cssEditor.setValue(previousCss);
            updateUndoRedoButtons();
            isCssUndoing = false;
            console.log('CSS å·²å¾©åŸï¼Œå‰©é¤˜æ­·å²:', cssHistory.length);
            return true;
        }

        // Redo CSS è®Šæ›´
        function redoCssChange() {
            if (cssRedoHistory.length === 0 || !cssEditor) {
                console.log('ç„¡ CSS é‡åšè¨˜éŒ„');
                return false;
            }
            isCssUndoing = true;
            const currentCss = cssEditor.getValue();
            cssHistory.push(currentCss); // å„²å­˜ç•¶å‰ç‹€æ…‹åˆ° undo
            const nextCss = cssRedoHistory.pop();
            cssEditor.setValue(nextCss);
            updateUndoRedoButtons();
            isCssUndoing = false;
            console.log('CSS å·²é‡åšï¼Œå‰©é¤˜é‡åšè¨˜éŒ„:', cssRedoHistory.length);
            return true;
        }

        // æ›´æ–° Undo/Redo æŒ‰éˆ•ç‹€æ…‹
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoCssBtn');
            const redoBtn = document.getElementById('redoCssBtn');
            if (undoBtn) {
                undoBtn.disabled = cssHistory.length === 0;
                undoBtn.classList.toggle('opacity-40', cssHistory.length === 0);
            }
            if (redoBtn) {
                redoBtn.disabled = cssRedoHistory.length === 0;
                redoBtn.classList.toggle('opacity-40', cssRedoHistory.length === 0);
            }
        }

        // åŒæ­¥æ¨£å¼åˆ° CSS ç·¨è¼¯å™¨
        // æœå°‹é‚è¼¯ï¼šæ ¹æ“šé è¦½æ¨¡å¼ï¼ˆsimple/regexï¼‰æ±ºå®šè¦æ›´æ–°çš„ç·¨è¼¯å™¨
        function syncStyleToCSS(selector, boxModel) {
            if (!boxModel) return;

            console.log('syncStyleToCSS è¢«èª¿ç”¨:', selector, boxModel);

            // åœ¨ä¿®æ”¹å‰å„²å­˜å¿«ç…§
            saveCssSnapshot();

            // å°æ–¼å¤š classï¼Œå–æœ€å…·é«”çš„ä¸€å€‹
            let targetSelector = selector;
            if (selector.startsWith('.') && selector.indexOf('.', 1) > 0) {
                const classes = selector.split('.').filter(Boolean);
                targetSelector = '.' + classes[classes.length - 1];
            }

            // è¼”åŠ©å‡½æ•¸ï¼šåœ¨æŒ‡å®šç·¨è¼¯å™¨ä¸­æœå°‹è¦å‰‡
            function findRuleInEditor(editor, sel) {
                if (!editor) return null;
                const content = editor.getValue();
                const escaped = sel.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const ruleRegex = new RegExp(escaped + '\\s*\\{([^}]*)\\}', 'g');
                const match = ruleRegex.exec(content);
                if (match) {
                    return { editor, content, match, ruleContent: match[1] };
                }
                return null;
            }

            let found = null;

            // ===== æ ¹æ“šé è¦½æ¨¡å¼æ±ºå®šæœå°‹ç¯„åœ =====
            if (previewMode === 'regex') {
                // Regex æ¨¡å¼ï¼šåªæœå°‹ Regex Tab çš„ OUT ç·¨è¼¯å™¨
                found = findRuleInEditor(regexOutputEditor, targetSelector);
                if (!found) {
                    console.log('Regex æ¨¡å¼ï¼šåœ¨ OUT ç·¨è¼¯å™¨ä¸­æ‰¾ä¸åˆ° CSS è¦å‰‡:', targetSelector);
                    return;
                }
            } else {
                // ç°¡æ˜“æ¨¡å¼ï¼šæ ¹æ“šç•¶å‰ Tab æ±ºå®šæœå°‹é †åº
                if (activeEditorTab === 'regex') {
                    // ç•¶å‰åœ¨ Regex Tab ä½†æ˜¯ç°¡æ˜“æ¨¡å¼ï¼šå„ªå…ˆæœ CSSï¼Œå†æœ HTML
                    found = findRuleInEditor(cssEditor, targetSelector);
                    if (!found) {
                        found = findRuleInEditor(htmlEditor, targetSelector);
                    }
                } else {
                    // ç•¶å‰åœ¨ CSS/HTML/Story Tabï¼šå…ˆæœç•¶å‰ Tab
                    found = findRuleInEditor(getCurrentEditor(), targetSelector);

                    // å¦‚æœæ²’æ‰¾åˆ°ï¼Œæœå…¶ä»– Tab
                    if (!found && activeEditorTab !== 'css') {
                        found = findRuleInEditor(cssEditor, targetSelector);
                    }
                    if (!found && activeEditorTab !== 'html') {
                        found = findRuleInEditor(htmlEditor, targetSelector);
                    }
                }

                if (!found) {
                    console.log('ç°¡æ˜“æ¨¡å¼ï¼šæ‰¾ä¸åˆ° CSS è¦å‰‡:', targetSelector);
                    return;
                }
            }

            // å¾æ‰¾åˆ°çš„çµæœä¸­å–å¾—ç·¨è¼¯å™¨å’Œå…§å®¹
            const targetEditor = found.editor;
            const css = found.content;
            const match = found.match;

            let ruleContent = match[1];
            let modified = false;
            let newProps = []; // è¦æ–°å¢çš„å±¬æ€§

            // ===== è™•ç† margin ç°¡å¯«å½¢å¼ =====
            // æª¢æŸ¥æ˜¯å¦å­˜åœ¨ margin ç°¡å¯«å½¢å¼ï¼ˆå¦‚ margin: 20px auto; æˆ– margin: 0 0 20px 0;ï¼‰
            const marginShorthandRegex = /([\n\r\s])(margin)(\s*:\s*)([^;]+)(;)/;
            const marginShorthandMatch = ruleContent.match(marginShorthandRegex);

            if (marginShorthandMatch) {
                // è§£æ margin ç°¡å¯«å€¼
                const marginValue = marginShorthandMatch[4].trim();
                const parts = marginValue.split(/\s+/);

                // è§£æå››å€‹æ–¹å‘çš„å€¼
                let top, right, bottom, left;
                if (parts.length === 1) {
                    top = right = bottom = left = parts[0];
                } else if (parts.length === 2) {
                    top = bottom = parts[0];
                    right = left = parts[1];
                } else if (parts.length === 3) {
                    top = parts[0];
                    right = left = parts[1];
                    bottom = parts[2];
                } else {
                    top = parts[0];
                    right = parts[1];
                    bottom = parts[2];
                    left = parts[3];
                }

                // ç”¨æ‹–æ›³çš„æ–°å€¼è¦†è“‹å°æ‡‰æ–¹å‘
                const newTop = boxModel.marginTop || top;
                const newRight = boxModel.marginRight || right;
                const newBottom = boxModel.marginBottom || bottom;
                const newLeft = boxModel.marginLeft || left;

                // é‡å»º margin ç°¡å¯«
                const newMarginValue = `${newTop} ${newRight} ${newBottom} ${newLeft}`;

                // åªæœ‰ç•¶å€¼æœ‰è®ŠåŒ–æ™‚æ‰æ›¿æ›
                if (newMarginValue !== marginValue) {
                    const oldDecl = marginShorthandMatch[0];
                    const newDecl = marginShorthandMatch[1] + 'margin' + marginShorthandMatch[3] + newMarginValue + ';';
                    ruleContent = ruleContent.replace(oldDecl, newDecl);
                    modified = true;
                    console.log('å·²æ›´æ–° margin ç°¡å¯«:', marginValue, '->', newMarginValue);
                }
            }

            // ===== è™•ç† width å’Œ height =====
            const sizeProps = {
                'width': boxModel.width + 'px',
                'height': boxModel.height + 'px'
            };

            for (const [prop, value] of Object.entries(sizeProps)) {
                if (!value || value === 'undefinedpx' || value === 'NaNpx') continue;

                // æª¢æŸ¥å±¬æ€§æ˜¯å¦å­˜åœ¨
                const propRegex = new RegExp('([\\n\\r\\s])(' + prop + ')(\\s*:\\s*)([^;]+)(;)', 'g');
                if (propRegex.test(ruleContent)) {
                    propRegex.lastIndex = 0;
                    ruleContent = ruleContent.replace(propRegex, '$1$2$3' + value + '$5');
                    modified = true;
                    console.log('å·²æ›´æ–°å±¬æ€§:', prop, '->', value);
                } else {
                    // å±¬æ€§ä¸å­˜åœ¨ï¼Œæ–°å¢å®ƒ
                    newProps.push(`    ${prop}: ${value};`);
                    console.log('å°‡æ–°å¢å±¬æ€§:', prop, '=', value);
                }
            }

            // ===== è™•ç†å–®ç¨çš„ margin-* å±¬æ€§ï¼ˆåƒ…ç•¶æ²’æœ‰ margin ç°¡å¯«å½¢å¼æ™‚ï¼‰=====
            if (!marginShorthandMatch) {
                const marginProps = {
                    'margin-top': boxModel.marginTop,
                    'margin-right': boxModel.marginRight,
                    'margin-bottom': boxModel.marginBottom,
                    'margin-left': boxModel.marginLeft
                };

                let hasAnyMarginProp = false;
                for (const [prop, value] of Object.entries(marginProps)) {
                    if (!value || value === '0px') continue;

                    const propRegex = new RegExp('([\\n\\r\\s])(' + prop + ')(\\s*:\\s*)([^;]+)(;)', 'g');
                    if (propRegex.test(ruleContent)) {
                        propRegex.lastIndex = 0;
                        ruleContent = ruleContent.replace(propRegex, '$1$2$3' + value + '$5');
                        modified = true;
                        hasAnyMarginProp = true;
                    }
                }

                // å¦‚æœè¦å‰‡ä¸­å®Œå…¨æ²’æœ‰ margin ç›¸é—œå±¬æ€§ï¼Œä¸”æœ‰éé›¶çš„ margin å€¼ï¼Œæ–°å¢ margin ç°¡å¯«
                if (!hasAnyMarginProp) {
                    const mt = boxModel.marginTop || '0px';
                    const mr = boxModel.marginRight || '0px';
                    const mb = boxModel.marginBottom || '0px';
                    const ml = boxModel.marginLeft || '0px';

                    // åªæœ‰ç•¶è‡³å°‘æœ‰ä¸€å€‹éé›¶å€¼æ™‚æ‰æ–°å¢
                    if (mt !== '0px' || mr !== '0px' || mb !== '0px' || ml !== '0px') {
                        newProps.push(`    margin: ${mt} ${mr} ${mb} ${ml};`);
                        console.log('å°‡æ–°å¢ margin ç°¡å¯«:', mt, mr, mb, ml);
                    }
                }
            }

            // å¦‚æœæœ‰è¦æ–°å¢çš„å±¬æ€§ï¼Œè¿½åŠ åˆ°è¦å‰‡æœ«å°¾
            if (newProps.length > 0) {
                // åœ¨è¦å‰‡å…§å®¹æœ«å°¾æ–°å¢å±¬æ€§
                ruleContent = ruleContent.trimEnd() + '\n' + newProps.join('\n') + '\n';
                modified = true;
                console.log('æ–°å¢å±¬æ€§:', newProps);
            }

            // å¦‚æœæœ‰ä¿®æ”¹ï¼Œæ›´æ–°ç·¨è¼¯å™¨
            if (modified) {
                const newCss = css.replace(match[0], targetSelector + ' {' + ruleContent + '}');
                targetEditor.setValue(newCss);
                console.log('CSS å·²æ›´æ–°:', targetSelector);
            } else {
                console.log('CSS ç„¡éœ€æ›´æ–°ï¼ˆç„¡è®ŠåŒ–ï¼‰');
            }
        }

        // æ›´æ–°è®Šæ•¸æ§åˆ¶å°ä¸­çš„è®Šæ•¸
        function updateCustomVar(varName, value) {
            const varIndex = customVars.findIndex(v => v.name === varName);
            if (varIndex !== -1) {
                // è§£ææ•¸å€¼å’Œå–®ä½
                const numMatch = value.match(/^([\d.]+)(.*)?$/);
                if (numMatch) {
                    customVars[varIndex].value = parseFloat(numMatch[1]);
                    customVars[varIndex].unit = numMatch[2] || '';
                    renderVariables();
                    console.log('è®Šæ•¸å·²æ›´æ–°:', varName, '=', value);
                }
            }
        }

        // é¡¯ç¤º Box Model è³‡è¨Šé¢æ¿
        function showBoxModelPanel(selector, pseudoElement, boxModel) {
            const panel = document.getElementById('boxModelPanel');
            if (!panel) return;

            // æ›´æ–°é¸æ“‡å™¨æ–‡å­—
            const displaySelector = pseudoElement ? `${selector}::${pseudoElement}` : selector;
            document.getElementById('boxModelSelector').textContent = displaySelector;

            // æ›´æ–° Box Model æ•¸å€¼
            document.getElementById('bm-size').textContent = `${boxModel.width} Ã— ${boxModel.height}`;

            // Margin
            document.getElementById('bm-margin-top').textContent = boxModel.marginTop;
            document.getElementById('bm-margin-right').textContent = boxModel.marginRight;
            document.getElementById('bm-margin-bottom').textContent = boxModel.marginBottom;
            document.getElementById('bm-margin-left').textContent = boxModel.marginLeft;

            // Padding
            document.getElementById('bm-padding-top').textContent = boxModel.paddingTop;
            document.getElementById('bm-padding-right').textContent = boxModel.paddingRight;
            document.getElementById('bm-padding-bottom').textContent = boxModel.paddingBottom;
            document.getElementById('bm-padding-left').textContent = boxModel.paddingLeft;

            // å…¶ä»–å±¬æ€§
            document.getElementById('bm-position').textContent = boxModel.position;
            document.getElementById('bm-border-radius').textContent = boxModel.borderRadius || '0';

            // é¡¯ç¤ºé¢æ¿
            panel.classList.remove('hidden');
        }

        // éš±è— Box Model è³‡è¨Šé¢æ¿
        function hideBoxModelPanel() {
            const panel = document.getElementById('boxModelPanel');
            if (panel) panel.classList.add('hidden');
        }

        // åœ¨ CSS ç·¨è¼¯å™¨ä¸­å®šä½é¸æ“‡å™¨ï¼ˆæˆ– HTML ç·¨è¼¯å™¨å®šä½ inline styleï¼‰
        // æœå°‹é‚è¼¯ï¼šæ ¹æ“šé è¦½æ¨¡å¼ï¼ˆsimple/regexï¼‰æ±ºå®šæœå°‹ç¯„åœ
        function locateCSSRule(selector, pseudoElement, tagName, hasInlineStyle, inlineStylePreview) {
            // æ§‹å»ºæœå°‹æ¨¡å¼ï¼ˆæ”¯æ´å½å…ƒç´ å’Œå¤š classï¼‰
            let searchPatterns = [];
            if (pseudoElement) {
                searchPatterns.push(selector + '::' + pseudoElement);
                searchPatterns.push(selector + ':' + pseudoElement);
            }
            searchPatterns.push(selector);

            // å°æ–¼å¤š class å…ƒç´ ï¼Œåˆ†åˆ¥æœå°‹æ¯å€‹ class
            if (selector.startsWith('.') && selector.indexOf('.', 1) > 0) {
                const classes = selector.split('.').filter(Boolean);
                for (let i = classes.length - 1; i >= 0; i--) {
                    const singleClass = '.' + classes[i];
                    if (!searchPatterns.includes(singleClass)) {
                        searchPatterns.push(singleClass);
                    }
                }
            }

            // è¼”åŠ©å‡½æ•¸ï¼šåœ¨æŒ‡å®šç·¨è¼¯å™¨ä¸­æœå°‹ CSS è¦å‰‡
            function searchInEditor(editor, editorName, patterns) {
                if (!editor) return null;
                const content = editor.getValue();

                for (const pattern of patterns) {
                    const escaped = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(escaped + '\\s*[{,]', 'g');
                    const match = regex.exec(content);

                    if (match) {
                        const textBefore = content.substring(0, match.index);
                        const lines = textBefore.split('\n');
                        return {
                            editor, editorName,
                            lineNumber: lines.length,
                            column: lines[lines.length - 1].length + 1,
                            patternLength: pattern.length
                        };
                    }
                }
                return null;
            }

            // é¡¯ç¤ºæœå°‹çµæœçš„è¼”åŠ©å‡½æ•¸
            function showResult(result) {
                result.editor.setSelection({
                    startLineNumber: result.lineNumber,
                    startColumn: result.column,
                    endLineNumber: result.lineNumber,
                    endColumn: result.column + result.patternLength
                });
                result.editor.revealLineInCenter(result.lineNumber);
                if (result.editorName !== activeEditorTab) {
                    switchTab(result.editorName);
                }
                result.editor.focus();
                console.log(`ğŸ” CSS å®šä½æˆåŠŸï¼ˆ${result.editorName}ï¼‰ï¼šç¬¬ ${result.lineNumber} è¡Œ`);
            }

            let result = null;

            // ===== æ ¹æ“šé è¦½æ¨¡å¼æ±ºå®šæœå°‹ç¯„åœ =====
            if (previewMode === 'regex') {
                // Regex æ¨¡å¼ï¼šå…ˆæœå°‹ç•¶å‰ OUT ç·¨è¼¯å™¨
                result = searchInEditor(regexOutputEditor, 'regex', searchPatterns);
                if (result) {
                    showResult(result);
                    return;
                }

                // æœå°‹æ‰€æœ‰å…¶ä»– editdisplay è¦å‰‡
                saveCurrentRule();
                const displayRules = regexRules.filter(r => r.type === 'editdisplay');
                for (const rule of displayRules) {
                    if (rule.id === activeRuleId) continue;
                    const content = rule.output || '';
                    
                    for (const pattern of searchPatterns) {
                        const escaped = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        const regex = new RegExp(escaped + '\\s*[{,]', 'g');
                        const match = regex.exec(content);
                        
                        if (match) {
                            // æ‰¾åˆ°äº†ï¼åˆ‡æ›åˆ°è©²è¦å‰‡
                            switchTab('regex');
                            switchRule(rule.id);
                            setTimeout(() => {
                                if (regexOutputEditor) {
                                    const newContent = regexOutputEditor.getValue();
                                    const newMatch = regex.exec(newContent);
                                    if (newMatch) {
                                        const textBefore = newContent.substring(0, newMatch.index);
                                        const lines = textBefore.split('\n');
                                        regexOutputEditor.setSelection({
                                            startLineNumber: lines.length,
                                            startColumn: lines[lines.length - 1].length + 1,
                                            endLineNumber: lines.length,
                                            endColumn: lines[lines.length - 1].length + 1 + pattern.length
                                        });
                                        regexOutputEditor.revealLineInCenter(lines.length);
                                        regexOutputEditor.focus();
                                    }
                                }
                            }, 50);
                            console.log(`ğŸ” åœ¨ Regex è¦å‰‡ã€Œ${rule.name}ã€ä¸­æ‰¾åˆ° CSS æ¨£å¼ï¼Œå·²è‡ªå‹•åˆ‡æ›`);
                            return;
                        }
                    }
                }
                
                console.log('ğŸ” Regex æ¨¡å¼ï¼šåœ¨æ‰€æœ‰è¦å‰‡ä¸­éƒ½æ‰¾ä¸åˆ°å°æ‡‰çš„æ¨£å¼');
                return;
            }

            // ===== ç°¡æ˜“æ¨¡å¼ï¼šæ ¹æ“šç•¶å‰ Tab æ±ºå®šæœå°‹é †åº =====
            if (activeEditorTab === 'regex') {
                // ç•¶å‰åœ¨ Regex Tab ä½†æ˜¯ç°¡æ˜“æ¨¡å¼ï¼šå„ªå…ˆæœ CSSï¼Œå†æœ HTML
                result = searchInEditor(cssEditor, 'css', searchPatterns);
                if (!result) {
                    result = searchInEditor(htmlEditor, 'html', searchPatterns);
                }
            } else {
                // ç•¶å‰åœ¨ CSS/HTML/Story Tabï¼šå…ˆæœç•¶å‰ Tab
                result = searchInEditor(getCurrentEditor(), activeEditorTab, searchPatterns);

                // å¦‚æœæ²’æ‰¾åˆ°ï¼Œæœå…¶ä»– Tab
                if (!result && activeEditorTab !== 'css') {
                    result = searchInEditor(cssEditor, 'css', searchPatterns);
                }
                if (!result && activeEditorTab !== 'html') {
                    result = searchInEditor(htmlEditor, 'html', searchPatterns);
                }
            }

            if (result) {
                showResult(result);
                return;
            }

            // ç°¡æ˜“æ¨¡å¼ä¸‹ï¼Œå¦‚æœå…ƒç´ æœ‰ inline styleï¼Œå˜—è©¦å®šä½
            if (hasInlineStyle && inlineStylePreview && htmlEditor) {
                const html = htmlEditor.getValue();
                const searchStr = '<' + tagName.toLowerCase();
                let searchIndex = 0;

                while ((searchIndex = html.indexOf(searchStr, searchIndex)) !== -1) {
                    const tagEnd = html.indexOf('>', searchIndex);
                    if (tagEnd === -1) break;

                    const tagContent = html.substring(searchIndex, tagEnd + 1);
                    if (tagContent.includes('style="') || tagContent.includes("style='")) {
                        const textBefore = html.substring(0, searchIndex);
                        const lines = textBefore.split('\n');

                        htmlEditor.setSelection({
                            startLineNumber: lines.length,
                            startColumn: lines[lines.length - 1].length + 1,
                            endLineNumber: lines.length,
                            endColumn: lines[lines.length - 1].length + 1 + tagContent.length
                        });
                        htmlEditor.revealLineInCenter(lines.length);
                        if (activeEditorTab !== 'html') switchTab('html');
                        htmlEditor.focus();
                        console.log('ğŸ” Inline style å…ƒç´ ï¼šå·²å®šä½');
                        return;
                    }
                    searchIndex = tagEnd;
                }
            }

            console.log('ğŸ” ç°¡æ˜“æ¨¡å¼ï¼šåœ¨ CSS/HTML ä¸­æ‰¾ä¸åˆ°å°æ‡‰çš„æ¨£å¼');
        }
        // é è¨­ CSS å…§å®¹ - åŠŸèƒ½å±•ç¤ºç¯„ä¾‹
        const defaultCss = `/* =========================================
   ğŸ§ª Regex UI Lab - åŠŸèƒ½å±•ç¤ºç¯„ä¾‹
   ========================================= */

/* ===== è§’è‰²å¡ç‰‡å®¹å™¨ ===== */
.character-card {
    max-width: 380px;
    margin: 20px auto;
    background: linear-gradient(145deg, #1a1b26 0%, #24283b 100%);
    border-radius: 20px;
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
    overflow: hidden;
    font-family: 'Segoe UI', sans-serif;
    border: 1px solid #414868;
}

/* ===== é ­åƒå€åŸŸ ===== */
.avatar-section {
    position: relative;
    height: 200px;
    background: linear-gradient(135deg, #7aa2f7 0%, #bb9af7 50%, #f7768e 100%);
    display: flex;
    align-items: center;
    justify-content: center;
}

.avatar-frame {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    border: 4px solid rgba(255, 255, 255, 0.9);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
    background: #1a1b26;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 48px;
}

.status-badge {
    position: absolute;
    bottom: 16px;
    right: 16px;
    background: rgba(158, 206, 106, 0.9);
    color: #1a1b26;
    padding: 6px 14px;
    border-radius: 20px;
    font-size: 0.75rem;
    font-weight: 700;
    backdrop-filter: blur(4px);
}

/* ===== è³‡è¨Šå€åŸŸ ===== */
.info-section {
    padding: 24px;
}

.char-name {
    color: #c0caf5;
    font-size: 1.6rem;
    font-weight: 700;
    margin: 0 0 8px 0;
    text-shadow: 0 2px 8px rgba(122, 162, 247, 0.3);
}

.char-title {
    color: #7aa2f7;
    font-size: 0.9rem;
    margin: 0 0 16px 0;
    opacity: 0.9;
}

.char-desc {
    color: #a9b1d6;
    font-size: 0.875rem;
    line-height: 1.7;
    margin: 0 0 20px 0;
}

/* ===== å±¬æ€§æ¢ ===== */
.stats-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-bottom: 20px;
}

.stat-item {
    background: rgba(65, 72, 104, 0.4);
    padding: 12px;
    border-radius: 12px;
    border: 1px solid rgba(122, 162, 247, 0.2);
}

.stat-label {
    color: #565f89;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin: 0 0 6px 0;
}

.stat-value {
    color: #7aa2f7;
    font-size: 1.2rem;
    font-weight: 700;
    margin: 0;
}

.stat-bar {
    height: 6px;
    background: rgba(65, 72, 104, 0.6);
    border-radius: 3px;
    margin-top: 8px;
    overflow: hidden;
}

.stat-fill {
    height: 100%;
    border-radius: 3px;
    transition: width 0.5s ease;
}

.stat-fill.hp { 
    background: linear-gradient(90deg, #f7768e, #ff9e64); 
    width: 75%;
}

.stat-fill.mp { 
    background: linear-gradient(90deg, #7aa2f7, #bb9af7); 
    width: 60%;
}

/* ===== å‹•ä½œæŒ‰éˆ• ===== */
.action-buttons {
    display: flex;
    gap: 12px;
}

.btn-action {
    flex: 1;
    padding: 14px 20px;
    border: none;
    border-radius: 12px;
    font-size: 0.875rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.btn-primary {
    background: linear-gradient(135deg, #7aa2f7, #bb9af7);
    color: #1a1b26;
    box-shadow: 0 4px 20px rgba(122, 162, 247, 0.4);
}

.btn-primary:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 30px rgba(122, 162, 247, 0.6);
}

.btn-secondary {
    background: transparent;
    color: #7aa2f7;
    border: 2px solid #7aa2f7;
}

.btn-secondary:hover {
    background: rgba(122, 162, 247, 0.15);
}

/* ===== æ¢ä»¶é¡¯ç¤ºå€å¡Š ===== */
.conditional-block {
    margin-top: 16px;
    padding: 16px;
    background: rgba(247, 118, 142, 0.1);
    border-left: 3px solid #f7768e;
    border-radius: 0 12px 12px 0;
}

.conditional-text {
    color: #f7768e;
    font-size: 0.8rem;
    margin: 0;
}

/* ===== é å°¾ ===== */
.card-footer {
    padding: 16px 24px;
    background: rgba(65, 72, 104, 0.3);
    border-top: 1px solid #414868;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.footer-info {
    color: #565f89;
    font-size: 0.75rem;
    margin: 0;
}

.footer-icon {
    color: #bb9af7;
    font-size: 1.2rem;
}

/* ===== éŸ¿æ‡‰å¼è¨­è¨ˆç¤ºç¯„ ===== */
@media (max-width: 768px) {
    .character-card {
        margin: 10px;
        border-radius: 16px;
    }
    
    .stats-grid {
        grid-template-columns: 1fr;
    }
    
    .action-buttons {
        flex-direction: column;
    }
}`;

        // é è¨­ HTML å…§å®¹ - åŠŸèƒ½å±•ç¤ºç¯„ä¾‹ï¼ˆåŒ…å« RISU è®Šæ•¸èªæ³•ï¼‰
        const defaultHtml = `<div class="character-card">
    <!-- é ­åƒå€åŸŸ -->
    <div class="avatar-section">
        <div class="avatar-frame">
            <!-- ğŸ’¡ RISU èªæ³•ï¼š{{image::è³‡ç”¢å}} ç”¨æ–¼é¡¯ç¤ºè§’è‰²åœ–ç‰‡ -->
            ğŸ§™â€â™‚ï¸
        </div>
        <!-- ğŸ’¡ RISU èªæ³•ï¼š{{getvar::è®Šæ•¸å}} ç”¨æ–¼é¡¯ç¤ºè®Šæ•¸å€¼ -->
        <span class="status-badge">Lv. {{getvar::player_level}}</span>
    </div>
    
    <!-- è³‡è¨Šå€åŸŸ -->
    <div class="info-section">
        <!-- ğŸ’¡ è©¦è©¦ã€Œæ™ºæ…§æç…‰ã€åŠŸèƒ½ï¼Œè‡ªå‹•æå– CSS è®Šæ•¸ -->
        <h2 class="char-name">{{getvar::player_name}}</h2>
        <p class="char-title">âœ¨ å†’éšªè€…å…¬æœƒãƒ»æ¢ç´¢è€…</p>
        <p class="char-desc">
            ä¸€ä½ä¾†è‡ªé™é åœ‹åº¦çš„æ—…è¡Œè€…ï¼Œæ“æœ‰æ“æ§å…ƒç´ çš„ç¥ç§˜åŠ›é‡ã€‚
            ç›®å‰æ­£åœ¨å°‹æ‰¾å‚³èªªä¸­çš„å¤ä»£éºè·¡ã€‚
        </p>
        
        <!-- å±¬æ€§å±•ç¤º -->
        <div class="stats-grid">
            <div class="stat-item">
                <p class="stat-label">ç”Ÿå‘½å€¼</p>
                <p class="stat-value">{{getvar::player_hp}} / 100</p>
                <div class="stat-bar">
                    <div class="stat-fill hp"></div>
                </div>
            </div>
            <div class="stat-item">
                <p class="stat-label">é­”åŠ›å€¼</p>
                <p class="stat-value">{{getvar::player_mp}} / 80</p>
                <div class="stat-bar">
                    <div class="stat-fill mp"></div>
                </div>
            </div>
        </div>
        
        <!-- å‹•ä½œæŒ‰éˆ• -->
        <div class="action-buttons">
            <button class="btn-action btn-primary">âš”ï¸ æˆ°é¬¥</button>
            <button class="btn-action btn-secondary">ğŸ“¦ èƒŒåŒ…</button>
        </div>
        
        <!-- ğŸ’¡ RISU èªæ³•ï¼š{{#if æ¢ä»¶}} ç”¨æ–¼æ¢ä»¶é¡¯ç¤º -->
        {{#if {{getvar::has_quest}}}}
        <div class="conditional-block">
            <p class="conditional-text">ğŸ“Œ é€²è¡Œä¸­ä»»å‹™ï¼š{{getvar::quest_name}}</p>
        </div>
        {{/if}}
    </div>
    
    <!-- é å°¾ -->
    <div class="card-footer">
        <p class="footer-info">ğŸ’¡ Ctrl+é»æ“Šé è¦½å€å…ƒç´ å¯å®šä½ CSS</p>
        <span class="footer-icon">â­</span>
    </div>
</div>`;

        // å…¨è¢å¹•åˆ‡æ›
        function toggleFullscreen(editorType) {
            // æ ¹æ“šé¡å‹é¸æ“‡å®¹å™¨å’Œç·¨è¼¯å™¨
            let container, editor;
            switch (editorType) {
                case 'css':
                    container = document.getElementById('cssEditorContainer');
                    editor = cssEditor;
                    break;
                case 'html':
                    container = document.getElementById('htmlEditorContainer');
                    editor = htmlEditor;
                    break;
                case 'regexOutput':
                    container = document.getElementById('regexOutputEditorContainer');
                    editor = regexOutputEditor;
                    break;
                case 'story':
                    container = document.getElementById('storyEditorContainer');
                    editor = storyEditor;
                    break;
                default:
                    return;
            }

            if (!container) return;
            const btn = container.querySelector('.monaco-fullscreen-btn i');

            if (container.classList.contains('fullscreen')) {
                container.classList.remove('fullscreen');
                if (btn) btn.className = 'fas fa-expand';
            } else {
                container.classList.add('fullscreen');
                if (btn) btn.className = 'fas fa-compress';
            }

            // é‡æ–°è¨ˆç®—ç·¨è¼¯å™¨å¤§å°
            setTimeout(() => {
                if (editor) editor.layout();
            }, 100);
        }

        // ESC éµé€€å‡ºå…¨è¢å¹• + Ctrl+Z æ’¤éŠ·è®Šæ•¸æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                document.querySelectorAll('.monaco-container.fullscreen').forEach(container => {
                    container.classList.remove('fullscreen');
                    container.querySelector('.monaco-fullscreen-btn i').className = 'fas fa-expand';
                    if (cssEditor) cssEditor.layout();
                    if (htmlEditor) htmlEditor.layout();
                });
            }

            // Ctrl+Z æ’¤éŠ·æ§åˆ¶æŸ„æ“ä½œï¼ˆå„ªå…ˆï¼‰æˆ–è®Šæ•¸æ§åˆ¶å™¨çš„è®Šæ›´
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                const activeEl = document.activeElement;
                const isInEditor = activeEl && (
                    activeEl.closest('.monaco-editor') ||
                    activeEl.closest('#cssEditorContainer') ||
                    activeEl.closest('#htmlEditorContainer')
                );

                // å¦‚æœç„¦é»ä¸åœ¨ç·¨è¼¯å™¨å…§ï¼Œè™•ç†æ§åˆ¶æŸ„æ“ä½œçš„ Undo
                if (!isInEditor) {
                    // å„ªå…ˆè™•ç† CSS æ­·å²ï¼ˆæ§åˆ¶æŸ„æ“ä½œï¼‰
                    if (cssHistory && cssHistory.length > 0) {
                        e.preventDefault();
                        if (undoCssChange()) {
                            console.log('æ§åˆ¶æŸ„æ“ä½œå·²å¾©åŸ');
                        }
                        return;
                    }
                    // å…¶æ¬¡è™•ç†è®Šæ•¸æ§åˆ¶å°
                    if (variableHistory && variableHistory.length > 0) {
                        e.preventDefault();
                        if (undoVariableChange()) {
                            console.log('è®Šæ•¸ç‹€æ…‹å·²å¾©åŸ');
                        }
                    }
                }
            }

            // Ctrl+Y æˆ– Ctrl+Shift+Z é‡åšæ§åˆ¶æŸ„æ“ä½œ
            if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                const activeEl = document.activeElement;
                const isInEditor = activeEl && (
                    activeEl.closest('.monaco-editor') ||
                    activeEl.closest('#cssEditorContainer') ||
                    activeEl.closest('#htmlEditorContainer')
                );

                if (!isInEditor && cssRedoHistory && cssRedoHistory.length > 0) {
                    e.preventDefault();
                    if (redoCssChange()) {
                        console.log('æ§åˆ¶æŸ„æ“ä½œå·²é‡åš');
                    }
                }
            }
        });


        // --- æ ¸å¿ƒé‚è¼¯ï¼šè®Šæ•¸æ¸²æŸ“ ---
        let customVars = [];
        let deleteTargetIndex = -1;

        // [æ–°å¢] é è¦½å€èƒŒæ™¯è‰²è¨­å®š
        let previewBgColor = '#ffffff'; // é è¨­ç™½è‰²
        const previewBgOptions = [
            { color: '#ffffff', name: 'ç™½', icon: 'â¬œ' },
            { color: '#1e1e2e', name: 'æ·±', icon: 'â¬›' },
            { color: '#f5f5f5', name: 'æ·¡ç°', icon: 'ğŸŸ¤' },
            { color: '#2d2d2d', name: 'ç‚­ç°', icon: 'âš«' },
            { color: 'transparent', name: 'é€æ˜', icon: 'ğŸŸ¥' }
        ];

        function setPreviewBgColor(color) {
            previewBgColor = color;
            render();
        }

        // --- è®Šæ•¸æ­·å²è¨˜éŒ„ï¼ˆæ”¯æ´ Ctrl+Zï¼‰---
        let variableHistory = [];
        const MAX_HISTORY_SIZE = 50;
        let isUndoing = false; // é˜²æ­¢ undo æ™‚è§¸ç™¼æ–°çš„å¿«ç…§

        // å„²å­˜ç•¶å‰è®Šæ•¸ç‹€æ…‹å¿«ç…§
        function saveVariableSnapshot() {
            if (isUndoing) return;
            // æ·±æ‹·è²ç•¶å‰è®Šæ•¸ç‹€æ…‹
            const snapshot = JSON.parse(JSON.stringify(customVars));
            variableHistory.push(snapshot);
            // é™åˆ¶æ­·å²è¨˜éŒ„å¤§å°
            if (variableHistory.length > MAX_HISTORY_SIZE) {
                variableHistory.shift();
            }
        }

        // å¾©åŸä¸Šä¸€æ¬¡è®Šæ•¸ç‹€æ…‹
        function undoVariableChange() {
            if (variableHistory.length === 0) {
                console.log('ç„¡æ­·å²è¨˜éŒ„å¯å¾©åŸ');
                return false;
            }
            isUndoing = true;
            customVars = variableHistory.pop();
            renderVarControls();
            render();
            isUndoing = false;
            return true;
        }

        // è¨­å®šè£ç½®é è¦½å¯¬åº¦
        function setDeviceWidth(width) {
            const range = document.getElementById('widthRange');
            const display = document.getElementById('widthDisplay');
            const frame = document.getElementById('previewFrame');

            if (range) range.value = width;
            if (display) display.textContent = width + 'px';
            if (frame) frame.style.width = width + 'px';
        }

        // è¿½è¹¤å„é¸æ“‡å™¨çš„å±•é–‹ç‹€æ…‹ï¼ˆé è¨­å…¨éƒ¨æ”¶åˆï¼‰
        let expandedSelectors = {};

        // ====== ğŸ§ª RISU è®Šæ•¸æ¨¡æ“¬ç³»çµ± ======
        let risuSimVars = {};  // { varName: { value, type, autoNamed } }  // å…¼å®¹æ¨¡å¼ï¼šç°¡æ˜“æ¨¡å¼å…±ç”¨
        let risuAssetMode = '800x600';  // é è¨­åœ–ç‰‡å°ºå¯¸

        // ====== Tab å°ˆå±¬è®Šæ•¸ç³»çµ± ======
        // [å·²ä¿®æ”¹] è®Šæ•¸å…±ç”¨æ¶æ§‹ï¼šCSS/HTML å…±ç”¨ä¸€çµ„ï¼ŒRegex/Story å…±ç”¨å¦ä¸€çµ„
        let tabVariables = {
            simple: { cssVars: [], risuVars: {} },  // CSS + HTML Tab å…±ç”¨
            regex: { cssVars: [], risuVars: {} }    // Regex + Story Tab å…±ç”¨
        };

        // è¼”åŠ©å‡½æ•¸ï¼šæ ¹æ“š Tab åç¨±å–å¾—å°æ‡‰çš„è®Šæ•¸çµ„ key
        function getVarGroupKey(tabName) {
            if (tabName === 'css' || tabName === 'html') {
                return 'simple';
            } else {
                return 'regex';  // regex æˆ– story
            }
        }
        let activeEditorTab = 'css';  // ç•¶å‰æ´»å‹•çš„ç·¨è¼¯å™¨ Tab

        // æ¸¬è©¦åœ–ç‰‡ URLï¼ˆä½¿ç”¨ placehold.co - å¯é çš„ placeholder æœå‹™ï¼‰
        const risuTestImages = {
            '800x600': 'https://placehold.co/800x600/667eea/ffffff?text=800x600',
            '1280x800': 'https://placehold.co/1280x800/764ba2/ffffff?text=1280x800',
            '1920x1080': 'https://placehold.co/1920x1080/a855f7/ffffff?text=1920x1080',
            '400x400': 'https://placehold.co/400x400/f59e0b/ffffff?text=400x400'
        };

        // è¨­å®šè³‡ç”¢åœ–ç‰‡æ¨¡å¼
        function setRisuAssetMode(mode) {
            risuAssetMode = mode;
            render();
        }

        // è™•ç†è‡ªè¨‚åœ–ç‰‡ä¸Šå‚³
        function handleCustomImageUpload(input) {
            const file = input.files[0];
            if (!file) return;

            // æª¢æŸ¥æª”æ¡ˆé¡å‹
            if (!file.type.startsWith('image/')) {
                alert('è«‹é¸æ“‡åœ–ç‰‡æª”æ¡ˆï¼');
                return;
            }

            // æª¢æŸ¥æª”æ¡ˆå¤§å°ï¼ˆé™åˆ¶ 5MBï¼‰
            if (file.size > 5 * 1024 * 1024) {
                alert('åœ–ç‰‡æª”æ¡ˆéå¤§ï¼è«‹é¸æ“‡ 5MB ä»¥ä¸‹çš„åœ–ç‰‡ã€‚');
                return;
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                const base64Data = e.target.result;
                let fileName = file.name.replace(/\.[^.]+$/, ''); // ç§»é™¤å‰¯æª”å

                // ä½¿ç”¨ Image åµæ¸¬åœ–ç‰‡å°ºå¯¸
                const img = new Image();
                img.onload = function () {
                    const width = img.width;
                    const height = img.height;
                    const customKey = 'custom_' + Date.now();

                    // æˆªçŸ­éé•·çš„æª”åï¼ˆä¿ç•™å‰ 10 å­—å…ƒï¼‰
                    if (fileName.length > 10) {
                        fileName = fileName.substring(0, 10) + '..';
                    }

                    // æ·»åŠ åˆ° risuTestImagesï¼ˆå„²å­˜ç‚ºç‰©ä»¶ä»¥åŒ…å« displayNameï¼‰
                    risuTestImages[customKey] = {
                        url: base64Data,
                        displayName: `ğŸ“· ${fileName} (${width}Ã—${height})`
                    };

                    // åˆ·æ–°è®Šæ•¸åˆ—è¡¨ï¼ˆè®“åœ–ç‰‡è³‡ç”¢çš„ä¸‹æ‹‰é¸å–®åŒ…å«æ–°ä¸Šå‚³çš„åœ–ç‰‡ï¼‰
                    renderRisuVars();
                    updateUploadedImageCount();
                    render();

                    console.log(`ğŸ“· å·²ä¸Šå‚³è‡ªè¨‚åœ–ç‰‡ï¼š${file.name} (${width}Ã—${height})`);
                };

                img.onerror = function () {
                    alert('ç„¡æ³•è®€å–åœ–ç‰‡å°ºå¯¸ï¼Œè«‹ç¢ºèªæª”æ¡ˆæ ¼å¼æ­£ç¢ºï¼');
                };

                img.src = base64Data;
            };

            reader.onerror = function () {
                alert('è®€å–åœ–ç‰‡å¤±æ•—ï¼Œè«‹é‡è©¦ï¼');
            };

            reader.readAsDataURL(file);

            // æ¸…ç©º input ä»¥ä¾¿é‡è¤‡ä¸Šå‚³åŒä¸€æª”æ¡ˆ
            input.value = '';
        }

        // æ ¹æ“šè³‡ç”¢åç¨±ç”Ÿæˆ placeholder åœ–ç‰‡ URL
        // ä½¿ç”¨ risuSimVars ä¸­è©²è³‡ç”¢çš„è¨­å®šï¼ˆå°ºå¯¸æˆ–è‡ªè¨‚åœ–ç‰‡ï¼‰
        function getAssetPlaceholder(assetName, type) {
            // å¾ risuSimVars å–å¾—è©²è³‡ç”¢çš„è¨­å®š
            const assetConfig = risuSimVars[assetName];
            const mode = assetConfig ? assetConfig.value : '800x600';

            // å¦‚æœé¸æ“‡çš„æ˜¯ä¸Šå‚³çš„è‡ªè¨‚åœ–ç‰‡
            if (mode.startsWith('custom_') && risuTestImages[mode]) {
                const customImg = risuTestImages[mode];
                // æ”¯æ´æ–°æ ¼å¼ï¼ˆç‰©ä»¶ï¼‰å’ŒèˆŠæ ¼å¼ï¼ˆå­—ä¸²ï¼‰
                return customImg.url || customImg;
            }

            // é è¨­å°ºå¯¸
            const sizes = {
                '800x600': { w: 800, h: 600 },
                '1280x800': { w: 1280, h: 800 },
                '1920x1080': { w: 1920, h: 1080 },
                '400x400': { w: 400, h: 400 }
            };
            const size = sizes[mode] || sizes['800x600'];

            // æ ¹æ“šè³‡ç”¢åç¨±ç”Ÿæˆå”¯ä¸€é¡è‰²ï¼ˆå“ˆå¸Œç®—æ³•ï¼‰
            let hash = 0;
            for (let i = 0; i < assetName.length; i++) {
                hash = ((hash << 5) - hash) + assetName.charCodeAt(i);
                hash = hash & hash;
            }

            // ç”Ÿæˆæ¼‚äº®çš„é¡è‰²ï¼ˆé¿å…å¤ªæš—æˆ–å¤ªäº®ï¼‰
            const hue = Math.abs(hash) % 360;
            const saturation = 60 + (Math.abs(hash >> 8) % 20);
            const lightness = 45 + (Math.abs(hash >> 16) % 15);

            // è½‰æ› HSL åˆ° HEX
            const hslToHex = (h, s, l) => {
                s /= 100;
                l /= 100;
                const a = s * Math.min(l, 1 - l);
                const f = n => {
                    const k = (n + h / 30) % 12;
                    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                    return Math.round(255 * color).toString(16).padStart(2, '0');
                };
                return f(0) + f(8) + f(4);
            };

            const bgColor = hslToHex(hue, saturation, lightness);
            const textColor = 'ffffff';

            // ç¸®çŸ­è³‡ç”¢åç¨±ç”¨æ–¼é¡¯ç¤º
            let displayName = assetName;
            if (displayName.length > 15) {
                displayName = displayName.substring(0, 12) + '..';
            }
            // URL encode ç‰¹æ®Šå­—ç¬¦
            displayName = encodeURIComponent(displayName);

            // ä½¿ç”¨ placehold.co æœå‹™
            return `https://placehold.co/${size.w}x${size.h}/${bgColor}/${textColor}?text=${displayName}`;
        }

        // æƒæ RISU è®Šæ•¸
        function scanRisuVariables() {
            const html = htmlEditor ? htmlEditor.getValue() : '';
            const css = cssEditor ? cssEditor.getValue() : '';
            const content = html + css;

            if (!content.trim()) {
                alert('è«‹å…ˆåœ¨ç·¨è¼¯å™¨ä¸­è¼¸å…¥å«æœ‰ RISU è®Šæ•¸çš„å…§å®¹ï¼');
                return;
            }

            let stringCounter = Object.keys(risuSimVars).length + 1;
            let newCount = 0;

            // è¨˜éŒ„å·²å¾æ¢ä»¶ä¸­æ•æ‰åˆ°å€¼çš„è®Šæ•¸ï¼ˆç¬¬ä¸€å€‹å€¼å„ªå…ˆï¼‰
            const conditionValues = {};

            // 1. å„ªå…ˆæƒææ¢ä»¶èªå¥ï¼Œæ•æ‰è®Šæ•¸çš„ç¬¬ä¸€å€‹å°æ¯”å€¼
            // æ ¼å¼: {{equal::{{gettempvar::NAME}}::VALUE}} æˆ– {{getvar::NAME}}=VALUE
            const condPatterns = [
                // {{equal::{{gettempvar::NAME}}::VALUE}}
                /\{\{equal::\{\{(?:getvar|gettempvar)::([^}]+)\}\}::([^{}]+)\}\}/gi,
                // {{not_equal::{{gettempvar::NAME}}::VALUE}}
                /\{\{not_equal::\{\{(?:getvar|gettempvar)::([^}]+)\}\}::([^{}]+)\}\}/gi,
                // {{greater::{{gettempvar::NAME}}::VALUE}}
                /\{\{greater(?:_equal)?::\{\{(?:getvar|gettempvar)::([^}]+)\}\}::([^{}]+)\}\}/gi,
                // {{less::{{gettempvar::NAME}}::VALUE}}
                /\{\{less(?:_equal)?::\{\{(?:getvar|gettempvar)::([^}]+)\}\}::([^{}]+)\}\}/gi,
                // {{getvar::NAME}}=VALUE æˆ– {{getvar::NAME}}==VALUE
                /\{\{(?:getvar|gettempvar)::([^}]+)\}\}\s*[=!<>]+\s*(\d+|"[^"]*"|'[^']*'|\w+)/gi
            ];

            for (const pattern of condPatterns) {
                let match;
                while ((match = pattern.exec(content)) !== null) {
                    const name = match[1].trim();
                    let value = match[2].replace(/["']/g, '').trim();

                    // åªè¨˜éŒ„ç¬¬ä¸€å€‹æ•æ‰åˆ°çš„å€¼
                    if (!conditionValues[name]) {
                        conditionValues[name] = value;
                    }
                }
            }

            // 2. æƒææ‰€æœ‰ {{getvar::NAME}} å’Œ {{gettempvar::NAME}}
            const varRegex = /\{\{(?:getvar|gettempvar)::([^{}]+)\}\}/gi;
            let match;
            while ((match = varRegex.exec(content)) !== null) {
                const name = match[1].trim();
                if (!risuSimVars[name]) {
                    // å„ªå…ˆä½¿ç”¨æ¢ä»¶ä¸­æ•æ‰åˆ°çš„å€¼ï¼Œå¦å‰‡ä½¿ç”¨ã€Œå­—ä¸²Nã€
                    if (conditionValues[name] !== undefined) {
                        risuSimVars[name] = {
                            value: conditionValues[name],
                            type: isNaN(conditionValues[name]) ? 'string' : 'number',
                            autoNamed: false
                        };
                    } else {
                        risuSimVars[name] = {
                            value: `å­—ä¸²${stringCounter++}`,
                            type: 'string',
                            autoNamed: true
                        };
                    }
                    newCount++;
                }
            }

            // 3. æƒæåœ–ç‰‡è³‡ç”¢ {{image::}}, {{img::}}, {{raw::}}, {{path::}}, {{bg::}}
            const assetRegex = /\{\{(image|img|raw|path|bg)::([^{}]+)\}\}/gi;
            while ((match = assetRegex.exec(content)) !== null) {
                const assetName = match[2].trim();
                if (!risuSimVars[assetName]) {
                    risuSimVars[assetName] = {
                        value: '800x600',  // é è¨­å°ºå¯¸
                        type: 'asset',     // æ¨™è¨˜ç‚ºåœ–ç‰‡è³‡ç”¢
                        assetType: match[1].toLowerCase(),
                        autoNamed: false
                    };
                    newCount++;
                }
            }

            renderRisuVars();
            render();

            // æ›´æ–°ä¸Šå‚³åœ–ç‰‡è¨ˆæ•¸
            updateUploadedImageCount();

            if (newCount > 0) {
                console.log(`ğŸ“¡ æƒæå®Œæˆï¼ç™¼ç¾ ${newCount} å€‹æ–°è®Šæ•¸`);
            } else {
                console.log('ğŸ“¡ æƒæå®Œæˆï¼æ²’æœ‰ç™¼ç¾æ–°è®Šæ•¸');
            }
        }

        // åŒæ­¥ Tab è®Šæ•¸åˆ°å…±ç”¨è®Šæ•¸ï¼ˆä¾›é¢æ¿é¡¯ç¤ºï¼‰
        // [å·²ä¿®æ”¹] åˆ‡æ› Tab æ™‚é¡¯ç¤ºå°æ‡‰è®Šæ•¸çµ„çš„è®Šæ•¸ï¼ˆCSS/HTML å…±ç”¨ï¼ŒRegex/Story å…±ç”¨ï¼‰
        function syncTabVariables() {
            // å–å¾—ç•¶å‰ Tab å°æ‡‰çš„è®Šæ•¸çµ„ key
            const groupKey = getVarGroupKey(activeEditorTab);

            // æ ¹æ“šè®Šæ•¸çµ„é¡¯ç¤ºå°æ‡‰çš„ RISU è®Šæ•¸
            risuSimVars = { ...tabVariables[groupKey].risuVars };
            renderRisuVars();

            // æ ¹æ“šè®Šæ•¸çµ„é¡¯ç¤ºå°æ‡‰çš„ CSS è®Šæ•¸ï¼ˆä½¿ç”¨æ·±æ‹·è²é¿å…å¼•ç”¨å•é¡Œï¼‰
            customVars = JSON.parse(JSON.stringify(tabVariables[groupKey].cssVars || []));
            renderVarControls();
        }

        // æƒæç•¶å‰ Tab çš„è®Šæ•¸ï¼ˆæŒ‰ Tab ç¨ç«‹å„²å­˜ï¼‰
        function scanCurrentTabVariables() {
            let content = '';
            const currentTab = activeEditorTab;

            // æ ¹æ“šç•¶å‰ Tab ç²å–å°æ‡‰ç·¨è¼¯å™¨å…§å®¹
            switch (currentTab) {
                case 'css':
                    content = cssEditor ? cssEditor.getValue() : '';
                    break;
                case 'html':
                    content = htmlEditor ? htmlEditor.getValue() : '';
                    break;
                case 'regex':
                    // Regex Tab æƒæç•¶å‰è¦å‰‡çš„ OUT æ¬„ä½
                    content = regexOutputEditor ? regexOutputEditor.getValue() : '';
                    break;
                case 'story':
                    // åŠ‡æƒ… Tab æƒæ storyEditor
                    content = storyEditor ? storyEditor.getValue() : '';
                    break;
            }

            if (!content.trim()) {
                alert('ç•¶å‰ Tab æ²’æœ‰å¯æƒæçš„å…§å®¹ï¼');
                return;
            }

            // æƒæ RISU è®Šæ•¸ï¼ˆgetvar, gettempvar, image, etc.ï¼‰
            const groupKey = getVarGroupKey(currentTab);  // [å·²ä¿®æ”¹] ä½¿ç”¨å…±ç”¨è®Šæ•¸çµ„
            const tabVars = tabVariables[groupKey].risuVars;
            let stringCounter = Object.keys(tabVars).length + 1;
            let newCount = 0;
            const conditionValues = {};

            // [å·²ä¿®å¾©] 1. å„ªå…ˆæƒææ¢ä»¶èªå¥ï¼Œæ•æ‰è®Šæ•¸çš„ç¬¬ä¸€å€‹å°æ¯”å€¼
            // æ ¼å¼: {{equal::{{gettempvar::NAME}}::VALUE}} ç­‰
            const condPatterns = [
                // {{equal::{{gettempvar::NAME}}::VALUE}}
                /\{\{equal::\{\{(?:getvar|gettempvar)::([^}]+)\}\}::([^{}]+)\}\}/gi,
                // {{not_equal::{{gettempvar::NAME}}::VALUE}}
                /\{\{not_equal::\{\{(?:getvar|gettempvar)::([^}]+)\}\}::([^{}]+)\}\}/gi,
                // {{greater::{{gettempvar::NAME}}::VALUE}}
                /\{\{greater(?:_equal)?::\{\{(?:getvar|gettempvar)::([^}]+)\}\}::([^{}]+)\}\}/gi,
                // {{less::{{gettempvar::NAME}}::VALUE}}
                /\{\{less(?:_equal)?::\{\{(?:getvar|gettempvar)::([^}]+)\}\}::([^{}]+)\}\}/gi,
                // {{getvar::NAME}}=VALUE æˆ– {{getvar::NAME}}==VALUE
                /\{\{(?:getvar|gettempvar)::([^}]+)\}\}\s*[=!<>]+\s*(\d+|"[^"]*"|'[^']*'|\w+)/gi,
                // {{#if ... getvar::NAME ... VALUE ...
                /\{\{#if[^}]*(?:getvar|gettempvar)::([^}]+?)[\s=!<>Â§]+['"]?([^'"\s}]+)/gi
            ];

            for (const pattern of condPatterns) {
                let condMatch;
                while ((condMatch = pattern.exec(content)) !== null) {
                    const varName = condMatch[1].trim();
                    let value = condMatch[2].replace(/["']/g, '').trim();

                    // åªè¨˜éŒ„ç¬¬ä¸€å€‹æ•æ‰åˆ°çš„å€¼
                    if (!conditionValues[varName]) {
                        conditionValues[varName] = value;
                    }
                }
            }

            // 2. æƒæ getvar/gettempvar
            const varPattern = /\{\{(?:getvar|gettempvar)::([^{}]+)\}\}/gi;
            let varMatch;
            while ((varMatch = varPattern.exec(content)) !== null) {
                const varName = varMatch[1].trim();
                if (!tabVars[varName]) {
                    const condValue = conditionValues[varName];
                    tabVars[varName] = {
                        value: condValue || `string_${stringCounter++}`,
                        type: 'string',
                        autoNamed: !condValue
                    };
                    newCount++;
                }
            }

            // 3. æƒæåœ–ç‰‡è³‡ç”¢ï¼ˆRISU æ¨™æº–æ ¼å¼ï¼‰
            const assetPattern = /\{\{(image|img|raw|path|bg)::([^{}]+)\}\}/gi;
            let assetMatch;
            while ((assetMatch = assetPattern.exec(content)) !== null) {
                const assetName = assetMatch[2].trim();
                if (!tabVars[assetName]) {
                    tabVars[assetName] = {
                        value: '800x600',
                        type: 'asset',
                        assetType: assetMatch[1].toLowerCase(),
                        autoNamed: false
                    };
                    newCount++;
                }
            }

            // 4. æƒæ <img="..."> å’Œ <imgs="..."> æ ¼å¼ï¼ˆè§’è‰²å¡å¸¸è¦‹çš„åœ–ç‰‡ä½”ä½ç¬¦ï¼‰
            // é€™ç¨®æ ¼å¼é€šå¸¸æœƒè¢« Regex è¦å‰‡æ•ç²ä¸¦è½‰æ›ç‚ºå¯¦éš›åœ–ç‰‡
            const imgTagPattern = /<\s*imgs?\s*=\s*["']([^"']+)["']\s*>/gi;
            let imgTagMatch;
            while ((imgTagMatch = imgTagPattern.exec(content)) !== null) {
                const assetName = imgTagMatch[1].trim();
                if (!tabVars[assetName]) {
                    tabVars[assetName] = {
                        value: '800x600',
                        type: 'asset',
                        assetType: 'img',  // é è¨­ç‚º img é¡å‹
                        autoNamed: false
                    };
                    newCount++;
                }
            }

            // åŒæ­¥åˆ°å…±ç”¨è®Šæ•¸ä¸¦æ¸²æŸ“
            syncTabVariables();
            updateUploadedImageCount();
            render(); // [æ–°å¢] è‡ªå‹•åˆ·æ–°é è¦½å€

            if (newCount > 0) {
                console.log(`ğŸ“¡ [${currentTab.toUpperCase()}] æƒæå®Œæˆï¼ç™¼ç¾ ${newCount} å€‹æ–°è®Šæ•¸`);
                alert(`âœ… æƒæå®Œæˆï¼ç™¼ç¾ ${newCount} å€‹æ–°è®Šæ•¸`);
            } else {
                console.log(`ğŸ“¡ [${currentTab.toUpperCase()}] æƒæå®Œæˆï¼æ²’æœ‰ç™¼ç¾æ–°è®Šæ•¸`);
                alert(`ğŸ“¡ æƒæå®Œæˆï¼æ²’æœ‰ç™¼ç¾æ–°è®Šæ•¸`);
            }
        }

        // ====== æƒæä¸‹æ‹‰é¸å–®æ§åˆ¶ ======
        function toggleScanMenu(event) {
            event.stopPropagation();
            const menu = document.getElementById('scanDropdownMenu');
            menu.classList.toggle('hidden');
            
            // é»æ“Šå…¶ä»–åœ°æ–¹é—œé–‰é¸å–®
            if (!menu.classList.contains('hidden')) {
                setTimeout(() => {
                    document.addEventListener('click', hideScanMenuOnClickOutside, { once: true });
                }, 0);
            }
        }

        function hideScanMenu() {
            document.getElementById('scanDropdownMenu').classList.add('hidden');
        }

        function hideScanMenuOnClickOutside(event) {
            const container = document.getElementById('scanBtnContainer');
            if (!container.contains(event.target)) {
                hideScanMenu();
            }
        }

        // æ™ºèƒ½å…¨æƒï¼šæ ¹æ“šç•¶å‰æ¨¡å¼è‡ªå‹•é¸æ“‡æ­£ç¢ºçš„å…¨æƒæ–¹æ³•
        function smartScanAll() {
            const groupKey = getVarGroupKey(activeEditorTab);
            if (groupKey === 'simple') {
                scanAllSimplePages();
            } else {
                scanAllDisplayRules();
            }
        }

        // ====== å…¨æƒæï¼šæƒææ‰€æœ‰ editdisplay è¦å‰‡ ======
        // è¿½è¹¤ RISU è®Šæ•¸çš„åˆ†çµ„å±•é–‹ç‹€æ…‹
        let expandedRisuGroups = {};

        function scanAllDisplayRules() {
            // åªåœ¨ Regex/Story æ¨¡å¼ä¸‹æœ‰æ•ˆ
            if (activeEditorTab !== 'regex' && activeEditorTab !== 'story') {
                alert('å…¨æƒåŠŸèƒ½åƒ…åœ¨ Regex/Story æ¨¡å¼ä¸‹å¯ç”¨ï¼');
                return;
            }

            // ç¯©é¸æ‰€æœ‰ type === 'editdisplay' çš„è¦å‰‡
            const displayRules = regexRules.filter(r => r.type === 'editdisplay');
            if (displayRules.length === 0) {
                alert('æ²’æœ‰ã€Œä¿®æ”¹é¡¯ç¤ºã€é¡å‹çš„è¦å‰‡å¯ä¾›æƒæï¼');
                return;
            }

            const groupKey = getVarGroupKey(activeEditorTab);
            const tabVars = tabVariables[groupKey].risuVars;
            let stringCounter = Object.keys(tabVars).length + 1;
            let newCount = 0;

            // æƒææ¯æ¢è¦å‰‡
            displayRules.forEach(rule => {
                const content = rule.output || '';
                if (!content.trim()) return;

                const ruleName = rule.name || 'æœªå‘½åè¦å‰‡';

                // å„ªå…ˆæƒææ¢ä»¶èªå¥ï¼Œæ•æ‰è®Šæ•¸å°æ¯”å€¼
                const conditionValues = {};
                const condPatterns = [
                    /\{\{equal::\{\{(?:getvar|gettempvar)::([^}]+)\}\}::([^{}]+)\}\}/gi,
                    /\{\{not_equal::\{\{(?:getvar|gettempvar)::([^}]+)\}\}::([^{}]+)\}\}/gi,
                    /\{\{greater(?:_equal)?::\{\{(?:getvar|gettempvar)::([^}]+)\}\}::([^{}]+)\}\}/gi,
                    /\{\{less(?:_equal)?::\{\{(?:getvar|gettempvar)::([^}]+)\}\}::([^{}]+)\}\}/gi,
                    /\{\{(?:getvar|gettempvar)::([^}]+)\}\}\s*[=!<>]+\s*(\d+|"[^"]*"|'[^']*'|\w+)/gi
                ];

                for (const pattern of condPatterns) {
                    let condMatch;
                    while ((condMatch = pattern.exec(content)) !== null) {
                        const varName = condMatch[1].trim();
                        let value = condMatch[2].replace(/["']/g, '').trim();
                        if (!conditionValues[varName]) {
                            conditionValues[varName] = value;
                        }
                    }
                }

                // æƒæ getvar/gettempvar
                const varPattern = /\{\{(?:getvar|gettempvar)::([^{}]+)\}\}/gi;
                let varMatch;
                while ((varMatch = varPattern.exec(content)) !== null) {
                    const varName = varMatch[1].trim();
                    if (!tabVars[varName]) {
                        // æ–°è®Šæ•¸
                        const condValue = conditionValues[varName];
                        tabVars[varName] = {
                            value: condValue || `string_${stringCounter++}`,
                            type: 'string',
                            autoNamed: !condValue,
                            sources: [ruleName]  // è¨˜éŒ„ä¾†æºè¦å‰‡
                        };
                        newCount++;
                    } else {
                        // å·²å­˜åœ¨çš„è®Šæ•¸ï¼Œæ·»åŠ ä¾†æºï¼ˆå¦‚æœå°šæœªè¨˜éŒ„ï¼‰
                        if (!tabVars[varName].sources) {
                            tabVars[varName].sources = [];
                        }
                        if (!tabVars[varName].sources.includes(ruleName)) {
                            tabVars[varName].sources.push(ruleName);
                        }
                    }
                }

                // æƒæåœ–ç‰‡è³‡ç”¢
                const assetPattern = /\{\{(image|img|raw|path|bg)::([^{}]+)\}\}/gi;
                let assetMatch;
                while ((assetMatch = assetPattern.exec(content)) !== null) {
                    const assetName = assetMatch[2].trim();
                    if (!tabVars[assetName]) {
                        tabVars[assetName] = {
                            value: '800x600',
                            type: 'asset',
                            assetType: assetMatch[1].toLowerCase(),
                            autoNamed: false,
                            sources: [ruleName]
                        };
                        newCount++;
                    } else {
                        if (!tabVars[assetName].sources) {
                            tabVars[assetName].sources = [];
                        }
                        if (!tabVars[assetName].sources.includes(ruleName)) {
                            tabVars[assetName].sources.push(ruleName);
                        }
                    }
                }
            });

            // [æ–°å¢] æƒæåŠ‡æƒ…ç·¨è¼¯å™¨å…§å®¹
            const storyContent = storyEditor ? storyEditor.getValue() : '';
            if (storyContent.trim()) {
                scanContentForRisuVars(storyContent, 'åŠ‡æƒ…', tabVars, stringCounter, (count) => {
                    newCount += count;
                });
            }

            // åŒæ­¥ä¸¦æ¸²æŸ“
            syncTabVariables();
            updateUploadedImageCount();
            render();

            const rulesScanned = displayRules.length;
            if (newCount > 0) {
                console.log(`ğŸ“¡ [å…¨æƒ] æƒæ ${rulesScanned} æ¢è¦å‰‡ + åŠ‡æƒ…å®Œæˆï¼ç™¼ç¾ ${newCount} å€‹æ–°è®Šæ•¸`);
                alert(`âœ… å·²æƒæ ${rulesScanned} æ¢ã€Œä¿®æ”¹é¡¯ç¤ºã€è¦å‰‡ + åŠ‡æƒ…ï¼\nç™¼ç¾ ${newCount} å€‹æ–°è®Šæ•¸`);
            } else {
                console.log(`ğŸ“¡ [å…¨æƒ] æƒæ ${rulesScanned} æ¢è¦å‰‡ + åŠ‡æƒ…å®Œæˆï¼æ²’æœ‰ç™¼ç¾æ–°è®Šæ•¸`);
                alert(`ğŸ“¡ å·²æƒæ ${rulesScanned} æ¢ã€Œä¿®æ”¹é¡¯ç¤ºã€è¦å‰‡ + åŠ‡æƒ…ï¼\næ²’æœ‰ç™¼ç¾æ–°è®Šæ•¸`);
            }
        }

        // ====== ç°¡æ˜“æ¨¡å¼å…¨æƒï¼šæƒææ‰€æœ‰ CSS + HTML åˆ†é  ======
        function scanAllSimplePages() {
            // åªåœ¨ç°¡æ˜“æ¨¡å¼ä¸‹æœ‰æ•ˆ
            if (activeEditorTab !== 'css' && activeEditorTab !== 'html') {
                alert('æ­¤å…¨æƒåŠŸèƒ½åƒ…åœ¨ CSS/HTML æ¨¡å¼ä¸‹å¯ç”¨ï¼');
                return;
            }

            // å…ˆå„²å­˜ç•¶å‰ç·¨è¼¯å™¨å…§å®¹
            saveCurrentCss();
            saveCurrentPage();

            const groupKey = getVarGroupKey(activeEditorTab);
            const tabVars = tabVariables[groupKey].risuVars;
            let stringCounter = Object.keys(tabVars).length + 1;
            let newCount = 0;

            // æƒææ‰€æœ‰ CSS åˆ†é 
            cssGroups.forEach(css => {
                const content = css.content || '';
                if (!content.trim()) return;
                scanContentForRisuVars(content, css.name, tabVars, stringCounter, (count) => {
                    newCount += count;
                    stringCounter += count;
                });
            });

            // æƒææ‰€æœ‰ HTML åˆ†é 
            htmlPages.forEach(page => {
                const content = page.content || '';
                if (!content.trim()) return;
                scanContentForRisuVars(content, page.name, tabVars, stringCounter, (count) => {
                    newCount += count;
                    stringCounter += count;
                });
            });

            // åŒæ­¥ä¸¦æ¸²æŸ“
            syncTabVariables();
            updateUploadedImageCount();
            render();

            const totalPages = cssGroups.length + htmlPages.length;
            if (newCount > 0) {
                console.log(`ğŸ“¡ [å…¨æƒ] æƒæ ${totalPages} å€‹åˆ†é å®Œæˆï¼ç™¼ç¾ ${newCount} å€‹æ–°è®Šæ•¸`);
                alert(`âœ… å·²æƒæ ${totalPages} å€‹åˆ†é ï¼\nç™¼ç¾ ${newCount} å€‹æ–°è®Šæ•¸`);
            } else {
                console.log(`ğŸ“¡ [å…¨æƒ] æƒæ ${totalPages} å€‹åˆ†é å®Œæˆï¼æ²’æœ‰ç™¼ç¾æ–°è®Šæ•¸`);
                alert(`ğŸ“¡ å·²æƒæ ${totalPages} å€‹åˆ†é ï¼\næ²’æœ‰ç™¼ç¾æ–°è®Šæ•¸`);
            }
        }

        // è¼”åŠ©å‡½æ•¸ï¼šæƒæå…§å®¹ä¸­çš„ RISU è®Šæ•¸
        function scanContentForRisuVars(content, sourceName, tabVars, startCounter, onCountUpdate) {
            let localCount = 0;
            let stringCounter = startCounter;

            // å„ªå…ˆæƒææ¢ä»¶èªå¥ï¼Œæ•æ‰è®Šæ•¸å°æ¯”å€¼
            const conditionValues = {};
            const condPatterns = [
                /\{\{equal::\{\{(?:getvar|gettempvar)::([^}]+)\}\}::([^{}]+)\}\}/gi,
                /\{\{not_equal::\{\{(?:getvar|gettempvar)::([^}]+)\}\}::([^{}]+)\}\}/gi,
                /\{\{greater(?:_equal)?::\{\{(?:getvar|gettempvar)::([^}]+)\}\}::([^{}]+)\}\}/gi,
                /\{\{less(?:_equal)?::\{\{(?:getvar|gettempvar)::([^}]+)\}\}::([^{}]+)\}\}/gi,
                /\{\{(?:getvar|gettempvar)::([^}]+)\}\}\s*[=!<>]+\s*(\d+|"[^"]*"|'[^']*'|\w+)/gi
            ];

            for (const pattern of condPatterns) {
                let condMatch;
                while ((condMatch = pattern.exec(content)) !== null) {
                    const varName = condMatch[1].trim();
                    let value = condMatch[2].replace(/["']/g, '').trim();
                    if (!conditionValues[varName]) {
                        conditionValues[varName] = value;
                    }
                }
            }

            // æƒæ getvar/gettempvar
            const varPattern = /\{\{(?:getvar|gettempvar)::([^{}]+)\}\}/gi;
            let varMatch;
            while ((varMatch = varPattern.exec(content)) !== null) {
                const varName = varMatch[1].trim();
                if (!tabVars[varName]) {
                    const condValue = conditionValues[varName];
                    tabVars[varName] = {
                        value: condValue || `string_${stringCounter++}`,
                        type: 'string',
                        autoNamed: !condValue,
                        sources: [sourceName]
                    };
                    localCount++;
                } else {
                    if (!tabVars[varName].sources) tabVars[varName].sources = [];
                    if (!tabVars[varName].sources.includes(sourceName)) {
                        tabVars[varName].sources.push(sourceName);
                    }
                }
            }

            // æƒæåœ–ç‰‡è³‡ç”¢
            const assetPattern = /\{\{(image|img|raw|path|bg)::([^{}]+)\}\}/gi;
            let assetMatch;
            while ((assetMatch = assetPattern.exec(content)) !== null) {
                const assetName = assetMatch[2].trim();
                if (!tabVars[assetName]) {
                    tabVars[assetName] = {
                        value: '800x600',
                        type: 'asset',
                        assetType: assetMatch[1].toLowerCase(),
                        autoNamed: false,
                        sources: [sourceName]
                    };
                    localCount++;
                } else {
                    if (!tabVars[assetName].sources) tabVars[assetName].sources = [];
                    if (!tabVars[assetName].sources.includes(sourceName)) {
                        tabVars[assetName].sources.push(sourceName);
                    }
                }
            }

            // æƒæ <img="..."> å’Œ <imgs="..."> æ ¼å¼ï¼ˆè§’è‰²å¡å¸¸è¦‹çš„åœ–ç‰‡ä½”ä½ç¬¦ï¼‰
            const imgTagPattern = /<\s*imgs?\s*=\s*["']([^"']+)["']\s*>/gi;
            let imgTagMatch;
            while ((imgTagMatch = imgTagPattern.exec(content)) !== null) {
                const assetName = imgTagMatch[1].trim();
                if (!tabVars[assetName]) {
                    tabVars[assetName] = {
                        value: '800x600',
                        type: 'asset',
                        assetType: 'img',
                        autoNamed: false,
                        sources: [sourceName]
                    };
                    localCount++;
                } else {
                    if (!tabVars[assetName].sources) tabVars[assetName].sources = [];
                    if (!tabVars[assetName].sources.includes(sourceName)) {
                        tabVars[assetName].sources.push(sourceName);
                    }
                }
            }

            onCountUpdate(localCount);
        }

        // [å·²ä¿®æ”¹] åœ¨ç•¶å‰ Tab ç·¨è¼¯å™¨ä¸­å®šä½ RISU è®Šæ•¸ï¼ŒRegex æ¨¡å¼æœƒæœå°‹æ‰€æœ‰ editdisplay è¦å‰‡
        function locateRisuVariable(varName) {
            // æ§‹å»ºæœå°‹æ¨¡å¼ï¼ˆæ”¯æ´å¤šç¨® RISU è®Šæ•¸æ ¼å¼ï¼‰
            const searchPatterns = [
                `{{getvar::${varName}}}`,
                `{{gettempvar::${varName}}}`,
                `{{image::${varName}}}`,
                `{{img::${varName}}}`,
                `{{bg::${varName}}}`,
                `{{raw::${varName}}}`,
                `{{path::${varName}}}`
            ];

            // æ ¹æ“šç•¶å‰è®Šæ•¸çµ„æ±ºå®šè¦æœå°‹çš„ç·¨è¼¯å™¨é †åº
            const groupKey = getVarGroupKey(activeEditorTab);

            if (groupKey === 'simple') {
                // ====== ç°¡æ˜“æ¨¡å¼ï¼šå…ˆæœç•¶å‰ç·¨è¼¯å™¨ï¼Œå†æœæ‰€æœ‰åˆ†é  ======
                
                // 1. å…ˆæœå°‹ç•¶å‰ç·¨è¼¯å™¨
                const currentEditor = activeEditorTab === 'css' ? cssEditor : htmlEditor;
                if (currentEditor) {
                    const code = currentEditor.getValue();
                    for (const pattern of searchPatterns) {
                        const index = code.indexOf(pattern);
                        if (index !== -1) {
                            locateInEditor(currentEditor, activeEditorTab.toUpperCase(), activeEditorTab, code, pattern, index, varName);
                            return;
                        }
                    }
                }

                // 2. æœå°‹å¦ä¸€å€‹ç·¨è¼¯å™¨
                const otherEditor = activeEditorTab === 'css' ? htmlEditor : cssEditor;
                const otherTab = activeEditorTab === 'css' ? 'html' : 'css';
                if (otherEditor) {
                    const code = otherEditor.getValue();
                    for (const pattern of searchPatterns) {
                        const index = code.indexOf(pattern);
                        if (index !== -1) {
                            switchTab(otherTab);
                            locateInEditor(otherEditor, otherTab.toUpperCase(), otherTab, code, pattern, index, varName);
                            return;
                        }
                    }
                }

                // 3. å…ˆå„²å­˜ç•¶å‰åˆ†é ï¼Œç„¶å¾Œæœå°‹æ‰€æœ‰å…¶ä»– CSS åˆ†é 
                saveCurrentCss();
                for (const css of cssGroups) {
                    if (css.id === activeCssId) continue; // è·³éç•¶å‰åˆ†é ï¼ˆå·²æœå°‹éï¼‰
                    const content = css.content || '';
                    for (const pattern of searchPatterns) {
                        const index = content.indexOf(pattern);
                        if (index !== -1) {
                            // æ‰¾åˆ°äº†ï¼åˆ‡æ›åˆ°è©² CSS åˆ†é 
                            switchTab('css');
                            switchCss(css.id);
                            setTimeout(() => {
                                if (cssEditor) {
                                    const newCode = cssEditor.getValue();
                                    const newIndex = newCode.indexOf(pattern);
                                    if (newIndex !== -1) {
                                        locateInEditor(cssEditor, 'CSS', 'css', newCode, pattern, newIndex, varName);
                                    }
                                }
                            }, 50);
                            console.log(`ğŸ” åœ¨ CSS åˆ†é ã€Œ${css.name}ã€ä¸­æ‰¾åˆ°è®Šæ•¸ ${varName}ï¼Œå·²è‡ªå‹•åˆ‡æ›`);
                            return;
                        }
                    }
                }

                // 4. æœå°‹æ‰€æœ‰å…¶ä»– HTML åˆ†é 
                saveCurrentPage();
                for (const page of htmlPages) {
                    if (page.id === activePageId) continue; // è·³éç•¶å‰åˆ†é ï¼ˆå·²æœå°‹éï¼‰
                    const content = page.content || '';
                    for (const pattern of searchPatterns) {
                        const index = content.indexOf(pattern);
                        if (index !== -1) {
                            // æ‰¾åˆ°äº†ï¼åˆ‡æ›åˆ°è©² HTML åˆ†é 
                            switchTab('html');
                            switchPage(page.id);
                            setTimeout(() => {
                                if (htmlEditor) {
                                    const newCode = htmlEditor.getValue();
                                    const newIndex = newCode.indexOf(pattern);
                                    if (newIndex !== -1) {
                                        locateInEditor(htmlEditor, 'HTML', 'html', newCode, pattern, newIndex, varName);
                                    }
                                }
                            }, 50);
                            console.log(`ğŸ” åœ¨ HTML åˆ†é ã€Œ${page.name}ã€ä¸­æ‰¾åˆ°è®Šæ•¸ ${varName}ï¼Œå·²è‡ªå‹•åˆ‡æ›`);
                            return;
                        }
                    }
                }

                alert(`åœ¨æ‰€æœ‰ CSS å’Œ HTML åˆ†é ä¸­éƒ½æ‰¾ä¸åˆ°è®Šæ•¸ \"${varName}\" çš„å¼•ç”¨ã€‚`);
            } else {
                // ====== Regex æ¨¡å¼ï¼šå…ˆæœç•¶å‰ç·¨è¼¯å™¨ï¼Œå†æœæ‰€æœ‰ editdisplay è¦å‰‡ ======
                
                // 1. å…ˆæœå°‹ç•¶å‰è¦å‰‡çš„ç·¨è¼¯å™¨
                if (regexOutputEditor) {
                    const code = regexOutputEditor.getValue();
                    for (const pattern of searchPatterns) {
                        const index = code.indexOf(pattern);
                        if (index !== -1) {
                            locateInEditor(regexOutputEditor, 'Regex', 'regex', code, pattern, index, varName);
                            return;
                        }
                    }
                }

                // 2. æœå°‹ Story ç·¨è¼¯å™¨
                if (storyEditor) {
                    const code = storyEditor.getValue();
                    for (const pattern of searchPatterns) {
                        const index = code.indexOf(pattern);
                        if (index !== -1) {
                            if (activeEditorTab !== 'story') {
                                switchTab('story');
                            }
                            locateInEditor(storyEditor, 'åŠ‡æƒ…', 'story', code, pattern, index, varName);
                            return;
                        }
                    }
                }

                // 3. æœå°‹æ‰€æœ‰ editdisplay è¦å‰‡ï¼ˆé™¤äº†ç•¶å‰è¦å‰‡ï¼‰
                const displayRules = regexRules.filter(r => r.type === 'editdisplay' && r.id !== activeRuleId);
                for (const rule of displayRules) {
                    const content = rule.output || '';
                    for (const pattern of searchPatterns) {
                        const index = content.indexOf(pattern);
                        if (index !== -1) {
                            // æ‰¾åˆ°äº†ï¼åˆ‡æ›åˆ°è©²è¦å‰‡
                            activeRuleId = rule.id;
                            loadRuleToEditor(rule);
                            renderRuleList();
                            
                            // ç­‰ç·¨è¼¯å™¨æ›´æ–°å¾Œå®šä½
                            setTimeout(() => {
                                if (regexOutputEditor) {
                                    const newCode = regexOutputEditor.getValue();
                                    const newIndex = newCode.indexOf(pattern);
                                    if (newIndex !== -1) {
                                        locateInEditor(regexOutputEditor, 'Regex', 'regex', newCode, pattern, newIndex, varName);
                                    }
                                }
                            }, 50);
                            
                            console.log(`ğŸ” åœ¨è¦å‰‡ã€Œ${rule.name}ã€ä¸­æ‰¾åˆ°è®Šæ•¸ ${varName}ï¼Œå·²è‡ªå‹•åˆ‡æ›`);
                            return;
                        }
                    }
                }

                alert(`åœ¨æ‰€æœ‰ã€Œä¿®æ”¹é¡¯ç¤ºã€è¦å‰‡å’ŒåŠ‡æƒ…ç·¨è¼¯å™¨ä¸­éƒ½æ‰¾ä¸åˆ°è®Šæ•¸ \"${varName}\" çš„å¼•ç”¨ã€‚`);
            }
        }

        // è¼”åŠ©å‡½æ•¸ï¼šåœ¨ç·¨è¼¯å™¨ä¸­å®šä½ä¸¦é«˜äº®
        function locateInEditor(editor, name, tab, code, pattern, index, varName) {
            const textBefore = code.substring(0, index);
            const lines = textBefore.split('\n');
            const lineNumber = lines.length;
            const column = lines[lines.length - 1].length + 1;

            if (tab !== activeEditorTab) {
                switchTab(tab);
                console.log(`ğŸ” åœ¨ ${name} ç·¨è¼¯å™¨ä¸­æ‰¾åˆ°è®Šæ•¸ ${varName}ï¼Œå·²è‡ªå‹•åˆ‡æ› Tab`);
            }

            editor.setSelection({
                startLineNumber: lineNumber,
                startColumn: column,
                endLineNumber: lineNumber,
                endColumn: column + pattern.length
            });
            editor.revealLineInCenter(lineNumber);
            editor.focus();
            console.log(`ğŸ” å·²å®šä½è®Šæ•¸ ${varName} æ–¼ ${name} ç·¨è¼¯å™¨ç¬¬ ${lineNumber} è¡Œ`);
        }

        // æ¸²æŸ“ RISU è®Šæ•¸åˆ—è¡¨ï¼ˆæ”¯æ´åˆ†çµ„é¡¯ç¤ºï¼‰
        function renderRisuVars() {
            const container = document.getElementById('risuVarsContainer');
            const msg = document.getElementById('noRisuVarsMsg');
            const names = Object.keys(risuSimVars);

            if (names.length === 0) {
                if (msg) msg.style.display = 'block';
                container.innerHTML = '';
                return;
            }
            if (msg) msg.style.display = 'none';

            // æª¢æŸ¥æ˜¯å¦æœ‰è®Šæ•¸å¸¶æœ‰ sources è³‡è¨Šï¼ˆå…¨æƒææ¨¡å¼ï¼‰
            const hasSourceInfo = names.some(n => risuSimVars[n].sources && risuSimVars[n].sources.length > 0);
            
            // åˆ†é›¢ä¸€èˆ¬è®Šæ•¸å’Œåœ–ç‰‡è³‡ç”¢
            const normalVars = names.filter(n => risuSimVars[n].type !== 'asset');
            const assetVars = names.filter(n => risuSimVars[n].type === 'asset');

            let html = '';

            if (hasSourceInfo) {
                // ====== åˆ†çµ„æ¨¡å¼ï¼ˆå…¨æƒæçµæœï¼‰======
                // æŒ‰ç¬¬ä¸€å€‹ä¾†æºè¦å‰‡åˆ†çµ„
                const groupedVars = {};
                const multiSourceVars = []; // è·¨å¤šè¦å‰‡çš„è®Šæ•¸

                names.forEach(name => {
                    const v = risuSimVars[name];
                    const sources = v.sources || ['æœªåˆ†é¡'];
                    if (sources.length > 1) {
                        multiSourceVars.push(name);
                    }
                    // æ­¸é¡åˆ°ç¬¬ä¸€å€‹ä¾†æº
                    const primarySource = sources[0] || 'æœªåˆ†é¡';
                    if (!groupedVars[primarySource]) {
                        groupedVars[primarySource] = [];
                    }
                    groupedVars[primarySource].push(name);
                });

                // æ¸²æŸ“è·¨è¦å‰‡å…±ç”¨è®Šæ•¸ï¼ˆå¦‚æœæœ‰ï¼‰
                if (multiSourceVars.length > 0) {
                    const isExpanded = expandedRisuGroups['__shared__'] !== false;
                    html += `
                        <div class="risu-var-group mb-2" data-group="__shared__">
                            <div class="flex items-center gap-1 cursor-pointer select-none py-1 px-2 bg-[#2d2d3a] rounded-t hover:bg-[#3d3d4a] transition"
                                onclick="toggleRisuVarGroup('__shared__')">
                                <span class="text-[10px] text-[#f9e2af]">${isExpanded ? 'â–¼' : 'â–¶'}</span>
                                <span class="text-xs text-[#f9e2af] font-bold">ğŸ”— å…±ç”¨è®Šæ•¸</span>
                                <span class="text-[10px] text-[#6c7086] ml-auto">${multiSourceVars.length} å€‹</span>
                            </div>
                            <div class="risu-var-group-content ${isExpanded ? '' : 'hidden'} bg-[#1e1e2e] rounded-b p-1 space-y-1">
                                ${multiSourceVars.map(name => renderRisuVarItem(name, true)).join('')}
                            </div>
                        </div>
                    `;
                }

                // æ¸²æŸ“å„è¦å‰‡åˆ†çµ„
                Object.keys(groupedVars).forEach(groupName => {
                    const varsInGroup = groupedVars[groupName];
                    const isExpanded = expandedRisuGroups[groupName] !== false;
                    html += `
                        <div class="risu-var-group mb-2" data-group="${groupName}">
                            <div class="flex items-center gap-1 cursor-pointer select-none py-1 px-2 bg-[#2d2d3a] rounded-t hover:bg-[#3d3d4a] transition"
                                onclick="toggleRisuVarGroup('${groupName.replace(/'/g, "\\'")}')">
                                <span class="text-[10px] text-[#89b4fa]">${isExpanded ? 'â–¼' : 'â–¶'}</span>
                                <span class="text-xs text-[#89b4fa] truncate" title="${groupName}">ğŸ“‹ ${groupName}</span>
                                <span class="text-[10px] text-[#6c7086] ml-auto">${varsInGroup.length} å€‹</span>
                            </div>
                            <div class="risu-var-group-content ${isExpanded ? '' : 'hidden'} bg-[#1e1e2e] rounded-b p-1 space-y-1">
                                ${varsInGroup.map(name => renderRisuVarItem(name, false)).join('')}
                            </div>
                        </div>
                    `;
                });
            } else {
                // ====== ç„¡åˆ†çµ„æ¨¡å¼ï¼ˆç•¶å‰æƒææˆ–ç°¡æ˜“æ¨¡å¼ï¼‰======
                // æ¸²æŸ“ä¸€èˆ¬è®Šæ•¸
                if (normalVars.length > 0) {
                    html += normalVars.map(name => renderRisuVarItem(name, false)).join('');
                }

                // æ¸²æŸ“åœ–ç‰‡è³‡ç”¢
                if (assetVars.length > 0) {
                    if (normalVars.length > 0) {
                        html += '<div class="border-b border-[#313244] my-2"></div>';
                    }
                    html += '<div class="text-[10px] text-[#6c7086] mb-1">ğŸ“· åœ–ç‰‡è³‡ç”¢</div>';
                    html += assetVars.map(name => renderRisuVarItem(name, false)).join('');
                }
            }

            container.innerHTML = html;
        }

        // æ¸²æŸ“å–®å€‹ RISU è®Šæ•¸é …ç›®
        function renderRisuVarItem(name, showSourceBadge) {
            const v = risuSimVars[name];
            const isAsset = v.type === 'asset';
            const shortName = name.length > 20 ? name.substring(0, 17) + '...' : name;
            const sourceBadge = showSourceBadge && v.sources && v.sources.length > 1 
                ? `<span class="text-[9px] text-[#f9e2af] bg-[#45475a] px-1 rounded" title="å…±ç”¨æ–¼: ${v.sources.join(', ')}">${v.sources.length}è¦å‰‡</span>` 
                : '';

            if (isAsset) {
                return `
                    <div class="flex items-center gap-2 bg-[#252530] p-2 rounded text-xs group">
                        <span class="text-[#f9e2af] font-mono flex-1 truncate" title="${name}">ğŸ“· ${shortName}</span>
                        ${sourceBadge}
                        <select onchange="updateRisuVar('${name}', this.value)"
                            class="w-24 bg-[#313244] text-[#cdd6f4] border border-[#45475a] rounded px-1 py-0.5 text-xs">
                            <option value="800x600" ${v.value === '800x600' ? 'selected' : ''}>800Ã—600</option>
                            <option value="1280x800" ${v.value === '1280x800' ? 'selected' : ''}>1280Ã—800</option>
                            <option value="1920x1080" ${v.value === '1920x1080' ? 'selected' : ''}>1920Ã—1080</option>
                            <option value="400x400" ${v.value === '400x400' ? 'selected' : ''}>400Ã—400</option>
                            ${getUploadedImageOptions(v.value)}
                        </select>
                        <button onclick="locateRisuVariable('${name}')" 
                            class="text-[#94e2d5] opacity-50 group-hover:opacity-100 hover:text-[#a6e3a1] transition px-1"
                            title="å®šä½åˆ°ç·¨è¼¯å™¨">ğŸ”</button>
                        <button onclick="removeRisuVar('${name}')" 
                            class="text-[#f38ba8] opacity-0 group-hover:opacity-100 hover:text-red-400 transition px-1"
                            title="ç§»é™¤">Ã—</button>
                    </div>
                `;
            } else {
                return `
                    <div class="flex items-center gap-2 bg-[#252530] p-2 rounded text-xs group">
                        <span class="text-[#89b4fa] font-mono flex-1 truncate" title="${name}">${shortName}</span>
                        ${sourceBadge}
                        <input type="text" value="${v.value}" 
                            onchange="updateRisuVar('${name}', this.value)"
                            class="w-20 bg-[#313244] text-[#cdd6f4] border border-[#45475a] rounded px-1.5 py-0.5 text-xs">
                        <button onclick="locateRisuVariable('${name}')" 
                            class="text-[#94e2d5] opacity-50 group-hover:opacity-100 hover:text-[#a6e3a1] transition px-1"
                            title="å®šä½åˆ°ç·¨è¼¯å™¨">ğŸ”</button>
                        <button onclick="removeRisuVar('${name}')" 
                            class="text-[#f38ba8] opacity-0 group-hover:opacity-100 hover:text-red-400 transition px-1"
                            title="ç§»é™¤">Ã—</button>
                    </div>
                `;
            }
        }

        // åˆ‡æ› RISU è®Šæ•¸åˆ†çµ„çš„å±•é–‹/æ”¶åˆç‹€æ…‹
        function toggleRisuVarGroup(groupName) {
            expandedRisuGroups[groupName] = expandedRisuGroups[groupName] === false ? true : false;
            renderRisuVars();
        }

        // ç”Ÿæˆä¸Šå‚³åœ–ç‰‡çš„é¸é … HTML
        function getUploadedImageOptions(currentValue) {
            const customKeys = Object.keys(risuTestImages).filter(k => k.startsWith('custom_'));
            if (customKeys.length === 0) return '';

            return customKeys.map(k => {
                const info = risuTestImages[k];
                const displayName = info.displayName || 'ğŸ“· è‡ªè¨‚åœ–ç‰‡';
                return `<option value="${k}" ${currentValue === k ? 'selected' : ''}>${displayName}</option>`;
            }).join('');
        }

        // æ›´æ–°ä¸Šå‚³åœ–ç‰‡è¨ˆæ•¸é¡¯ç¤º
        function updateUploadedImageCount() {
            const count = Object.keys(risuTestImages).filter(k => k.startsWith('custom_')).length;
            const span = document.getElementById('uploadedImageCount');
            if (span) {
                span.textContent = count > 0 ? `(${count} å¼µ)` : '';
            }
        }

        // [å·²ä¿®æ”¹] æ¸…ç©ºç•¶å‰è®Šæ•¸çµ„çš„ RISU æ¨¡æ“¬è®Šæ•¸
        function clearRisuVars() {
            const groupKey = getVarGroupKey(activeEditorTab);
            const groupName = groupKey === 'simple' ? 'ç°¡æ˜“æ¨¡å¼' : 'Regex æ¨¡å¼';
            const tabVars = tabVariables[groupKey].risuVars;
            if (Object.keys(tabVars).length === 0) {
                alert(`ç•¶å‰${groupName}æ²’æœ‰æ¨¡æ“¬è®Šæ•¸å¯ä¾›æ¸…ç©º`);
                return;
            }
            if (confirm(`ç¢ºå®šè¦æ¸…ç©º${groupName}çš„æ‰€æœ‰æ¨¡æ“¬è®Šæ•¸å—ï¼Ÿ`)) {
                tabVariables[groupKey].risuVars = {};
                syncTabVariables();
                render();
                document.getElementById('risuVarSearchInput').value = '';
                console.log(`ğŸ—‘ï¸ å·²æ¸…ç©º${groupName}çš„æ‰€æœ‰æ¨¡æ“¬è®Šæ•¸`);
            }
        }

        // éæ¿¾ RISU è®Šæ•¸åˆ—è¡¨ï¼ˆä¾æœå°‹é—œéµå­—ï¼‰
        function filterRisuVariables(keyword) {
            const container = document.getElementById('risuVarsContainer');
            const items = container.querySelectorAll('.flex.items-center.gap-2');
            const lowerKeyword = keyword.toLowerCase().trim();

            items.forEach(item => {
                const nameSpan = item.querySelector('span[title]');
                if (nameSpan) {
                    const varName = nameSpan.getAttribute('title').toLowerCase();
                    item.style.display = lowerKeyword === '' || varName.includes(lowerKeyword) ? '' : 'none';
                }
            });
        }

        // éæ¿¾è®Šæ•¸æ§åˆ¶å°ï¼ˆä¾æœå°‹é—œéµå­—ï¼‰
        function filterVariables(keyword) {
            const container = document.getElementById('variablesContainer');
            // è®Šæ•¸æ§åˆ¶å°ä½¿ç”¨åˆ†çµ„çµæ§‹
            const groups = container.querySelectorAll('.var-group-container, .flex.items-center');
            const lowerKeyword = keyword.toLowerCase().trim();

            groups.forEach(group => {
                // å°æ¯å€‹åˆ†çµ„å…§çš„é …ç›®æˆ–å–®ç¨é …ç›®é€²è¡Œç¯©é¸
                const items = group.querySelectorAll ? group.querySelectorAll('.flex.items-center.gap-2') : [group];
                let hasVisibleItem = false;

                items.forEach(item => {
                    const input = item.querySelector('input[type="text"], input[type="color"], input[type="range"]');
                    if (input && input.id) {
                        const varName = input.id.toLowerCase();
                        const isMatch = lowerKeyword === '' || varName.includes(lowerKeyword);
                        item.style.display = isMatch ? '' : 'none';
                        if (isMatch) hasVisibleItem = true;
                    }
                });

                // å¦‚æœæ˜¯åˆ†çµ„å®¹å™¨ï¼Œæ ¹æ“šæ˜¯å¦æœ‰å¯è¦‹é …ç›®ä¾†æ±ºå®šé¡¯ç¤º
                if (group.classList.contains('var-group-container')) {
                    group.style.display = hasVisibleItem ? '' : 'none';
                }
            });
        }

        // [å·²ä¿®æ”¹] æ›´æ–° RISU è®Šæ•¸å€¼ï¼ˆåŒæ™‚æ›´æ–° tabVariables å’Œ risuSimVarsï¼‰
        function updateRisuVar(name, value) {
            // æ›´æ–°ç•¶å‰è®Šæ•¸çµ„çš„è®Šæ•¸
            const groupKey = getVarGroupKey(activeEditorTab);
            const tabVars = tabVariables[groupKey].risuVars;
            if (tabVars[name]) {
                tabVars[name].value = value;
                tabVars[name].autoNamed = false;
            }
            // åŒæ™‚æ›´æ–°å…±ç”¨è®Šæ•¸ï¼ˆç”¨æ–¼æ¸²æŸ“ï¼‰
            if (risuSimVars[name]) {
                risuSimVars[name].value = value;
                risuSimVars[name].autoNamed = false;
            }
            render();
        }

        // [å·²ä¿®æ”¹] ç§»é™¤ RISU è®Šæ•¸ï¼ˆåŒæ™‚å¾ tabVariables å’Œ risuSimVars ç§»é™¤ï¼‰
        function removeRisuVar(name) {
            // å¾ç•¶å‰è®Šæ•¸çµ„çš„è®Šæ•¸ä¸­ç§»é™¤
            const groupKey = getVarGroupKey(activeEditorTab);
            delete tabVariables[groupKey].risuVars[name];
            // åŒæ™‚å¾å…±ç”¨è®Šæ•¸ç§»é™¤
            delete risuSimVars[name];
            renderRisuVars();
            render();
        }

        // æ‰“é–‹æ‰‹å‹•æ·»åŠ è®Šæ•¸ Modal
        function openRisuVarModal() {
            document.getElementById('risuVarModal').classList.remove('hidden');
            document.getElementById('risuVarName').value = '';
            document.getElementById('risuVarValue').value = '';
            document.getElementById('risuVarType').value = 'string';
            toggleRisuVarValueInput();
            document.getElementById('risuVarName').focus();
        }

        // é—œé–‰æ‰‹å‹•æ·»åŠ è®Šæ•¸ Modal
        function closeRisuVarModal() {
            document.getElementById('risuVarModal').classList.add('hidden');
        }

        // åˆ‡æ›è®Šæ•¸å€¼è¼¸å…¥æ¬„ä½ï¼ˆæ ¹æ“šé¡å‹é¡¯ç¤ºä¸åŒè¼¸å…¥ï¼‰
        function toggleRisuVarValueInput() {
            const type = document.getElementById('risuVarType').value;
            const valueContainer = document.getElementById('risuVarValueContainer');
            const assetContainer = document.getElementById('risuVarAssetContainer');
            const assetSelect = document.getElementById('risuVarAssetValue');
            
            if (type === 'asset') {
                valueContainer.classList.add('hidden');
                assetContainer.classList.remove('hidden');
                
                // å‹•æ…‹å¡«å……å·²ä¸Šå‚³çš„åœ–ç‰‡é¸é …
                const existingOptions = assetSelect.querySelectorAll('option[value^="custom_"]');
                existingOptions.forEach(opt => opt.remove());
                
                Object.keys(risuTestImages).forEach(key => {
                    const img = risuTestImages[key];
                    const name = img.name || key;
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = `ğŸ–¼ï¸ ${name}`;
                    assetSelect.appendChild(option);
                });
            } else {
                valueContainer.classList.remove('hidden');
                assetContainer.classList.add('hidden');
            }
        }

        // æ‰‹å‹•æ·»åŠ  RISU è®Šæ•¸ï¼ˆå„²å­˜åˆ°ç•¶å‰ Tabï¼‰
        function addRisuSimVar() {
            const name = document.getElementById('risuVarName').value.trim();
            const type = document.getElementById('risuVarType').value;
            
            let value;
            if (type === 'asset') {
                value = document.getElementById('risuVarAssetValue').value;
            } else {
                value = document.getElementById('risuVarValue').value.trim() || 'é è¨­å€¼';
            }

            if (!name) {
                alert('è«‹è¼¸å…¥è®Šæ•¸åç¨±ï¼');
                return;
            }

            // å„²å­˜åˆ°ç•¶å‰è®Šæ•¸çµ„çš„è®Šæ•¸
            const groupKey = getVarGroupKey(activeEditorTab);
            tabVariables[groupKey].risuVars[name] = { value: value, type: type, autoNamed: false };
            closeRisuVarModal();
            syncTabVariables();
            render();
        }

        // è™•ç† RISU CBS èªæ³•ï¼ˆåœ¨é è¦½å‰èª¿ç”¨ï¼‰
        function processRisuContent(content) {
            if (!content.includes('{{')) {
                return content;
            }

            let result = content;
            let iterations = 0;
            const maxIterations = 100;

            // å¤šæ¬¡è¿­ä»£è™•ç†ï¼Œç¢ºä¿å·¢ç‹€èªæ³•å¾å…§åˆ°å¤–è™•ç†
            while (iterations++ < maxIterations && result.includes('{{')) {
                const before = result;

                // 1. æ›¿æ› {{getvar::NAME}} å’Œ {{gettempvar::NAME}}
                result = result.replace(/\{\{(?:getvar|gettempvar)::([^{}]+)\}\}/gi, (match, name) => {
                    const trimmedName = name.trim();
                    if (risuSimVars[trimmedName]) {
                        return risuSimVars[trimmedName].value;
                    }
                    // æœªå®šç¾©çš„è®Šæ•¸è¿”å› '0'ï¼Œé€™æ¨£ {{#if_pure {{? ({{getvar::xxx}} == 0) }}}} å¯ä»¥æ­£å¸¸é‹ä½œ
                    return '0';
                });

                // 1.5 è™•ç†å¸¸ç”¨ç‰¹æ®Šè®Šæ•¸ï¼ˆä¸å¸¶é›™å†’è™Ÿï¼‰
                // å„ªå…ˆä½¿ç”¨ç”¨æˆ¶åœ¨ risuSimVars ä¸­è‡ªè¨‚çš„å€¼ï¼Œå¦å‰‡ä½¿ç”¨é è¨­å€¼
                const getSystemVar = (name, defaultVal) => {
                    return risuSimVars[name] ? risuSimVars[name].value : defaultVal;
                };

                // è¨Šæ¯ç´¢å¼•ç›¸é—œï¼ˆæ•¸å­—å‹ï¼Œç”¨æ–¼æ¢ä»¶åˆ¤æ–·ï¼‰
                result = result.replace(/\{\{chat_index\}\}/gi, getSystemVar('chat_index', '10'));
                result = result.replace(/\{\{chatindex\}\}/gi, getSystemVar('chat_index', '10'));
                result = result.replace(/\{\{lastmessageid\}\}/gi, getSystemVar('lastmessageid', '10'));
                result = result.replace(/\{\{lastmessageindex\}\}/gi, getSystemVar('lastmessageid', '10'));

                // è§’è‰²ç›¸é—œ
                result = result.replace(/\{\{user\}\}/gi, getSystemVar('user', 'User'));
                result = result.replace(/\{\{char\}\}/gi, getSystemVar('char', 'Character'));
                result = result.replace(/\{\{charname\}\}/gi, getSystemVar('char', 'Character'));
                result = result.replace(/\{\{username\}\}/gi, getSystemVar('user', 'User'));

                // è¨Šæ¯å…§å®¹ç›¸é—œ
                result = result.replace(/\{\{lastmessage\}\}/gi, getSystemVar('lastmessage', '(Last message)'));
                result = result.replace(/\{\{role\}\}/gi, getSystemVar('role', 'assistant'));
                result = result.replace(/\{\{messagetime\}\}/gi, getSystemVar('messagetime', ''));

                // å…¶ä»–å¸¸è¦‹è®Šæ•¸
                result = result.replace(/\{\{idle_duration\}\}/gi, getSystemVar('idle_duration', '0'));
                result = result.replace(/\{\{maxcontext\}\}/gi, getSystemVar('maxcontext', '8000'));

                // 2. æ›¿æ›åœ–ç‰‡è³‡ç”¢è®Šæ•¸ï¼ˆæ”¯æ´ 5 ç¨®é¡å‹ï¼‰
                // {{image::A}} - ä»¥åœ–åƒå…ƒç´ é¡¯ç¤º
                // {{img::A}} - ä»¥æœªæ¨£å¼åœ–åƒå…ƒç´ é¡¯ç¤º
                // {{raw::A}} / {{path::A}} - è¿”å›è·¯å¾‘è³‡æ–™
                // {{bg::A}} - ä»¥èƒŒæ™¯åœ–åƒå…ƒç´ é¡¯ç¤º
                result = result.replace(/\{\{(image|img|raw|path|bg)::([^{}]+)\}\}/gi, (match, type, assetName) => {
                    const name = assetName.trim();
                    const placeholderUrl = getAssetPlaceholder(name, type);

                    if (type === 'image' || type === 'img') {
                        // è¿”å› <img> æ¨™ç±¤
                        const shortName = name.length > 20 ? name.substring(0, 20) + '..' : name;
                        return `<img src="${placeholderUrl}" alt="${shortName}" style="max-width:100%;">`;
                    } else if (type === 'bg') {
                        // è¿”å› CSS url()
                        return `url('${placeholderUrl}')`;
                    } else {
                        // raw, path - è¿”å›ç´”è·¯å¾‘
                        return placeholderUrl;
                    }
                });

                // 3. è™•ç† CBS å‡½æ•¸
                // {{equal::A::B}} - ç›¸ç­‰æ¯”è¼ƒ
                result = result.replace(/\{\{equal::([^:{}]+)::([^{}]+)\}\}/gi, (m, a, b) => {
                    return a.trim() === b.trim() ? '1' : '0';
                });

                // {{not_equal::A::B}} - ä¸ç›¸ç­‰æ¯”è¼ƒ
                result = result.replace(/\{\{not_equal::([^:{}]+)::([^{}]+)\}\}/gi, (m, a, b) => {
                    return a.trim() !== b.trim() ? '1' : '0';
                });

                // {{greater::A::B}} - å¤§æ–¼
                result = result.replace(/\{\{greater::([^:{}]+)::([^{}]+)\}\}/gi, (m, a, b) => {
                    return parseFloat(a) > parseFloat(b) ? '1' : '0';
                });

                // {{greater_equal::A::B}} - å¤§æ–¼ç­‰æ–¼
                result = result.replace(/\{\{greater_equal::([^:{}]+)::([^{}]+)\}\}/gi, (m, a, b) => {
                    return parseFloat(a) >= parseFloat(b) ? '1' : '0';
                });

                // {{less::A::B}} - å°æ–¼
                result = result.replace(/\{\{less::([^:{}]+)::([^{}]+)\}\}/gi, (m, a, b) => {
                    return parseFloat(a) < parseFloat(b) ? '1' : '0';
                });

                // {{less_equal::A::B}} - å°æ–¼ç­‰æ–¼
                result = result.replace(/\{\{less_equal::([^:{}]+)::([^{}]+)\}\}/gi, (m, a, b) => {
                    return parseFloat(a) <= parseFloat(b) ? '1' : '0';
                });

                // {{and::A::B}} - é‚è¼¯ AND
                result = result.replace(/\{\{and::([^:{}]+)::([^{}]+)\}\}/gi, (m, a, b) => {
                    return (a.trim() === '1' && b.trim() === '1') ? '1' : '0';
                });

                // {{or::A::B}} - é‚è¼¯ OR
                result = result.replace(/\{\{or::([^:{}]+)::([^{}]+)\}\}/gi, (m, a, b) => {
                    return (a.trim() === '1' || b.trim() === '1') ? '1' : '0';
                });

                // {{not::A}} - é‚è¼¯ NOT
                result = result.replace(/\{\{not::([^{}]+)\}\}/gi, (m, a) => {
                    return a.trim() === '1' ? '0' : '1';
                });

                // {{trim::A}} - å»é™¤ç©ºç™½
                result = result.replace(/\{\{trim::([^{}]*)\}\}/gi, (m, a) => a.trim());

                // {{? EXPR}} - è¨ˆç®—è¡¨é”å¼ (ç°¡åŒ–è™•ç†)
                result = result.replace(/\{\{\?\s*([^{}]+)\}\}/gi, (m, expr) => {
                    return evaluateSimpleExpression(expr) ? '1' : '0';
                });

                // 4. è™•ç† {{#if CONDITION}}...{{/if}} å€å¡Š
                // ä½¿ç”¨ã€Œæœ€å…§å±¤å„ªå…ˆã€ç­–ç•¥ï¼šåªåŒ¹é…ä¸åŒ…å«å·¢ç‹€ #if çš„å€å¡Š
                // é€™æ¨£å¯ä»¥æ­£ç¢ºè™•ç†å·¢ç‹€ IFï¼Œå¾å…§åˆ°å¤–é€å±¤è§£æ
                result = result.replace(/\{\{#if\s+([^{}]+)\}\}((?:(?!\{\{#if)[\s\S])*?)\{\{\/if\}\}/gi, (match, cond, body) => {
                    const condValue = cond.trim();
                    // æ¢ä»¶ç‚º "1" æˆ– "true" æ™‚é¡¯ç¤ºå…§å®¹
                    if (condValue === '1' || condValue === 'true') {
                        return body;
                    }
                    return '';
                });

                // è™•ç† {{#if_pure ...}}...{{/if}} - æ”¯æ´å·¢ç‹€ {{? EXPR}} æˆ–ç›´æ¥æ¢ä»¶
                // æ­£å‰‡æ”¹é€²ï¼šå…è¨±æ¢ä»¶ä¸­åŒ…å« {{? ...}} èªæ³•
                result = result.replace(/\{\{#if_pure\s+((?:\{\{\?[\s\S]+?\}\})|[^{}]+)\}\}((?:(?!\{\{#if)[\s\S])*?)\{\{\/if(?:_pure)?\}\}/gi, (match, cond, body) => {
                    let expression = cond.trim();
                    // å¦‚æœæ¢ä»¶ä¸­é‚„æœ‰ {{? ... }}ï¼Œæå–è£¡é¢çš„å…§å®¹
                    const innerMatch = expression.match(/\{\{\?\s*([\s\S]+?)\s*\}\}/);
                    if (innerMatch) {
                        expression = innerMatch[1];
                    }
                    const conditionMet = evaluateSimpleExpression(expression);
                    return conditionMet ? body : '';
                });

                // å¦‚æœæ²’æœ‰ä»»ä½•æ›¿æ›ç™¼ç”Ÿï¼Œåœæ­¢è¿­ä»£
                if (result === before) break;
            }

            // 5. æœ€å¾Œæ¸…ç†ï¼šç§»é™¤æ‰€æœ‰æœªè™•ç†çš„ CBS èªæ³•
            // ä½¿ç”¨æ›´æ™ºèƒ½çš„æ–¹å¼è™•ç†å·¢ç‹€æ‹¬è™Ÿ
            result = cleanRemainingSyntax(result);

            return result;
        }

        // æ¸…ç†å‰©é¤˜çš„ CBS èªæ³•
        function cleanRemainingSyntax(content) {
            let result = content;
            let iterations = 0;

            // åè¦†æ¸…ç†ç›´åˆ°æ²’æœ‰å¯æ¸…ç†çš„ CBS èªæ³•
            while (iterations++ < 50 && result.includes('{{')) {
                const before = result;

                // æ¸…ç†æœªè™•ç†çš„ {{trim::...}} - åªä¿ç•™å…§å®¹
                result = result.replace(/\{\{trim::([^{}]*)\}\}/gi, (m, a) => a ? a.trim() : '');

                // åªæ¸…ç†å·²çŸ¥çš„ CBS èªæ³•çµæ§‹ï¼Œä¿ç•™ $n æ¨¡æ¿è®Šæ•¸
                // æ¸…ç†æœ€å…§å±¤çš„æœªè™•ç† {{#if...}}...{{/if}} å€å¡Šï¼ˆéè²ªå©ªåŒ¹é…ï¼‰
                result = result.replace(/\{\{#if(?:_pure)?(?:(?!\{\{#if).)*?\{\{\/if(?:_pure)?\}\}/gi, '');

                // æ¸…ç†æœªè™•ç†çš„è®Šæ•¸è®€å–
                result = result.replace(/\{\{(?:getvar|gettempvar)::[^{}]*\}\}/gi, '');

                // æ¸…ç†æœªè™•ç†çš„åœ–ç‰‡/è³‡ç”¢èªæ³•
                result = result.replace(/\{\{(?:image|img|raw|path|bg|emotion|asset|audio|video)::[^{}]*\}\}/gi, '');

                // æ¸…ç†æœªè™•ç†çš„æ¯”è¼ƒå‡½æ•¸
                result = result.replace(/\{\{(?:equal|not_equal|greater|greater_equal|less|less_equal|and|or|not)::[^{}]*\}\}/gi, '');

                // æ¸…ç†è¨ˆç®—è¡¨é”å¼
                result = result.replace(/\{\{\?\s*[^{}]*\}\}/gi, '');

                // æ¸…ç†å…¶ä»–å¸¸è¦‹èªæ³•
                result = result.replace(/\{\{(?:br|newline|cbr|cnl)\}\}/gi, '<br>');

                if (result === before) {
                    // æ²’æœ‰æ›´å¤šå¯æ¸…ç†çš„å·²çŸ¥èªæ³•
                    break;
                }
            }

            return result;
        }

        // è©•ä¼°ç°¡å–®è¡¨é”å¼
        function evaluateSimpleExpression(expr) {
            // æ¸…ç†è¡¨é”å¼
            const cleanExpr = expr.trim();

            // è™•ç†é‚è¼¯ OR: A || B
            if (cleanExpr.includes('||')) {
                const parts = cleanExpr.split('||').map(p => p.trim());
                return parts.some(p => evaluateSimpleExpression(p));
            }

            // è™•ç†é‚è¼¯ AND: A && B æˆ– A & B
            if (cleanExpr.includes('&&') || cleanExpr.includes('&')) {
                const parts = cleanExpr.split(/&&|&/).map(p => p.trim());
                return parts.every(p => evaluateSimpleExpression(p));
            }

            // è™•ç†æ‹¬è™Ÿè¡¨é”å¼: (expr)
            const parenMatch = cleanExpr.match(/^\((.+)\)$/);
            if (parenMatch) {
                return evaluateSimpleExpression(parenMatch[1]);
            }

            // è™•ç†ç°¡å–®æ¯”è¼ƒ: A=B, A==B, A!=B, A>B, A<B, A>=B, A<=B
            const compMatch = cleanExpr.match(/([^=!<>]*)\s*(==?|!=|<=?|>=?)\s*(.*)/);
            if (compMatch) {
                let left = compMatch[1].trim();
                const op = compMatch[2];
                let right = compMatch[3].trim();

                // ç©ºå€¼è¦–ç‚º 0 æˆ–ç©ºå­—ä¸²
                if (left === '') left = '0';
                if (right === '') right = '0';

                // å˜—è©¦è½‰æ›ç‚ºæ•¸å­—é€²è¡Œæ¯”è¼ƒ
                const leftNum = parseFloat(left);
                const rightNum = parseFloat(right);
                const isNumeric = !isNaN(leftNum) && !isNaN(rightNum);

                switch (op) {
                    case '=':
                    case '==': return isNumeric ? leftNum === rightNum : left === right;
                    case '!=': return isNumeric ? leftNum !== rightNum : left !== right;
                    case '<': return leftNum < rightNum;
                    case '>': return leftNum > rightNum;
                    case '<=': return leftNum <= rightNum;
                    case '>=': return leftNum >= rightNum;
                }
            }

            // è™•ç†å–®ä¸€å€¼: "1" æˆ– "true" è¦–ç‚º trueï¼Œ"0" æˆ–ç©ºå€¼è¦–ç‚º false
            return cleanExpr === '1' || cleanExpr === 'true';
        }

        // è¼”åŠ©å‡½æ•¸ï¼šæ¸²æŸ“é¸æ“‡å™¨åˆ†çµ„ HTML
        function renderSelectorGroups(selectorGroups, parentId) {
            let html = '';
            Object.entries(selectorGroups).forEach(([selector, vars]) => {
                const selectorKey = `${parentId}_${selector}`;
                const isExpanded = expandedSelectors[selectorKey] === true;
                const hasNewVar = vars.some(v => v.isNew);
                const isMedia = selector === '@media';

                html += `
                <div class="var-group ml-2" data-selector="${selectorKey}">
                    <div class="var-group-header flex items-center justify-between cursor-pointer px-2 py-1 rounded ${isExpanded ? 'bg-[#313244]' : 'bg-[#1e1e2e] hover:bg-[#252537]'} transition" onclick="toggleVarGroup('${selectorKey}')">
                        <div class="flex items-center gap-2">
                            <i class="fas fa-chevron-${isExpanded ? 'down' : 'right'} text-[9px] text-[#6c7086] w-3"></i>
                            <span class="text-[11px] font-mono ${isMedia ? 'text-yellow-400' : 'text-[#89b4fa]'} ${hasNewVar ? 'font-bold' : ''}">${isMedia ? 'ğŸ“± ' : '.'}${selector.replace(/^\./, '')}</span>
                        </div>
                        <span class="text-[10px] ${isExpanded ? 'text-[#a6adc8]' : 'text-[#6c7086]'}">${vars.length}</span>
                    </div>
                    <div class="var-group-content ${isExpanded ? '' : 'hidden'} pl-3 border-l-2 ${isMedia ? 'border-yellow-500/30' : 'border-[#89b4fa]/30'} ml-2 mt-1 space-y-1">
                        ${vars.map(v => `
                            <div class="var-control-item group ${v.isNew ? 'newly-added' : ''}" data-var-id="${v.id}">
                                <div class="var-header">
                                    <span class="var-name text-[11px]" onclick="copyText('${v.name}')" title="${v.name}">
                                        ${v.name.replace('--', '').replace(selector.replace(/^\./, '') + '-', '')}
                                    </span>
                                    <div class="flex gap-1 items-center">
                                        ${v.isMediaQuery ? '' : `<button onclick="locateVariable('${v.name}')" class="text-[#a6adc8] hover:text-white hover:bg-[#45475a] p-1 rounded transition" title="åœ¨ CSS ä¸­å®šä½"><i class="fas fa-search text-[10px]"></i></button>`}
                                        <button onclick="removeVariable('${v.id}')" class="text-[#6c7086] hover:text-red-400 p-1 rounded transition"><i class="fas fa-trash text-[10px]"></i></button>
                                    </div>
                                </div>
                                ${renderInput(v)}
                            </div>
                        `).join('')}
                    </div>
                </div>`;
            });
            return html;
        }

        function renderVarControls() {
            const container = document.getElementById('variablesContainer');
            const msg = document.getElementById('noVarsMsg');

            if (customVars.length === 0) {
                container.innerHTML = '';
                if (msg) msg.style.display = 'block';
                return;
            }
            if (msg) msg.style.display = 'none';

            // æª¢æŸ¥ä¾†æºè³‡è¨Šé¡å‹
            const hasCssPageInfo = customVars.some(v => v.cssPageId && v.cssPageName);
            const hasRuleInfo = customVars.some(v => v.ruleId && v.ruleName);

            let html = '';

            if (hasCssPageInfo) {
                // ====== ç°¡æ˜“æ¨¡å¼ï¼šCSS åˆ†é  â†’ é¸æ“‡å™¨ ======
                const cssPageGroups = {};
                customVars.forEach(v => {
                    const pageKey = v.cssPageId || 'unknown';
                    const pageName = v.cssPageName || 'æœªçŸ¥åˆ†é ';
                    if (!cssPageGroups[pageKey]) {
                        cssPageGroups[pageKey] = { name: pageName, vars: [] };
                    }
                    cssPageGroups[pageKey].vars.push(v);
                });

                Object.entries(cssPageGroups).forEach(([pageId, pageData]) => {
                    const pageKey = `cssPage_${pageId}`;
                    const isPageExpanded = expandedSelectors[pageKey] !== false;
                    const pageVarCount = pageData.vars.length;

                    const selectorGroups = {};
                    pageData.vars.forEach(v => {
                        const sel = v.selector || 'global';
                        if (!selectorGroups[sel]) selectorGroups[sel] = [];
                        selectorGroups[sel].push(v);
                    });

                    html += `
                    <div class="var-css-page-group mb-3" data-css-page="${pageId}">
                        <div class="flex items-center justify-between cursor-pointer px-2 py-1.5 rounded ${isPageExpanded ? 'bg-[#2d3548]' : 'bg-[#1e1e2e] hover:bg-[#252537]'} transition border-l-4 border-[#f9e2af]" onclick="toggleVarGroup('${pageKey}')">
                            <div class="flex items-center gap-2">
                                <i class="fas fa-chevron-${isPageExpanded ? 'down' : 'right'} text-[10px] text-[#f9e2af] w-3"></i>
                                <span class="text-xs font-bold text-[#f9e2af]">ğŸ“„ ${pageData.name}</span>
                            </div>
                            <span class="text-[10px] text-[#6c7086]">${pageVarCount} è®Šæ•¸</span>
                        </div>
                        <div class="var-css-page-content ${isPageExpanded ? '' : 'hidden'} ml-2 mt-1 space-y-1">`;

                    html += renderSelectorGroups(selectorGroups, pageId);
                    html += `</div></div>`;
                });
            } else if (hasRuleInfo) {
                // ====== Regex æ¨¡å¼ï¼šè¦å‰‡åç¨± â†’ é¸æ“‡å™¨ ======
                const ruleGroups = {};
                customVars.forEach(v => {
                    const ruleKey = v.ruleId || 'unknown';
                    const ruleName = v.ruleName || 'æœªçŸ¥è¦å‰‡';
                    if (!ruleGroups[ruleKey]) {
                        ruleGroups[ruleKey] = { name: ruleName, vars: [] };
                    }
                    ruleGroups[ruleKey].vars.push(v);
                });

                Object.entries(ruleGroups).forEach(([ruleId, ruleData]) => {
                    const ruleKey = `rule_${ruleId}`;
                    const isRuleExpanded = expandedSelectors[ruleKey] !== false;
                    const ruleVarCount = ruleData.vars.length;

                    const selectorGroups = {};
                    ruleData.vars.forEach(v => {
                        const sel = v.selector || 'global';
                        if (!selectorGroups[sel]) selectorGroups[sel] = [];
                        selectorGroups[sel].push(v);
                    });

                    html += `
                    <div class="var-rule-group mb-3" data-rule="${ruleId}">
                        <div class="flex items-center justify-between cursor-pointer px-2 py-1.5 rounded ${isRuleExpanded ? 'bg-[#2d4535]' : 'bg-[#1e1e2e] hover:bg-[#252537]'} transition border-l-4 border-[#a6e3a1]" onclick="toggleVarGroup('${ruleKey}')">
                            <div class="flex items-center gap-2">
                                <i class="fas fa-chevron-${isRuleExpanded ? 'down' : 'right'} text-[10px] text-[#a6e3a1] w-3"></i>
                                <span class="text-xs font-bold text-[#a6e3a1]">ğŸ“ ${ruleData.name}</span>
                            </div>
                            <span class="text-[10px] text-[#6c7086]">${ruleVarCount} è®Šæ•¸</span>
                        </div>
                        <div class="var-rule-content ${isRuleExpanded ? '' : 'hidden'} ml-2 mt-1 space-y-1">`;

                    html += renderSelectorGroups(selectorGroups, ruleId);
                    html += `</div></div>`;
                });
            } else {
                // ====== èˆŠæ¨¡å¼ï¼ˆç„¡ CSS åˆ†é è³‡è¨Šï¼‰ï¼šåªæŒ‰é¸æ“‡å™¨åˆ†çµ„ ======
                const groups = {};
                customVars.forEach(v => {
                    const sel = v.selector || 'global';
                    if (!groups[sel]) groups[sel] = [];
                    groups[sel].push(v);
                });

                Object.entries(groups).forEach(([selector, vars]) => {
                    const isExpanded = expandedSelectors[selector] === true;
                    const hasNewVar = vars.some(v => v.isNew);
                    const isMedia = selector === '@media';

                    html += `
                    <div class="var-group mb-2" data-selector="${selector}">
                        <div class="var-group-header flex items-center justify-between cursor-pointer px-2 py-1.5 rounded ${isExpanded ? 'bg-[#313244]' : 'bg-[#1e1e2e] hover:bg-[#252537]'} transition" onclick="toggleVarGroup('${selector}')">
                            <div class="flex items-center gap-2">
                                <i class="fas fa-chevron-${isExpanded ? 'down' : 'right'} text-[10px] text-[#6c7086] w-3"></i>
                                <span class="text-xs font-mono ${isMedia ? 'text-yellow-400' : 'text-[#89b4fa]'} ${hasNewVar ? 'font-bold' : ''}">${isMedia ? 'ğŸ“± ' : '.'}${selector.replace(/^\./, '')}</span>
                            </div>
                            <span class="text-[10px] ${isExpanded ? 'text-[#a6adc8]' : 'text-[#6c7086]'}">${vars.length}</span>
                        </div>
                        <div class="var-group-content ${isExpanded ? '' : 'hidden'} pl-4 border-l-2 ${isMedia ? 'border-yellow-500/30' : 'border-[#89b4fa]/30'} ml-2 mt-1 space-y-1">
                            ${vars.map(v => `
                                <div class="var-control-item group ${v.isNew ? 'newly-added' : ''}" data-var-id="${v.id}">
                                    <div class="var-header">
                                        <span class="var-name text-[11px]" onclick="copyText('${v.name}')" title="${v.name}">
                                            ${v.name.replace('--', '').replace(selector.replace(/^\./, '') + '-', '')}
                                        </span>
                                        <div class="flex gap-1 items-center">
                                            ${v.isMediaQuery ? '' : `<button onclick="locateVariable('${v.name}')" class="text-[#a6adc8] hover:text-white hover:bg-[#45475a] p-1 rounded transition" title="åœ¨ CSS ä¸­å®šä½"><i class="fas fa-search text-[10px]"></i></button>`}
                                            <button onclick="removeVariable('${v.id}')" class="text-[#6c7086] hover:text-red-400 p-1 rounded transition"><i class="fas fa-trash text-[10px]"></i></button>
                                        </div>
                                    </div>
                                    ${renderInput(v)}
                                </div>
                            `).join('')}
                        </div>
                    </div>`;
                });
            }

            container.innerHTML = html;

            // ç¶å®šäº‹ä»¶
            customVars.forEach(v => {
                const el = document.getElementById(`input-${v.id}`);
                if (el) {
                    // æ»‘æ¡¿é–‹å§‹æ‹–å‹•æ™‚å„²å­˜å¿«ç…§ï¼ˆåªåœ¨ mousedown æ™‚å„²å­˜ä¸€æ¬¡ï¼‰
                    el.addEventListener('mousedown', () => {
                        saveVariableSnapshot();
                    });
                    el.addEventListener('input', (e) => {
                        v.value = e.target.value;
                        if (v.type === 'color') {
                            const textInput = el.nextElementSibling;
                            if (textInput) textInput.value = e.target.value;
                        } else if (v.type === 'range') {
                            // å³æ™‚æ›´æ–°å³å´æ•¸å€¼é¡¯ç¤º
                            const valueDisplay = document.getElementById(`value-${v.id}`);
                            if (valueDisplay) valueDisplay.value = v.value;
                        }
                        render();
                    });
                }

                // ç‚ºæ•¸å€¼è¼¸å…¥æ¡†ç¶å®šäº‹ä»¶
                const valueInput = document.getElementById(`value-${v.id}`);
                if (valueInput) {
                    // è¼¸å…¥æ¡†ç²å¾—ç„¦é»æ™‚å„²å­˜å¿«ç…§
                    valueInput.addEventListener('focus', () => {
                        saveVariableSnapshot();
                    });
                    valueInput.addEventListener('change', (e) => {
                        const newVal = parseFloat(e.target.value);
                        if (!isNaN(newVal)) {
                            v.value = newVal;
                            const rangeInput = document.getElementById(`input-${v.id}`);
                            if (rangeInput) rangeInput.value = newVal;
                            render();
                        }
                    });
                    valueInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') e.target.blur();
                    });
                }
            });
            setTimeout(() => { customVars.forEach(v => v.isNew = false); }, 1000);
        }

        // åˆ‡æ›åˆ†çµ„å±•é–‹/æ”¶åˆ
        function toggleVarGroup(selector) {
            expandedSelectors[selector] = !expandedSelectors[selector];
            renderVarControls();
        }

        // å±•é–‹æŒ‡å®šé¸æ“‡å™¨çš„åˆ†çµ„ï¼ˆä¾›å¤–éƒ¨å‘¼å«ï¼‰
        function expandVarGroup(selector) {
            // å˜—è©¦ç²¾ç¢ºåŒ¹é…æˆ–éƒ¨åˆ†åŒ¹é…
            const groups = Object.keys(customVars.reduce((acc, v) => {
                acc[v.selector || 'global'] = true;
                return acc;
            }, {}));

            let targetSelector = groups.find(g => g === selector);
            if (!targetSelector) {
                // éƒ¨åˆ†åŒ¹é…ï¼ˆå»é™¤å‰å°é»ï¼‰
                const cleanSel = selector.replace(/^\./, '');
                targetSelector = groups.find(g => g.includes(cleanSel) || cleanSel.includes(g.replace(/^\./, '')));
            }

            if (targetSelector && !expandedSelectors[targetSelector]) {
                expandedSelectors[targetSelector] = true;
                renderVarControls();

                // æ»¾å‹•åˆ°è©²åˆ†çµ„
                setTimeout(() => {
                    const groupEl = document.querySelector(`[data-selector="${targetSelector}"]`);
                    if (groupEl) {
                        groupEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }, 50);
            }
        }

        function renderInput(v) {
            if (v.type === 'color') {
                return `<div class="flex gap-2 items-center">
                            <input type="color" id="input-${v.id}" value="${v.value}" class="w-8 h-6 p-0 border-0 bg-transparent cursor-pointer rounded">
                            <input type="text" value="${v.value}" onchange="updateVarValue('${v.id}', this.value)" class="flex-1 bg-[#11111b] text-xs text-[#a6adc8] border border-[#313244] rounded px-1 font-mono">
                        </div>`;
            } else if (v.type === 'range') {
                let val = parseFloat(v.value) || 0;
                let min = val < 0 ? val * 3 : 0;
                let max = val === 0 ? 100 : val * 2;
                if (val < 0) { max = Math.abs(val); }
                if (v.unit === 'deg') { min = -360; max = 360; }
                if (v.unit === '%') { min = 0; max = 100; }
                if (v.unit === 'px' && Math.abs(val) < 20) { min = -20; max = 20; }

                return `<div class="flex gap-2 items-center">
                            <input type="range" id="input-${v.id}" min="${min}" max="${max}" step="0.1" value="${val}" class="flex-1 h-1 bg-[#313244] rounded-lg appearance-none cursor-pointer">
                            <input type="number" id="value-${v.id}" value="${val}" step="0.1" 
                                class="w-14 text-[10px] text-right text-[#a6adc8] font-mono bg-transparent border border-transparent hover:border-[#313244] focus:border-[#89b4fa] focus:outline-none rounded px-1 appearance-none"
                                title="é»æ“Šè¼¸å…¥ç²¾ç¢ºæ•¸å€¼">
                            <span class="text-[10px] text-[#6c7086] w-8">${v.unit}</span>
                        </div>`;
            }
            return '';
        }

        // [å·²ä¿®æ”¹] å®šä½ CSS è®Šæ•¸ï¼Œæ‰¾ä¸åˆ°æ™‚æœå°‹åŒä¸€è®Šæ•¸çµ„çš„å…¶ä»– Tab å’Œåˆ†é 
        function locateVariable(varName) {
            const searchStr = `var(${varName})`;

            // æ ¹æ“šç•¶å‰è®Šæ•¸çµ„æ±ºå®šè¦æœå°‹çš„ç·¨è¼¯å™¨é †åº
            const groupKey = getVarGroupKey(activeEditorTab);

            if (groupKey === 'simple') {
                // ====== ç°¡æ˜“æ¨¡å¼ï¼šæœå°‹æ‰€æœ‰ CSS åˆ†é  ======
                // 1. å…ˆæœå°‹ç•¶å‰ CSS ç·¨è¼¯å™¨
                if (cssEditor) {
                    const code = cssEditor.getValue();
                    const index = code.indexOf(searchStr);
                    if (index !== -1) {
                        locateInCssEditor(code, searchStr, index, varName);
                        if (activeEditorTab !== 'css') switchTab('css');
                        return;
                    }
                }

                // 2. æœå°‹æ‰€æœ‰å…¶ä»– CSS åˆ†é 
                saveCurrentCss();
                for (const css of cssGroups) {
                    if (css.id === activeCssId) continue;
                    const content = css.content || '';
                    const index = content.indexOf(searchStr);
                    if (index !== -1) {
                        // æ‰¾åˆ°äº†ï¼åˆ‡æ›åˆ°è©² CSS åˆ†é 
                        switchTab('css');
                        switchCss(css.id);
                        setTimeout(() => {
                            if (cssEditor) {
                                const newCode = cssEditor.getValue();
                                const newIndex = newCode.indexOf(searchStr);
                                if (newIndex !== -1) {
                                    locateInCssEditor(newCode, searchStr, newIndex, varName);
                                }
                            }
                        }, 50);
                        console.log(`ğŸ” åœ¨ CSS åˆ†é ã€Œ${css.name}ã€ä¸­æ‰¾åˆ°è®Šæ•¸ ${varName}ï¼Œå·²è‡ªå‹•åˆ‡æ›`);
                        return;
                    }
                }

                // 3. æœå°‹ HTML ç·¨è¼¯å™¨
                if (htmlEditor) {
                    const code = htmlEditor.getValue();
                    const index = code.indexOf(searchStr);
                    if (index !== -1) {
                        switchTab('html');
                        locateInHtmlEditor(code, searchStr, index, varName);
                        return;
                    }
                }

                alert(`åœ¨æ‰€æœ‰ CSS åˆ†é å’Œ HTML ç·¨è¼¯å™¨ä¸­éƒ½æ‰¾ä¸åˆ°å¼•ç”¨ ${varName} çš„åœ°æ–¹ã€‚\nå¯èƒ½è©²è®Šæ•¸æœªè¢«ä½¿ç”¨æˆ–å·²è¢«æ‰‹å‹•åˆªé™¤ã€‚`);
            } else {
                // ====== Regex æ¨¡å¼ï¼šæœå°‹æ‰€æœ‰ Regex è¦å‰‡ ======
                
                // 1. å…ˆæœå°‹ç•¶å‰è¦å‰‡çš„ output ç·¨è¼¯å™¨
                if (regexOutputEditor) {
                    const code = regexOutputEditor.getValue();
                    const index = code.indexOf(searchStr);
                    if (index !== -1) {
                        locateInRegexEditor(code, searchStr, index, varName);
                        if (activeEditorTab !== 'regex') switchTab('regex');
                        return;
                    }
                }

                // 2. æœå°‹ Story ç·¨è¼¯å™¨
                if (storyEditor) {
                    const code = storyEditor.getValue();
                    const index = code.indexOf(searchStr);
                    if (index !== -1) {
                        switchTab('story');
                        locateInStoryEditor(code, searchStr, index, varName);
                        return;
                    }
                }

                // 3. æœå°‹æ‰€æœ‰å…¶ä»– editdisplay è¦å‰‡
                saveCurrentRule();
                const displayRules = regexRules.filter(r => r.type === 'editdisplay');
                for (const rule of displayRules) {
                    if (rule.id === activeRuleId) continue;
                    const content = rule.output || '';
                    const index = content.indexOf(searchStr);
                    if (index !== -1) {
                        // æ‰¾åˆ°äº†ï¼åˆ‡æ›åˆ°è©²è¦å‰‡
                        switchTab('regex');
                        switchRule(rule.id);
                        setTimeout(() => {
                            if (regexOutputEditor) {
                                const newCode = regexOutputEditor.getValue();
                                const newIndex = newCode.indexOf(searchStr);
                                if (newIndex !== -1) {
                                    locateInRegexEditor(newCode, searchStr, newIndex, varName);
                                }
                            }
                        }, 50);
                        console.log(`ğŸ” åœ¨ Regex è¦å‰‡ã€Œ${rule.name}ã€ä¸­æ‰¾åˆ°è®Šæ•¸ ${varName}ï¼Œå·²è‡ªå‹•åˆ‡æ›`);
                        return;
                    }
                }

                alert(`åœ¨æ‰€æœ‰ Regex è¦å‰‡å’Œ Story ç·¨è¼¯å™¨ä¸­éƒ½æ‰¾ä¸åˆ°å¼•ç”¨ ${varName} çš„åœ°æ–¹ã€‚\nå¯èƒ½è©²è®Šæ•¸æœªè¢«ä½¿ç”¨æˆ–å·²è¢«æ‰‹å‹•åˆªé™¤ã€‚`);
            }
        }

        // è¼”åŠ©å‡½æ•¸ï¼šåœ¨ Regex ç·¨è¼¯å™¨ä¸­å®šä½
        function locateInRegexEditor(code, searchStr, index, varName) {
            const textBefore = code.substring(0, index);
            const lines = textBefore.split('\n');
            const lineNumber = lines.length;
            const column = lines[lines.length - 1].length + 1;

            regexOutputEditor.setSelection({
                startLineNumber: lineNumber,
                startColumn: column,
                endLineNumber: lineNumber,
                endColumn: column + searchStr.length
            });
            regexOutputEditor.revealLineInCenter(lineNumber);
            regexOutputEditor.focus();
            console.log(`ğŸ” å·²å®šä½è®Šæ•¸ ${varName} æ–¼ Regex ç·¨è¼¯å™¨ç¬¬ ${lineNumber} è¡Œ`);
        }

        // è¼”åŠ©å‡½æ•¸ï¼šåœ¨ Story ç·¨è¼¯å™¨ä¸­å®šä½
        function locateInStoryEditor(code, searchStr, index, varName) {
            const textBefore = code.substring(0, index);
            const lines = textBefore.split('\n');
            const lineNumber = lines.length;
            const column = lines[lines.length - 1].length + 1;

            storyEditor.setSelection({
                startLineNumber: lineNumber,
                startColumn: column,
                endLineNumber: lineNumber,
                endColumn: column + searchStr.length
            });
            storyEditor.revealLineInCenter(lineNumber);
            storyEditor.focus();
            console.log(`ğŸ” å·²å®šä½è®Šæ•¸ ${varName} æ–¼ Story ç·¨è¼¯å™¨ç¬¬ ${lineNumber} è¡Œ`);
        }

        // è¼”åŠ©å‡½æ•¸ï¼šåœ¨ CSS ç·¨è¼¯å™¨ä¸­å®šä½
        function locateInCssEditor(code, searchStr, index, varName) {
            const textBefore = code.substring(0, index);
            const lines = textBefore.split('\n');
            const lineNumber = lines.length;
            const column = lines[lines.length - 1].length + 1;

            cssEditor.setSelection({
                startLineNumber: lineNumber,
                startColumn: column,
                endLineNumber: lineNumber,
                endColumn: column + searchStr.length
            });
            cssEditor.revealLineInCenter(lineNumber);
            cssEditor.focus();
            console.log(`ğŸ” å·²å®šä½è®Šæ•¸ ${varName} æ–¼ CSS ç·¨è¼¯å™¨ç¬¬ ${lineNumber} è¡Œ`);
        }

        // è¼”åŠ©å‡½æ•¸ï¼šåœ¨ HTML ç·¨è¼¯å™¨ä¸­å®šä½
        function locateInHtmlEditor(code, searchStr, index, varName) {
            const textBefore = code.substring(0, index);
            const lines = textBefore.split('\n');
            const lineNumber = lines.length;
            const column = lines[lines.length - 1].length + 1;

            htmlEditor.setSelection({
                startLineNumber: lineNumber,
                startColumn: column,
                endLineNumber: lineNumber,
                endColumn: column + searchStr.length
            });
            htmlEditor.revealLineInCenter(lineNumber);
            htmlEditor.focus();
            console.log(`ğŸ” å·²å®šä½è®Šæ•¸ ${varName} æ–¼ HTML ç·¨è¼¯å™¨ç¬¬ ${lineNumber} è¡Œ`);
        }

        // --- Snippet Logic ---
        const defaultSnippets = [
            // === åŸºç¤æ¨£å¼ ===
            { name: "ğŸ”³ åœ“è§’", code: "border-radius: 12px;" },
            { name: "ğŸ“ é‚Šæ¡†", code: "border: 1px solid #ccc;" },
            { name: "ğŸ“ å…§è·", code: "padding: 16px;" },
            { name: "ğŸ“ å¤–è·", code: "margin: 16px;" },
            { name: "ğŸ“¦ å¯¬é«˜", code: "width: 100%;\nheight: auto;" },

            // === æ–‡å­—æ’ç‰ˆ ===
            { name: "ğŸ”¤ å­—é«”å¤§å°", code: "font-size: 1rem;" },
            { name: "ğŸ…±ï¸ å­—é«”ç²—ç´°", code: "font-weight: 600;" },
            { name: "ğŸ“ è¡Œé«˜é–“è·", code: "line-height: 1.6;\nletter-spacing: 0.02em;" },
            { name: "ğŸ“‹ æ–‡å­—å°é½Š", code: "text-align: center;" },
            { name: "âœ‚ï¸ æ–‡å­—æˆªæ–·", code: "overflow: hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;" },

            // === é¡è‰²èˆ‡èƒŒæ™¯ ===
            { name: "ğŸ¨ æ–‡å­—é¡è‰²", code: "color: #333333;" },
            { name: "ğŸ–Œï¸ èƒŒæ™¯é¡è‰²", code: "background-color: #ffffff;" },
            { name: "ğŸŒˆ èƒŒæ™¯æ¼¸å±¤", code: "background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);" },
            { name: "ğŸ–¼ï¸ èƒŒæ™¯åœ–ç‰‡", code: "background-image: url('');\nbackground-size: cover;\nbackground-position: center;" },
            { name: "âœ¨ æ–‡å­—æ¼¸å±¤", code: "background: linear-gradient(45deg, #f5c2e7, #89b4fa);\n-webkit-background-clip: text;\ncolor: transparent;" },

            // === ä½ˆå±€å®¹å™¨ ===
            { name: "ğŸ“¦ Flex å®¹å™¨", code: "display: flex;\nalign-items: center;\njustify-content: center;" },
            { name: "ğŸ“¦ Flex æ©«æ’", code: "display: flex;\nflex-direction: row;\ngap: 12px;" },
            { name: "ğŸ“¦ Flex ç›´æ’", code: "display: flex;\nflex-direction: column;\ngap: 12px;" },
            { name: "ğŸ”² Grid å®¹å™¨", code: "display: grid;\ngrid-template-columns: repeat(3, 1fr);\ngap: 16px;" },
            { name: "ğŸ“ çµ•å°å®šä½", code: "position: absolute;\ntop: 0;\nleft: 0;" },
            { name: "ğŸ“Œ å›ºå®šå®šä½", code: "position: fixed;\nbottom: 20px;\nright: 20px;" },

            // === é™°å½±èˆ‡æ•ˆæœ ===
            { name: "ğŸ‘» ç›’å­é™°å½±", code: "box-shadow: 0 4px 6px rgba(0,0,0,0.1);" },
            { name: "ğŸ’ æ–‡å­—é™°å½±", code: "text-shadow: 2px 2px 4px rgba(0,0,0,0.3);" },
            { name: "ğŸªŸ ç»ç’ƒæ“¬æ…‹", code: "backdrop-filter: blur(10px);\nbackground: rgba(255,255,255,0.15);\nborder: 1px solid rgba(255,255,255,0.2);" },
            { name: "ğŸ‘ï¸ é€æ˜åº¦", code: "opacity: 0.8;" },

            // === äº’å‹•æ•ˆæœ ===
            { name: "ğŸ‘† æ»‘é¼ æ‰‹å‹¢", code: "cursor: pointer;" },
            { name: "ğŸ­ éæ¸¡å‹•ç•«", code: "transition: all 0.3s ease;" },
            { name: "ğŸ” æ‡¸åœæ”¾å¤§", code: "transform: scale(1.05);" },
            { name: "ğŸ”„ æ—‹è½‰", code: "transform: rotate(45deg);" },
            { name: "ğŸ’« é—œéµå¹€å‹•ç•«", code: "@keyframes pulse {\n  0% { opacity: 1; }\n  50% { opacity: 0.5; }\n  100% { opacity: 1; }\n}\nanimation: pulse 2s infinite;" }
        ];
        let userSnippets = [];

        function loadSnippets() {
            const stored = localStorage.getItem('regex_ui_lab_snippets');
            if (stored) {
                try { userSnippets = JSON.parse(stored); } catch (e) { userSnippets = []; }
            }
            renderSnippets();
        }
        function saveSnippets() {
            localStorage.setItem('regex_ui_lab_snippets', JSON.stringify(userSnippets));
            renderSnippets();
        }

        // åŒ¯å‡ºå’’èªç‚º JSON æª”æ¡ˆ
        function exportSnippets() {
            if (userSnippets.length === 0) {
                alert('å°šç„¡è‡ªè¨‚å’’èªå¯åŒ¯å‡ºï¼\nè«‹å…ˆæ–°å¢å’’èªå¾Œå†åŒ¯å‡ºã€‚');
                return;
            }

            const data = JSON.stringify(userSnippets, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `regex-ui-lab-snippets-${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            alert(`å·²åŒ¯å‡º ${userSnippets.length} å€‹è‡ªè¨‚å’’èªï¼`);
        }

        // åŒ¯å…¥å’’èª JSON æª”æ¡ˆ
        function importSnippets(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (!Array.isArray(imported)) {
                        throw new Error('æ ¼å¼éŒ¯èª¤ï¼šå¿…é ˆæ˜¯é™£åˆ—');
                    }

                    // é©—è­‰æ ¼å¼
                    imported.forEach((item, i) => {
                        if (!item.name || !item.code) {
                            throw new Error(`ç¬¬ ${i + 1} é …ç¼ºå°‘ name æˆ– code æ¬„ä½`);
                        }
                    });

                    // åˆä½µä¸¦å»é‡
                    const existingNames = new Set(userSnippets.map(s => s.name));
                    let added = 0;
                    imported.forEach(s => {
                        if (!existingNames.has(s.name)) {
                            userSnippets.push({ name: s.name, code: s.code });
                            added++;
                        }
                    });

                    saveSnippets();
                    alert(`åŒ¯å…¥æˆåŠŸï¼\næ–°å¢ ${added} å€‹å’’èª\nç•¥é ${imported.length - added} å€‹é‡è¤‡é …ç›®`);
                } catch (err) {
                    alert(`åŒ¯å…¥å¤±æ•—ï¼š${err.message}`);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // é‡è¨­ input ä»¥ä¾¿é‡è¤‡é¸æ“‡åŒæª”æ¡ˆ
        }
        function renderSnippets() {
            const container = document.getElementById('snippetContainer');
            if (!container) return; // Guard

            let html = defaultSnippets.map(s => `
                <span class="snippet-chip" onclick="insertSnippet(\`${s.code.replace(/\n/g, '\\n').replace(/"/g, '&quot;')}\`)">${s.name}</span>
            `).join('');

            if (userSnippets.length > 0) {
                html += '<div class="w-full h-[1px] bg-[#313244] my-2"></div>';
                html += userSnippets.map((s, index) => `
                    <span class="snippet-chip !bg-[#45475a] !text-[#f9e2af]">
                        <span onclick="insertSnippet(\`${s.code.replace(/\n/g, '\\n').replace(/"/g, '&quot;')}\`)">${s.name}</span>
                        <i class="fas fa-times snippet-delete" onclick="openConfirmModal(${index}); event.stopPropagation();"></i>
                    </span>
                `).join('');
            }
            container.innerHTML = html;
        }
        function insertSnippet(code) {
            const editor = getCurrentEditor();
            if (!editor) { alert("è«‹ç­‰å¾…ç·¨è¼¯å™¨åˆå§‹åŒ–å®Œæˆï¼"); return; }

            // åœ¨æ¸¸æ¨™ä½ç½®æ’å…¥ç¨‹å¼ç¢¼ç‰‡æ®µ
            const selection = editor.getSelection();
            const id = { major: 1, minor: 1 };
            const op = {
                identifier: id,
                range: selection,
                text: code,
                forceMoveMarkers: true
            };
            editor.executeEdits('insertSnippet', [op]);
            editor.focus();
            render();
        }

        // ===== å’’èªåˆ†é ç³»çµ± =====
        let currentSnippetTab = 'css';
        let lastSelectedSelector = null; // å„²å­˜æœ€å¾Œé¸å–çš„å…ƒç´ é¸æ“‡å™¨

        function switchSnippetTab(tab) {
            currentSnippetTab = tab;
            const cssTab = document.getElementById('snippetTabCss');
            const responsiveTab = document.getElementById('snippetTabResponsive');
            const snippetContainer = document.getElementById('snippetContainer');
            const responsiveContainer = document.getElementById('responsiveContainer');
            const snippetActions = document.getElementById('snippetActions');

            if (tab === 'css') {
                cssTab.className = 'text-xs px-2 py-1 rounded-t bg-[#313244] text-[#a6e3a1] font-bold border-b-2 border-[#a6e3a1]';
                responsiveTab.className = 'text-xs px-2 py-1 rounded-t bg-[#1e1e2e] text-[#6c7086] hover:text-white transition';
                snippetContainer.classList.remove('hidden');
                responsiveContainer.classList.add('hidden');
                if (snippetActions) snippetActions.style.display = 'flex';
            } else {
                cssTab.className = 'text-xs px-2 py-1 rounded-t bg-[#1e1e2e] text-[#6c7086] hover:text-white transition';
                responsiveTab.className = 'text-xs px-2 py-1 rounded-t bg-[#313244] text-[#f9e2af] font-bold border-b-2 border-[#f9e2af]';
                snippetContainer.classList.add('hidden');
                responsiveContainer.classList.remove('hidden');
                if (snippetActions) snippetActions.style.display = 'none';
                updateResponsiveHint();
            }
        }

        function updateResponsiveHint() {
            const hint = document.getElementById('responsiveHint');
            if (hint) {
                if (lastSelectedSelector) {
                    hint.innerHTML = `å·²é¸å–: <span class="text-[#a6e3a1] font-mono">${lastSelectedSelector}</span>`;
                } else {
                    hint.textContent = 'å…ˆç”¨ã€Œé¸å–ã€æ¨¡å¼é¸å–å…ƒç´ ï¼Œå†é»æ“Šä¸‹æ–¹æŒ‰éˆ•';
                }
            }
        }

        // éŸ¿æ‡‰å¼æ•ˆæœå®šç¾©
        const responsiveEffects = {
            hide: { name: 'éš±è—', css: 'display: none;' },
            smallText: { name: 'ç¸®å°å­—é«”', css: 'font-size: 0.875rem;' },
            fullWidth: { name: 'æ»¿ç‰ˆå¯¬åº¦', css: 'width: 100%;\n    max-width: 100%;' },
            column: { name: 'ç›´å‘æ’åˆ—', css: 'flex-direction: column;' },
            centerText: { name: 'ç½®ä¸­æ–‡å­—', css: 'text-align: center;' },
            noPadding: { name: 'ç§»é™¤å…§è·', css: 'padding: 0;' },
            twoColumn: { name: 'å…©æ¬„', css: 'grid-template-columns: repeat(2, 1fr);' },
            smallerText: { name: 'ç¨å¾®ç¸®å°', css: 'font-size: 0.95rem;' }
        };

        function insertResponsiveStyle(effectType, maxWidth, minWidth) {
            if (!cssEditor) { alert("è«‹ç­‰å¾…ç·¨è¼¯å™¨åˆå§‹åŒ–å®Œæˆï¼"); return; }

            const effect = responsiveEffects[effectType];
            if (!effect) return;

            // ä½¿ç”¨å·²é¸å–çš„é¸æ“‡å™¨ï¼Œæˆ–é è¨­ä½”ä½ç¬¦
            const selector = lastSelectedSelector || '.your-class';

            // ç”¢ç”Ÿ media query
            let mediaQuery;
            if (minWidth) {
                mediaQuery = `@media (min-width: ${minWidth}px) and (max-width: ${maxWidth}px)`;
            } else {
                mediaQuery = `@media (max-width: ${maxWidth}px)`;
            }

            const code = `\n${mediaQuery} {\n  ${selector} {\n    ${effect.css}\n  }\n}\n`;

            // åˆ‡æ›åˆ° CSS åˆ†é ä¸¦æ’å…¥
            switchTab('css');

            // åœ¨ç·¨è¼¯å™¨æœ«å°¾æ’å…¥
            const model = cssEditor.getModel();
            const lastLine = model.getLineCount();
            const lastColumn = model.getLineMaxColumn(lastLine);

            const range = {
                startLineNumber: lastLine,
                startColumn: lastColumn,
                endLineNumber: lastLine,
                endColumn: lastColumn
            };

            cssEditor.executeEdits('insertResponsive', [{
                range: range,
                text: code
            }]);

            // æ»¾å‹•åˆ°æ–°æ’å…¥çš„ä½ç½®
            cssEditor.revealLineInCenter(lastLine + 3);
            cssEditor.focus();
            render();
        }

        // Modals
        const modal = document.getElementById('snippetModal');
        const confirmModal = document.getElementById('confirmModal');
        const nameInput = document.getElementById('newSnippetName');
        const codeInput = document.getElementById('newSnippetCode');
        function openSnippetModal() { modal.style.display = 'flex'; nameInput.value = ''; codeInput.value = ''; nameInput.focus(); }
        function closeSnippetModal() { modal.style.display = 'none'; }
        function confirmAddSnippet() {
            const name = nameInput.value.trim();
            const code = codeInput.value.trim();
            if (!name || !code) { alert("è«‹å¡«å¯«å®Œæ•´å’’èªåç¨±èˆ‡ä»£ç¢¼ï¼"); return; }
            userSnippets.push({ name, code });
            saveSnippets();
            closeSnippetModal();
        }
        function openConfirmModal(index) { deleteTargetIndex = index; confirmModal.style.display = 'flex'; }
        function closeConfirmModal() { confirmModal.style.display = 'none'; deleteTargetIndex = -1; }
        function performDeleteSnippet() {
            if (deleteTargetIndex > -1) {
                userSnippets.splice(deleteTargetIndex, 1);
                saveSnippets();
                closeConfirmModal();
            }
        }

        // åˆ‡æ›æç…‰é¡å‹éæ¿¾é¢æ¿
        function toggleExtractFilter() {
            const panel = document.getElementById('extractFilterPanel');
            panel.classList.toggle('hidden');
        }

        // é»æ“Šå…¶ä»–åœ°æ–¹é—œé–‰é¢æ¿
        document.addEventListener('click', (e) => {
            const panel = document.getElementById('extractFilterPanel');
            const btn = document.getElementById('extractFilterBtn');
            if (panel && btn && !panel.contains(e.target) && !btn.contains(e.target)) {
                panel.classList.add('hidden');
            }
        });

        // --- Auto Extract (Alchemy) ---
        function autoExtractVariables() {
            // æ ¹æ“šç•¶å‰ Tab é¸æ“‡ç·¨è¼¯å™¨
            let editor = null;
            let editorName = '';
            switch (activeEditorTab) {
                case 'css':
                    editor = cssEditor;
                    editorName = 'CSS';
                    break;
                case 'html':
                    editor = htmlEditor;
                    editorName = 'HTML';
                    break;
                case 'regex':
                    editor = regexOutputEditor;
                    editorName = 'Regex OUT';
                    break;
                case 'story':
                    editor = storyEditor;
                    editorName = 'åŠ‡æƒ…';
                    break;
            }

            if (!editor) { alert("è«‹ç­‰å¾…ç·¨è¼¯å™¨åˆå§‹åŒ–å®Œæˆï¼"); return; }
            let css = editor.getValue();
            if (!css.trim()) { alert(`è«‹å…ˆåœ¨ ${editorName} ç·¨è¼¯å™¨ä¸­è¼¸å…¥å…§å®¹ï¼`); return; }

            // è®€å–éæ¿¾è¨­å®š
            const filters = {
                color: document.getElementById('extractColor')?.checked ?? true,
                size: document.getElementById('extractSize')?.checked ?? true,
                angle: document.getElementById('extractAngle')?.checked ?? true,
                viewport: document.getElementById('extractViewport')?.checked ?? true
            };

            // åˆ¤æ–·å€¼æ˜¯å¦ç¬¦åˆéæ¿¾æ¢ä»¶
            const matchesFilter = (text) => {
                // é¡è‰²ï¼ˆhexï¼‰
                if (text.startsWith('#')) {
                    return filters.color;
                }
                // é¡è‰²ï¼ˆrgba/rgb/hsl/hslaï¼‰
                if (/^rgba?\(/i.test(text) || /^hsla?\(/i.test(text)) {
                    return filters.color;
                }
                // åˆ¤æ–·å–®ä½
                const unit = text.replace(/^-?\d*\.?\d+/, '');
                if (unit === 'deg') return filters.angle;
                if (unit === 'vh' || unit === 'vw') return filters.viewport;
                if (unit === 'px' || unit === 'em' || unit === 'rem' || unit === '%') return filters.size;
                if (unit === 's' || unit === 'ms') return filters.size; // æ™‚é–“å–®ä½æ­¸é¡æ–¼å°ºå¯¸
                if (unit === '') {
                    // ç„¡å–®ä½æ•¸å­—ï¼ˆå¦‚ scale(1.05)ï¼‰
                    const num = parseFloat(text);
                    // éæ¿¾æ‰å¤ªå°çš„æ•¸å­—ï¼Œé¿å…æç…‰ 0, 1 ç­‰å¸¸è¦‹å€¼
                    if (!isNaN(num) && Math.abs(num) > 1 && Math.abs(num) < 10) {
                        return filters.size; // ç„¡å–®ä½æ•¸å­—æ­¸é¡æ–¼å°ºå¯¸
                    }
                    return false; // å…¶ä»–ç„¡å–®ä½æ•¸å­—ä¸æç…‰
                }
                return true; // é è¨­åŒ…å«
            };

            const cleanName = (str) => str.replace(/[^\w\s-]/g, '').trim().replace(/\s+/g, '-').toLowerCase();

            // æ‰¾å‡ºæ‰€æœ‰ @media æŸ¥è©¢çš„ä½ç½®ç¯„åœï¼Œé€™äº›ç¯„åœå…§çš„æ•¸å€¼ä¸æ‡‰è½‰æ›ç‚º var()
            const mediaRanges = [];
            const mediaRegex = /@media\s*\([^{]+\)/gi;
            let mediaMatch;
            while ((mediaMatch = mediaRegex.exec(css)) !== null) {
                mediaRanges.push({ start: mediaMatch.index, end: mediaMatch.index + mediaMatch[0].length });
            }

            // æª¢æŸ¥æŸå€‹ä½ç½®æ˜¯å¦åœ¨ @media æŸ¥è©¢æ¢ä»¶å…§
            const isInMediaQuery = (pos) => mediaRanges.some(r => pos >= r.start && pos < r.end);

            const declRegex = /([a-zA-Z-]+)\s*:\s*([^;{}]+)(?:;|\s*})/g;
            // æ“´å……åŒ¹é…è¦å‰‡ï¼šæ”¯æ´ 8 ä½ hex é¡è‰²ã€rgba/rgb/hsl/hslaã€s/ms ç§’å–®ä½ã€ç„¡å–®ä½æ•¸å­—
            const valPartsRegex = /(-?\d*\.?\d+(?:px|em|rem|%|deg|vh|vw|s|ms)?|#(?:[0-9a-fA-F]{8}|[0-9a-fA-F]{6}|[0-9a-fA-F]{3})|rgba?\([^)]+\)|hsla?\([^)]+\))/gi;

            let match;
            // ä¿ç•™ç¾æœ‰è®Šæ•¸ï¼Œåªæ–°å¢æ–°çš„
            const existingVarNames = new Set(customVars.map(v => v.name));
            let newVarsCount = 0;
            let mediaVarsCount = 0;
            const changes = [];

            declRegex.lastIndex = 0;
            while ((match = declRegex.exec(css)) !== null) {
                const prop = match[1];
                const val = match[2];
                const matchString = match[0];
                const valStartInMatch = matchString.indexOf(val);
                const absValStart = match.index + valStartInMatch;

                // æª¢æŸ¥é€™å€‹å®£å‘Šæ˜¯å¦åœ¨ @media æŸ¥è©¢æ¢ä»¶å…§
                const inMedia = isInMediaQuery(match.index);

                const textBefore = css.substring(0, match.index);
                const braceIndex = textBefore.lastIndexOf('{');
                let selectorName = inMedia ? "breakpoint" : "global";
                if (!inMedia && braceIndex !== -1) {
                    const selectorPart = textBefore.substring(0, braceIndex);
                    const lastCloseBrace = selectorPart.lastIndexOf('}');
                    let rawSelector = selectorPart.substring(lastCloseBrace + 1).trim();
                    const lines = rawSelector.split('\n');
                    rawSelector = lines[lines.length - 1];
                    if (rawSelector) selectorName = cleanName(rawSelector);
                }
                if (selectorName.length > 25) selectorName = selectorName.substring(0, 25);

                valPartsRegex.lastIndex = 0;
                let pMatch;
                while ((pMatch = valPartsRegex.exec(val)) !== null) {
                    const text = pMatch[0];
                    const num = parseFloat(text);
                    if (!isNaN(num) && (num === 0 || num === 1)) continue;

                    // æª¢æŸ¥é€™å€‹å€¼æ˜¯å¦åœ¨ var() å¼•ç”¨å…§ï¼ˆå·²è¢«æç…‰éï¼‰
                    // æŸ¥çœ‹å®Œæ•´å€¼å­—ä¸²ï¼Œç¢ºèª pMatch.index çš„ä½ç½®å‰å¾Œæ˜¯å¦è¢« var() åŒ…åœ
                    const beforeMatch = val.substring(0, pMatch.index);
                    const afterMatch = val.substring(pMatch.index + text.length);
                    if (beforeMatch.endsWith('var(') || beforeMatch.includes('var(--')) {
                        // é€™å€‹å€¼å·²ç¶“åœ¨ var() å…§ï¼Œè·³é
                        continue;
                    }

                    // æª¢æŸ¥æ˜¯å¦ç¬¦åˆéæ¿¾æ¢ä»¶
                    if (!matchesFilter(text)) {
                        continue;
                    }

                    let varName = `--${selectorName}-${prop}`;
                    let counter = 1;
                    // æª¢æŸ¥æ˜¯å¦èˆ‡ç¾æœ‰è®Šæ•¸æˆ–æœ¬æ¬¡æ–°å¢çš„è®Šæ•¸è¡çª
                    while (existingVarNames.has(varName) || customVars.some(v => v.name === varName) || changes.some(c => c.varName === varName)) {
                        varName = `--${selectorName}-${prop}-${counter++}`;
                    }

                    const type = text.startsWith('#') ? 'color' : 'range';
                    let unit = '';
                    if (type === 'range') unit = text.replace(/^-?\d*\.?\d+/, '');

                    const id = 'v' + Date.now() + Math.floor(Math.random() * 10000);
                    
                    // æ ¹æ“šç•¶å‰æ¨¡å¼å–å¾—ä¾†æºè³‡è¨Š
                    let sourceInfo = {};
                    const groupKey = getVarGroupKey(activeEditorTab);
                    
                    if (groupKey === 'simple') {
                        // ç°¡æ˜“æ¨¡å¼ï¼šè¨˜éŒ„ CSS åˆ†é è³‡è¨Š
                        const currentCss = cssGroups.find(c => c.id === activeCssId);
                        sourceInfo = {
                            cssPageId: activeCssId,
                            cssPageName: currentCss ? currentCss.name : 'æœªçŸ¥åˆ†é '
                        };
                    } else {
                        // Regex æ¨¡å¼ï¼šè¨˜éŒ„è¦å‰‡è³‡è¨Š
                        const currentRule = regexRules.find(r => r.id === activeRuleId);
                        sourceInfo = {
                            ruleId: activeRuleId,
                            ruleName: currentRule ? currentRule.name : 'æœªçŸ¥è¦å‰‡'
                        };
                    }
                    
                    // æ¨™è¨˜æ˜¯å¦ç‚º @media æŸ¥è©¢ä¸­çš„æ–·é»è®Šæ•¸
                    customVars.push({
                        id,
                        name: varName,
                        type,
                        value: text.replace(unit, ''),
                        unit,
                        original: text,
                        isNew: true,
                        isMediaQuery: inMedia,
                        selector: inMedia ? '@media' : (selectorName || 'global'),
                        ...sourceInfo  // å±•é–‹ä¾†æºè³‡è¨Š
                    });

                    // åªæœ‰é @media æŸ¥è©¢ä¸­çš„æ•¸å€¼æ‰æœƒè¢«æ›¿æ›ç‚º var()
                    if (!inMedia) {
                        const absStart = absValStart + pMatch.index;
                        const absEnd = absStart + text.length;
                        changes.push({ start: absStart, end: absEnd, text: `var(${varName})`, varName });
                    } else {
                        mediaVarsCount++;
                    }
                    newVarsCount++;
                }
            }

            changes.sort((a, b) => b.start - a.start);
            let resultCSS = css;
            changes.forEach(c => { resultCSS = resultCSS.substring(0, c.start) + c.text + resultCSS.substring(c.end); });

            if (newVarsCount > 0) {
                editor.setValue(resultCSS);
                // åŒæ™‚å„²å­˜åˆ° tabVariables
                tabVariables[getVarGroupKey(activeEditorTab)].cssVars = customVars;
                renderVarControls();
                render();
                let msg = `æå–æ¨¡å¼å•Ÿå‹•ï¼\nå·²å¾ ${editorName} ç·¨è¼¯å™¨æ™ºæ…§æå– ${newVarsCount} å€‹è®Šæ•¸ã€‚`;
                if (mediaVarsCount > 0) {
                    msg += `\n\nâš ï¸ åµæ¸¬åˆ° ${mediaVarsCount} å€‹éŸ¿æ‡‰å¼æ–·é»ï¼š\né€™äº›è®Šæ•¸å¯åœ¨æ§åˆ¶å°èª¿æ•´ï¼Œä½†åŒ¯å‡ºæ™‚\næœƒä¿æŒåŸå§‹æ•¸å€¼ä»¥ç¢ºä¿ç›¸å®¹æ€§ã€‚`;
                }
                alert(msg);
            } else {
                alert("æœªç™¼ç¾å¯æå–çš„æ•¸å€¼ã€‚");
            }
        }

        // ğŸ”¥ æç…‰é¸å–ï¼šå¾ç·¨è¼¯å™¨é¸å–çš„ç¨‹å¼ç¢¼ç‰‡æ®µä¸­æç…‰è®Šæ•¸
        function extractSelectedCSS() {
            const editor = getCurrentEditor();
            const editorName = getEditorName();
            if (!editor) { alert("è«‹ç­‰å¾…ç·¨è¼¯å™¨åˆå§‹åŒ–å®Œæˆï¼"); return; }

            const selection = editor.getSelection();
            const selectedText = editor.getModel().getValueInRange(selection);

            if (!selectedText || !selectedText.trim()) {
                alert(`è«‹å…ˆåœ¨ ${editorName} ç·¨è¼¯å™¨ä¸­é¸å–è¦æç…‰çš„ç¨‹å¼ç¢¼å€æ®µï¼\n\nä½¿ç”¨æ–¹æ³•ï¼š\n1. åœ¨ç·¨è¼¯å™¨ä¸­é¸å–ä¸€æ®µå®Œæ•´çš„æ¨£å¼è¦å‰‡\n2. é»æ“Šã€Œæç…‰é¸å–ã€æŒ‰éˆ•`);
                return;
            }

            // è®€å–éæ¿¾è¨­å®š
            const filters = {
                color: document.getElementById('extractColor')?.checked ?? true,
                size: document.getElementById('extractSize')?.checked ?? true,
                angle: document.getElementById('extractAngle')?.checked ?? true,
                viewport: document.getElementById('extractViewport')?.checked ?? true
            };

            // åˆ¤æ–·å€¼æ˜¯å¦ç¬¦åˆéæ¿¾æ¢ä»¶
            const matchesFilter = (text) => {
                if (text.startsWith('#')) return filters.color;
                if (/^rgba?\(/.test(text) || /^hsla?\(/.test(text)) return filters.color;
                const unit = text.replace(/^-?\d*\.?\d+/, '');
                if (unit === 'deg') return filters.angle;
                if (unit === 'vh' || unit === 'vw') return filters.viewport;
                if (unit === 'px' || unit === 'em' || unit === 'rem' || unit === '%') return filters.size;
                if (unit === 's' || unit === 'ms') return filters.size;
                if (unit === '') {
                    const num = parseFloat(text);
                    if (!isNaN(num) && Math.abs(num) > 1 && Math.abs(num) < 10) return filters.size;
                    return false;
                }
                return true;
            };

            const cleanName = (str) => str.replace(/[^\w\s-]/g, '').trim().replace(/\s+/g, '-').toLowerCase();

            const declRegex = /([a-zA-Z-]+)\s*:\s*([^;{}]+)(?:;|\s*})/g;
            const valPartsRegex = /(-?\d*\.?\d+(?:px|em|rem|%|deg|vh|vw|s|ms)?|#(?:[0-9a-fA-F]{8}|[0-9a-fA-F]{6}|[0-9a-fA-F]{3})|rgba?\([^)]+\)|hsla?\([^)]+\))/gi;

            // å˜—è©¦å¾é¸å–å…§å®¹ä¸­æå–é¸æ“‡å™¨
            const selectorMatch = selectedText.match(/([.#\w][^{]*)\s*\{/);
            let selectorName = 'selection';
            if (selectorMatch) {
                selectorName = cleanName(selectorMatch[1].trim().split('\n').pop());
                if (selectorName.length > 25) selectorName = selectorName.substring(0, 25);
            }

            let newVarsCount = 0;
            const changes = [];
            const existingVarNames = new Set(customVars.map(v => v.name));

            let match;
            declRegex.lastIndex = 0;
            while ((match = declRegex.exec(selectedText)) !== null) {
                const prop = match[1];
                const val = match[2];
                const matchString = match[0];
                const valStartInMatch = matchString.indexOf(val);
                const absValStart = match.index + valStartInMatch;

                let pMatch;
                valPartsRegex.lastIndex = 0;
                while ((pMatch = valPartsRegex.exec(val)) !== null) {
                    const text = pMatch[0];
                    const num = parseFloat(text);
                    if (!isNaN(num) && (num === 0 || num === 1)) continue;

                    const beforeMatch = val.substring(0, pMatch.index);
                    if (beforeMatch.endsWith('var(') || beforeMatch.includes('var(--')) continue;
                    if (!matchesFilter(text)) continue;

                    let varName = `--${selectorName}-${prop}`;
                    let counter = 1;
                    while (existingVarNames.has(varName) || customVars.some(v => v.name === varName) || changes.some(c => c.varName === varName)) {
                        varName = `--${selectorName}-${prop}-${counter++}`;
                    }

                    const type = text.startsWith('#') || /^rgba?\(/.test(text) || /^hsla?\(/.test(text) ? 'color' : 'range';
                    let unit = '';
                    if (type === 'range') unit = text.replace(/^-?\d*\.?\d+/, '');

                    const id = 'v' + Date.now() + Math.floor(Math.random() * 10000);
                    customVars.push({
                        id,
                        name: varName,
                        type,
                        value: type === 'color' ? text : text.replace(unit, ''),
                        unit,
                        original: text,
                        isNew: true,
                        isMediaQuery: false,
                        selector: selectorName
                    });

                    const absStart = absValStart + pMatch.index;
                    const absEnd = absStart + text.length;
                    changes.push({ start: absStart, end: absEnd, text: `var(${varName})`, varName });
                    newVarsCount++;
                    existingVarNames.add(varName);
                }
            }

            if (newVarsCount > 0) {
                // å»ºç«‹æ›¿æ›å¾Œçš„é¸å–å€åŸŸæ–‡å­—
                changes.sort((a, b) => b.start - a.start);
                let resultText = selectedText;
                changes.forEach(c => {
                    resultText = resultText.substring(0, c.start) + c.text + resultText.substring(c.end);
                });

                // å–ä»£é¸å–å€åŸŸ
                editor.executeEdits('extractSelected', [{
                    range: selection,
                    text: resultText
                }]);

                renderVarControls();

                // å±•é–‹æ–°å¢çš„åˆ†çµ„
                if (selectorName) {
                    expandVarGroup(selectorName);
                }

                alert(`âœ¨ å¾é¸å–å€æ®µæç…‰æˆåŠŸï¼\næ–°å¢ ${newVarsCount} å€‹è®Šæ•¸\nåˆ†çµ„ï¼š${selectorName}`);
            } else {
                alert("åœ¨é¸å–çš„å€æ®µä¸­æœªç™¼ç¾å¯æå–çš„æ•¸å€¼ã€‚\n\nå¯èƒ½åŸå› ï¼š\n1. é¸å–çš„å…§å®¹ä¸åŒ…å«æ•¸å€¼\n2. æ•¸å€¼å·²è¢«æç…‰ç‚º var()\n3. æ•¸å€¼è¢«éæ¿¾æ¢ä»¶æ’é™¤");
            }
        }

        // å–å¾—ç•¶å‰ Tab çš„ç·¨è¼¯å™¨
        function getCurrentEditor() {
            switch (activeEditorTab) {
                case 'css': return cssEditor;
                case 'html': return htmlEditor;
                case 'regex': return regexOutputEditor;
                case 'story': return storyEditor;
                default: return cssEditor;
            }
        }

        function getEditorName() {
            switch (activeEditorTab) {
                case 'css': return 'CSS';
                case 'html': return 'HTML';
                case 'regex': return 'Regex OUT';
                case 'story': return 'åŠ‡æƒ…';
                default: return 'CSS';
            }
        }

        // ç‡’éŒ„å„²å­˜ï¼šå°‡è®Šæ•¸å€¼å¯«å›ç•¶å‰ Tab ç·¨è¼¯å™¨ä¸¦æ¸…ç©ºæ§åˆ¶å°
        function burnVariablesToCSS() {
            console.log("burnVariablesToCSS called");
            const editor = getCurrentEditor();
            if (!editor) {
                console.warn("Editor not ready");
                return;
            }

            if (customVars.length === 0) {
                console.warn("No variables to burn");
                return;
            }

            // æ›´æ–°è¨Šæ¯ä¸¦é¡¯ç¤ºç‡’éŒ„ç¢ºèª Modal
            const count = customVars.length;
            const editorName = getEditorName();
            document.getElementById('burnConfirmMessage').innerHTML =
                `ç¢ºå®šè¦ç‡’éŒ„å„²å­˜å—ï¼Ÿ<br><br>é€™å°‡æœƒï¼š<br>1. å°‡ <b>${count}</b> å€‹è®Šæ•¸çš„å€¼å¯«å…¥ ${editorName} ç·¨è¼¯å™¨<br>2. æ¸…ç©º ${activeEditorTab.toUpperCase()} Tab çš„è®Šæ•¸æ§åˆ¶å°<br><br><span class="text-xs text-[#6c7086]">æ­¤æ“ä½œç„¡æ³•å¾©åŸã€‚</span>`;
            document.getElementById('burnConfirmModal').style.display = 'flex';
        }

        function closeBurnConfirmModal() {
            document.getElementById('burnConfirmModal').style.display = 'none';
        }

        function performBurnVariables() {
            closeBurnConfirmModal();

            // æª¢æŸ¥ä¾†æºè³‡è¨Šé¡å‹
            const hasCssPageInfo = customVars.some(v => v.cssPageId);
            const hasRuleInfo = customVars.some(v => v.ruleId);

            if (hasCssPageInfo) {
                // ====== ç°¡æ˜“æ¨¡å¼ï¼šè·¨ CSS åˆ†é ç‡’éŒ„ ======
                const pageGroups = {};
                customVars.forEach(v => {
                    const pageId = v.cssPageId || activeCssId;
                    if (!pageGroups[pageId]) pageGroups[pageId] = [];
                    pageGroups[pageId].push(v);
                });

                saveCurrentCss();

                let totalBurned = 0;
                const burnedPages = [];

                Object.entries(pageGroups).forEach(([pageId, vars]) => {
                    const cssPage = cssGroups.find(c => c.id === pageId);
                    if (!cssPage) return;

                    let content = cssPage.content || '';
                    vars.forEach(v => {
                        const varRef = `var(${v.name})`;
                        const newValue = v.value + (v.unit || '');
                        content = content.split(varRef).join(newValue);
                    });
                    cssPage.content = content;
                    totalBurned += vars.length;
                    burnedPages.push(cssPage.name);
                });

                const currentCss = cssGroups.find(c => c.id === activeCssId);
                if (currentCss && cssEditor) {
                    cssEditor.setValue(currentCss.content);
                }

                customVars = [];
                tabVariables[getVarGroupKey(activeEditorTab)].cssVars = [];
                variableHistory = [];
                renderVarControls();
                render();

                console.log(`âœ… è·¨åˆ†é ç‡’éŒ„å®Œæˆï¼å·²å°‡ ${totalBurned} å€‹è®Šæ•¸å€¼å¯«å…¥ ${burnedPages.length} å€‹ CSS åˆ†é ï¼š${burnedPages.join(', ')}`);
            } else if (hasRuleInfo) {
                // ====== Regex æ¨¡å¼ï¼šè·¨è¦å‰‡ç‡’éŒ„ ======
                const ruleGroups = {};
                customVars.forEach(v => {
                    const ruleId = v.ruleId || activeRuleId;
                    if (!ruleGroups[ruleId]) ruleGroups[ruleId] = [];
                    ruleGroups[ruleId].push(v);
                });

                // å„²å­˜ç•¶å‰è¦å‰‡
                saveCurrentRule();

                let totalBurned = 0;
                const burnedRules = [];

                Object.entries(ruleGroups).forEach(([ruleId, vars]) => {
                    const rule = regexRules.find(r => r.id === ruleId);
                    if (!rule) return;

                    let content = rule.output || '';
                    vars.forEach(v => {
                        const varRef = `var(${v.name})`;
                        const newValue = v.value + (v.unit || '');
                        content = content.split(varRef).join(newValue);
                    });
                    rule.output = content;
                    totalBurned += vars.length;
                    burnedRules.push(rule.name);
                });

                // é‡æ–°è¼‰å…¥ç•¶å‰è¦å‰‡çš„ç·¨è¼¯å™¨
                const currentRule = regexRules.find(r => r.id === activeRuleId);
                if (currentRule && regexOutputEditor) {
                    regexOutputEditor.setValue(currentRule.output || '');
                }

                customVars = [];
                tabVariables[getVarGroupKey(activeEditorTab)].cssVars = [];
                variableHistory = [];
                renderVarControls();
                render();

                console.log(`âœ… è·¨è¦å‰‡ç‡’éŒ„å®Œæˆï¼å·²å°‡ ${totalBurned} å€‹è®Šæ•¸å€¼å¯«å…¥ ${burnedRules.length} å€‹ Regex è¦å‰‡ï¼š${burnedRules.join(', ')}`);
            } else {
                // ====== èˆŠæ¶æ§‹ï¼šåªç‡’éŒ„ç•¶å‰ç·¨è¼¯å™¨ ======
                const editor = getCurrentEditor();
                let content = editor.getValue();

                customVars.forEach(v => {
                    const varRef = `var(${v.name})`;
                    const newValue = v.value + (v.unit || '');
                    content = content.split(varRef).join(newValue);
                });

                editor.setValue(content);

                const burnedCount = customVars.length;
                customVars = [];
                tabVariables[getVarGroupKey(activeEditorTab)].cssVars = [];
                variableHistory = [];
                renderVarControls();
                render();

                console.log(`âœ… ç‡’éŒ„å®Œæˆï¼å·²å°‡ ${burnedCount} å€‹è®Šæ•¸å€¼å¯«å…¥ ${getEditorName()} ç·¨è¼¯å™¨ã€‚`);
            }
        }

        function addVariable(type) { /* Unused manual add, keeping structure simpler */ }
        function removeVariable(id) {
            if (confirm("ç¢ºå®šåˆªé™¤æ­¤è®Šæ•¸ï¼Ÿ")) {
                customVars = customVars.filter(v => v.id !== id);
                renderVarControls();
                render();
            }
        }
        function updateVarValue(id, val) {
            const v = customVars.find(x => x.id === id);
            if (v) {
                v.value = val;
                document.getElementById(`input-${id}`).value = val;
                render();
            }
        }

        // Copy / Export
        function executeCopy(text) {
            const dummy = document.createElement("textarea");
            dummy.style.position = 'fixed'; dummy.style.top = '0'; dummy.style.left = '0'; dummy.style.opacity = '0';
            document.body.appendChild(dummy);
            dummy.value = text;
            dummy.select();
            try { document.execCommand("copy"); } catch (err) { alert("è¤‡è£½å¤±æ•—"); }
            document.body.removeChild(dummy);
        }
        function copyText(text) { executeCopy(`var(${text})`); }

        // ===== åˆä½µè¤‡è£½ Modal ç³»çµ± =====

        // é–‹å•Ÿåˆä½µè¤‡è£½ Modal
        function copyMergedCode() {
            openMergeModal();
        }

        function openMergeModal() {
            // å…ˆå„²å­˜ç•¶å‰é é¢å…§å®¹
            saveCurrentPage();
            saveCurrentCss();

            // å¡«å……é é¢é¸å–®
            const select = document.getElementById('mergePageSelect');
            select.innerHTML = htmlPages.map(page =>
                `<option value="${page.id}" ${page.id === activePageId ? 'selected' : ''}>${page.name}</option>`
            ).join('');

            // é‡è¨­å‹¾é¸æ¡†
            document.getElementById('mergeGlobalCss').checked = true;
            document.getElementById('mergeLinkedCss').checked = true;

            // æ›´æ–°é è¦½
            updateMergePreview();

            // é¡¯ç¤º Modal
            document.getElementById('mergeModal').style.display = 'flex';
        }

        function closeMergeModal() {
            document.getElementById('mergeModal').style.display = 'none';
        }

        // æ›´æ–°åˆä½µé è¦½
        function updateMergePreview() {
            const pageId = document.getElementById('mergePageSelect').value;
            const includeGlobal = document.getElementById('mergeGlobalCss').checked;
            const includeLinked = document.getElementById('mergeLinkedCss').checked;

            const page = htmlPages.find(p => p.id === pageId);
            if (!page) return;

            let previewItems = [];

            // HTML é é¢
            previewItems.push(`<div class="text-[#a6e3a1]">ğŸ“„ HTML: <span class="text-[#cdd6f4]">${page.name}</span></div>`);

            // å…¨åŸŸ CSS
            if (includeGlobal) {
                const globalCss = cssGroups.filter(c => c.isGlobal);
                if (globalCss.length > 0) {
                    previewItems.push(`<div class="text-[#f9e2af]">ğŸŒ å…¨åŸŸ CSS: <span class="text-[#cdd6f4]">${globalCss.map(c => c.name).join(', ')}</span></div>`);
                }
            }

            // é€£çµ CSS
            if (includeLinked && page.linkedCss) {
                const linked = cssGroups.find(c => c.id === page.linkedCss);
                if (linked) {
                    previewItems.push(`<div class="text-[#89b4fa]">ğŸ”— é€£çµ CSS: <span class="text-[#cdd6f4]">${linked.name}</span></div>`);
                }
            }

            // å¦‚æœéƒ½æ²’å‹¾é¸
            if (!includeGlobal && !includeLinked) {
                previewItems.push(`<div class="text-[#6c7086] italic">ï¼ˆåƒ…è¤‡è£½ HTML å…§å®¹ï¼‰</div>`);
            }

            document.getElementById('mergePreview').innerHTML = previewItems.join('');
        }

        // åŸ·è¡Œåˆä½µè¤‡è£½
        function performMergedCopy() {
            const pageId = document.getElementById('mergePageSelect').value;
            const includeGlobal = document.getElementById('mergeGlobalCss').checked;
            const includeLinked = document.getElementById('mergeLinkedCss').checked;

            const page = htmlPages.find(p => p.id === pageId);
            if (!page) {
                alert('æ‰¾ä¸åˆ°é¸æ“‡çš„é é¢ï¼');
                return;
            }

            // æ”¶é›† CSS
            let cssContent = '';
            const collectedCss = [];

            // å…¨åŸŸ CSS
            if (includeGlobal) {
                cssGroups.filter(c => c.isGlobal).forEach(c => {
                    if (c.content && c.content.trim()) {
                        cssContent += c.content + '\n\n';
                        collectedCss.push(c.name);
                    }
                });
            }

            // é€£çµ CSS
            if (includeLinked && page.linkedCss) {
                const linked = cssGroups.find(c => c.id === page.linkedCss);
                if (linked && linked.content && linked.content.trim()) {
                    cssContent += linked.content + '\n\n';
                    collectedCss.push(linked.name);
                }
            }

            // å–å¾— HTML å…§å®¹
            const htmlContent = page.content || '';

            // çµ„åˆè¼¸å‡º
            let merged = '';

            if (cssContent.trim()) {
                // æ™ºæ…§æª¢æ¸¬ CSS æ˜¯å¦å·²åŒ…å« <style> æ¨™ç±¤
                const hasStyleTag = cssContent.trim().startsWith('<style') || cssContent.includes('<style>');

                if (hasStyleTag) {
                    merged = cssContent.trim() + '\n' + htmlContent;
                } else {
                    merged = `<style>\n${cssContent.trim()}\n</style>\n${htmlContent}`;
                }
            } else {
                // åªæœ‰ HTML
                merged = htmlContent;
            }

            // å¥—ç”¨ç©ºè¡Œæ¸…ç†ï¼ˆå¦‚æœå•Ÿç”¨ï¼‰
            merged = cleanEmptyLines(merged);

            // è¤‡è£½åˆ°å‰ªè²¼ç°¿
            executeCopy(merged);

            // é—œé–‰ Modal
            closeMergeModal();

            // é¡¯ç¤ºçµæœ
            let msg = `âœ… å·²åˆä½µè¤‡è£½ï¼\n\nğŸ“„ HTML: ${page.name}`;
            if (collectedCss.length > 0) {
                msg += `\nğŸ¨ CSS: ${collectedCss.join(', ')}`;
            }
            if (!includeGlobal && !includeLinked) {
                msg += '\n\nğŸ“Œ åƒ…è¤‡è£½ HTML å…§å®¹ï¼ˆæœªåŒ…å«ä»»ä½• CSSï¼‰';
            }
            alert(msg);
        }

        // ===== è¨­å®šç³»çµ± =====

        function openSettingsModal() {
            // åŒæ­¥ UI ç‹€æ…‹
            document.getElementById('settingCleanEmptyLines').checked = appSettings.cleanEmptyLines;
            document.getElementById('settingIncludeImages').checked = appSettings.includeImages;
            document.getElementById('settingsModal').style.display = 'flex';
        }

        function closeSettingsModal() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        function toggleSetting(key) {
            if (key === 'cleanEmptyLines') {
                appSettings.cleanEmptyLines = document.getElementById('settingCleanEmptyLines').checked;
            } else if (key === 'includeImages') {
                appSettings.includeImages = document.getElementById('settingIncludeImages').checked;
            }
        }

        // æ¸…ç†ç©ºè¡Œå·¥å…·å‡½æ•¸
        function cleanEmptyLines(content) {
            if (!appSettings.cleanEmptyLines) return content;
            // ç§»é™¤ç´”ç©ºè¡Œï¼ˆåªä¿ç•™å–®ä¸€æ›è¡Œï¼‰
            return content.replace(/\n[ \t]*\n/g, '\n');
        }

        // åŒ¯å‡ºå·¥ä½œç‹€æ…‹
        function exportWorkspace() {
            // å…ˆå„²å­˜æ‰€æœ‰ç·¨è¼¯å™¨å…§å®¹
            saveCurrentPage();
            saveCurrentCss();
            saveCurrentRule();

            const workspaceData = {
                version: "1.1",  // [æ›´æ–°] ç‰ˆæœ¬è™Ÿ
                exportDate: new Date().toISOString(),
                settings: appSettings,

                // ç·¨è¼¯å™¨è³‡æ–™
                cssGroups: cssGroups,
                htmlPages: htmlPages,
                regexRules: regexRules,

                // [æ–°å¢] åŠ‡æƒ… Tab å…§å®¹
                storyContent: storyEditor ? storyEditor.getValue() : '',

                // ç‹€æ…‹
                activeCssId: activeCssId,
                activePageId: activePageId,
                activeRuleId: activeRuleId,
                cssCounter: cssCounter,
                pageCounter: pageCounter,
                ruleCounter: ruleCounter,

                // [æ–°å¢] ç·¨è¼¯å™¨å’Œé è¦½ç‹€æ…‹
                activeEditorTab: activeEditorTab || 'css',
                previewMode: previewMode || 'simple',
                previewBgColor: previewBgColor || '#ffffff',

                // è®Šæ•¸ç‹€æ…‹
                tabVariables: typeof tabVariables !== 'undefined' ? tabVariables : {},
                risuSimVars: typeof risuSimVars !== 'undefined' ? risuSimVars : {},

                // ä¸Šå‚³çš„åœ–ç‰‡ï¼ˆå¯é¸ï¼‰
                uploadedImages: appSettings.includeImages && typeof risuTestImages !== 'undefined'
                    ? risuTestImages
                    : null
            };

            // ä¸‹è¼‰ JSON æª”æ¡ˆ
            const blob = new Blob([JSON.stringify(workspaceData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `regex_ui_lab_workspace_${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            let msg = `âœ… å·¥ä½œç‹€æ…‹å·²åŒ¯å‡ºï¼\n\n`;
            msg += `ğŸ“„ HTML é é¢: ${htmlPages.length}\n`;
            msg += `ğŸ¨ CSS åˆ†çµ„: ${cssGroups.length}\n`;
            msg += `ğŸ“‹ Regex è¦å‰‡: ${regexRules.length}`;
            if (appSettings.includeImages && typeof risuTestImages !== 'undefined') {
                msg += `\nğŸ–¼ï¸ åœ–ç‰‡: ${Object.keys(risuTestImages).length}`;
            }
            alert(msg);
        }

        // åŒ¯å…¥å·¥ä½œç‹€æ…‹
        function importWorkspace() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';

            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const data = JSON.parse(text);

                    // é©—è­‰æ ¼å¼
                    if (!data.version || !data.cssGroups || !data.htmlPages) {
                        alert('âŒ ç„¡æ•ˆçš„å·¥ä½œç‹€æ…‹æª”æ¡ˆï¼\n\nè«‹ç¢ºä¿æ˜¯ç”±ã€ŒåŒ¯å‡ºé€²åº¦ã€ç”¢ç”Ÿçš„ JSON æª”æ¡ˆã€‚');
                        return;
                    }

                    // ç¢ºèªè¦†è“‹
                    if (!confirm(`ğŸ“¥ ç™¼ç¾å·¥ä½œç‹€æ…‹æª”æ¡ˆ\n\n` +
                        `ğŸ“„ HTML é é¢: ${data.htmlPages.length}\n` +
                        `ğŸ¨ CSS åˆ†çµ„: ${data.cssGroups.length}\n` +
                        `ğŸ“‹ Regex è¦å‰‡: ${data.regexRules?.length || 0}\n\n` +
                        `é€™å°‡è¦†è“‹ç›®å‰æ‰€æœ‰å…§å®¹ï¼Œç¢ºå®šè¦åŒ¯å…¥å—ï¼Ÿ`)) {
                        return;
                    }

                    // æ¢å¾©è¨­å®š
                    if (data.settings) {
                        appSettings = { ...appSettings, ...data.settings };
                    }

                    // æ¢å¾©è³‡æ–™
                    cssGroups = data.cssGroups || [];
                    htmlPages = data.htmlPages || [];
                    regexRules = data.regexRules || [];

                    // æ¢å¾©ç‹€æ…‹
                    activeCssId = data.activeCssId || (cssGroups[0]?.id || 'css-1');
                    activePageId = data.activePageId || (htmlPages[0]?.id || 'page-1');
                    activeRuleId = data.activeRuleId || (regexRules[0]?.id || 'rule-1');
                    cssCounter = data.cssCounter || cssGroups.length;
                    pageCounter = data.pageCounter || htmlPages.length;
                    ruleCounter = data.ruleCounter || regexRules.length;

                    // æ¢å¾©è®Šæ•¸
                    if (data.tabVariables && typeof tabVariables !== 'undefined') {
                        Object.assign(tabVariables, data.tabVariables);
                    }
                    if (data.risuSimVars && typeof risuSimVars !== 'undefined') {
                        risuSimVars = data.risuSimVars;
                    }

                    // æ¢å¾©åœ–ç‰‡
                    if (data.uploadedImages && typeof risuTestImages !== 'undefined') {
                        Object.assign(risuTestImages, data.uploadedImages);
                    }

                    // [æ–°å¢] æ¢å¾©ç·¨è¼¯å™¨å’Œé è¦½ç‹€æ…‹
                    if (data.activeEditorTab) {
                        activeEditorTab = data.activeEditorTab;
                    }
                    if (data.previewMode) {
                        previewMode = data.previewMode;
                    }
                    if (data.previewBgColor) {
                        previewBgColor = data.previewBgColor;
                        // åŒæ­¥æ›´æ–°è‰²ç›¤ UI
                        const picker = document.getElementById('previewBgPicker');
                        if (picker) picker.value = previewBgColor;
                    }

                    // æ›´æ–°ç·¨è¼¯å™¨
                    const activeCss = cssGroups.find(c => c.id === activeCssId);
                    const activePage = htmlPages.find(p => p.id === activePageId);
                    const activeRule = regexRules.find(r => r.id === activeRuleId);

                    if (cssEditor && activeCss) {
                        cssEditor.setValue(activeCss.content || '');
                    }
                    if (htmlEditor && activePage) {
                        htmlEditor.setValue(activePage.content || '');
                    }
                    if (activeRule) {
                        loadRuleToEditor(activeRule);
                    }

                    // [æ–°å¢] æ¢å¾©åŠ‡æƒ… Tab å…§å®¹
                    if (data.storyContent && storyEditor) {
                        storyEditor.setValue(data.storyContent);
                    }

                    // é‡æ–°æ¸²æŸ“ UI
                    if (typeof renderCssTabs === 'function') renderCssTabs();
                    if (typeof renderPageTabs === 'function') renderPageTabs();
                    if (typeof renderRuleList === 'function') renderRuleList();

                    // [å·²ä¿®æ”¹] åŒæ­¥è®Šæ•¸æ§åˆ¶å°ï¼šä½¿ç”¨æ–°çš„è®Šæ•¸çµ„æ¶æ§‹
                    // æ·»åŠ å‘å¾Œç›¸å®¹ï¼šå¦‚æœåŒ¯å…¥çš„æ˜¯èˆŠæ ¼å¼ï¼ˆcss/html/regex/storyï¼‰ï¼Œè‡ªå‹•è½‰æ›
                    if (tabVariables && tabVariables.css && !tabVariables.simple) {
                        // èˆŠæ ¼å¼: åˆä½µ css+html -> simple, regex+story -> regex
                        const oldTabVars = tabVariables;
                        tabVariables = {
                            simple: {
                                cssVars: [...(oldTabVars.css?.cssVars || []), ...(oldTabVars.html?.cssVars || [])],
                                risuVars: { ...(oldTabVars.css?.risuVars || {}), ...(oldTabVars.html?.risuVars || {}) }
                            },
                            regex: {
                                cssVars: [...(oldTabVars.regex?.cssVars || []), ...(oldTabVars.story?.cssVars || [])],
                                risuVars: { ...(oldTabVars.regex?.risuVars || {}), ...(oldTabVars.story?.risuVars || {}) }
                            }
                        };
                        console.log('ğŸ“¦ å·²è½‰æ›èˆŠç‰ˆè®Šæ•¸æ ¼å¼ç‚ºæ–°æ¶æ§‹');
                    }
                    const groupKey = getVarGroupKey(activeEditorTab);
                    if (typeof activeEditorTab !== 'undefined' && tabVariables[groupKey]) {
                        customVars = tabVariables[groupKey].cssVars || [];
                    }
                    if (typeof renderVarControls === 'function') renderVarControls();
                    if (typeof renderRisuVars === 'function') renderRisuVars();
                    if (typeof syncTabVariables === 'function') syncTabVariables();

                    // [æ–°å¢] æ¢å¾© Tab å’Œé è¦½æ¨¡å¼çš„ UI ç‹€æ…‹
                    if (typeof switchTab === 'function' && activeEditorTab) {
                        switchTab(activeEditorTab);
                    }
                    if (typeof setPreviewMode === 'function' && previewMode) {
                        setPreviewMode(previewMode);
                    }

                    if (typeof render === 'function') render();

                    closeSettingsModal();

                    alert(`âœ… å·¥ä½œç‹€æ…‹å·²æ¢å¾©ï¼\n\nåŒ¯å…¥è‡ª: ${data.exportDate || 'æœªçŸ¥æ—¥æœŸ'}`);

                } catch (err) {
                    alert(`âŒ åŒ¯å…¥å¤±æ•—ï¼š${err.message}`);
                }
            };

            input.click();
        }

        // Render
        function render() {
            if (!monacoReady) return; // ç­‰å¾… Monaco åˆå§‹åŒ–å®Œæˆ

            const regexStr = document.getElementById('regexInput').value;
            const flags = document.getElementById('regexFlags').value;

            // === CSS åˆ†çµ„åˆä½µé‚è¼¯ ===
            // 1. å…ˆå„²å­˜ç•¶å‰ç·¨è¼¯å™¨çš„å…§å®¹åˆ°å°æ‡‰åˆ†çµ„
            saveCurrentCss();

            // 2. åˆä½µæ‰€æœ‰å…¨åŸŸ CSS + ç•¶å‰ HTML é€£æ¥çš„ CSS
            let combinedCss = '';

            // æ”¶é›†æ‰€æœ‰å…¨åŸŸ CSS
            cssGroups.filter(c => c.isGlobal).forEach(c => {
                combinedCss += '/* === ' + c.name + ' (å…¨åŸŸ) === */\n' + c.content + '\n\n';
            });

            // å–å¾—ç•¶å‰ HTML é é¢é€£æ¥çš„ CSSï¼ˆå¦‚æœæœ‰ï¼‰
            const currentPage = htmlPages.find(p => p.id === activePageId);
            if (currentPage && currentPage.linkedCss) {
                const linkedCss = cssGroups.find(c => c.id === currentPage.linkedCss);
                if (linkedCss && !linkedCss.isGlobal) {
                    combinedCss += '/* === ' + linkedCss.name + ' (é€£æ¥) === */\n' + linkedCss.content + '\n\n';
                }
            }

            // å¦‚æœç•¶å‰ç·¨è¼¯çš„ CSS ä¸æ˜¯å…¨åŸŸä¸”æ²’æœ‰è¢«é€£æ¥ï¼Œä¹ŸåŠ å…¥é è¦½
            const currentCss = cssGroups.find(c => c.id === activeCssId);
            if (false && currentCss && !currentCss.isGlobal) {  // [å·²ä¿®å¾©] ç¦ç”¨æ­¤é‚è¼¯ï¼Œåªæœ‰å…¨åŸŸå’Œé€£çµçš„CSSæ‰ç”Ÿæ•ˆ
                const alreadyIncluded = currentPage?.linkedCss === activeCssId;
                if (!alreadyIncluded) {
                    combinedCss += '/* === ' + currentCss.name + ' (ç•¶å‰ç·¨è¼¯) === */\n' + currentCss.content + '\n\n';
                }
            }

            let css = combinedCss;  // [å·²ä¿®å¾©] åªä½¿ç”¨å…¨åŸŸå’Œé€£çµçš„ CSSï¼Œä¸å† fallback ä½¿ç”¨ç·¨è¼¯å™¨å…§å®¹
            let template = htmlEditor ? htmlEditor.getValue() : '';
            // ä½¿ç”¨ Monaco åŠ‡æƒ…ç·¨è¼¯å™¨ï¼Œå‚™ç”¨èˆŠç‰ˆ testInput
            const testText = storyEditor ? storyEditor.getValue() : (document.getElementById('testInput')?.value || '');
            const previewFrame = document.getElementById('previewFrame');

            if (!previewFrame) return; // Guard clause

            // ===== æ™ºæ…§åµæ¸¬ï¼šCSS ç·¨è¼¯å™¨ä¸­æ˜¯å¦åŒ…å« <style> æ¨™ç±¤ =====
            // å¦‚æœ CSS ç·¨è¼¯å™¨åŒ…å« <style> æ¨™ç±¤ï¼Œå‰‡è‡ªå‹•æ‹†åˆ† CSS å’Œ HTML
            let extractedCss = css;
            let extractedHtml = '';

            if (css.includes('<style') && css.includes('</style>')) {
                const styleMatch = css.match(/<style[^>]*>([\s\S]*?)<\/style>/gi);
                if (styleMatch) {
                    // æå–æ‰€æœ‰ <style> æ¨™ç±¤å…§çš„ CSS
                    extractedCss = styleMatch.map(s => s.replace(/<\/?style[^>]*>/gi, '')).join('\n');
                    // ç§»é™¤ <style> æ¨™ç±¤å¾Œå‰©é¤˜çš„å°±æ˜¯ HTML
                    extractedHtml = css.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '').trim();
                }
            }

            // å¦‚æœ HTML ç·¨è¼¯å™¨æœ‰å…§å®¹ï¼Œå„ªå…ˆä½¿ç”¨ç·¨è¼¯å™¨å…§å®¹
            if (template.trim()) {
                extractedHtml = template;
            }

            // é è¦½æ™‚ä½¿ç”¨ :root ä½œç‚ºè®Šæ•¸ä½œç”¨åŸŸ
            const cssVarsBlock = `:root {\n${customVars.map(v => `  ${v.name}: ${v.value}${v.unit || ''};`).join('\n')}\n}`;

            let finalContent = "";

            // æ ¹æ“šé è¦½æ¨¡å¼æ±ºå®šå…§å®¹
            if (previewMode === 'simple') {
                // ç°¡æ˜“æ¨¡å¼ï¼šä½¿ç”¨ CSS Tab + HTML Tab çš„å…§å®¹
                finalContent = extractedHtml || template;
            } else {
                // Regex æ¨¡å¼ï¼šä½¿ç”¨ Regex è¦å‰‡è™•ç†åŠ‡æƒ…å…§å®¹
                // ä¸ä½¿ç”¨ CSS/HTML Tabï¼Œåªä½¿ç”¨ Regex è¦å‰‡çš„ OUT
                try {
                    if (testText) {
                        finalContent = testText;

                        // [æ–°å¢] æ”¶é›†éœ€è¦ç§»å‹•çš„å…§å®¹
                        let moveTopContent = [];
                        let moveBottomContent = [];

                        // ä¾åºå¥—ç”¨æ‰€æœ‰å•Ÿç”¨çš„è¦å‰‡
                        regexRules.filter(r => r.enabled && r.pattern).forEach(rule => {
                            try {
                                // [æ–°å¢] è§£æ flagsï¼Œåˆ†é›¢æ¨™æº– regex flags å’Œ RISU é€²éšæ¨™èªŒ
                                const flagStr = rule.flags || 'gi';
                                const hasMoveBtm = /<move_bottom>/i.test(flagStr);
                                const hasMoveTop = /<move_top>/i.test(flagStr);
                                const hasCbs = /<cbs>/i.test(flagStr);
                                // æå–æ¨™æº– regex flagsï¼ˆç§»é™¤ RISU é€²éšæ¨™èªŒï¼‰
                                const regexFlags = flagStr.replace(/<[^>]+>/g, '').trim() || 'gi';

                                const regex = new RegExp(rule.pattern, regexFlags);

                                if (hasMoveBtm || hasMoveTop) {
                                    // [move_top/move_bottom æ¨¡å¼] æ”¶é›†åŒ¹é…å…§å®¹ï¼Œç§»é™¤åŸä½ç½®ï¼Œç¨å¾Œæ’å…¥
                                    const matches = [];
                                    finalContent = finalContent.replace(regex, function (match, ...args) {
                                        let output = rule.output || '';
                                        const groupCount = args.length - 2;
                                        for (let i = groupCount - 1; i >= 0; i--) {
                                            const varRegex = new RegExp('\\$' + (i + 1) + '(?![0-9])', 'g');
                                            output = output.replace(varRegex, args[i] || '');
                                        }
                                        matches.push(output);
                                        return ''; // å¾åŸä½ç½®ç§»é™¤
                                    });

                                    // å°‡æ”¶é›†çš„å…§å®¹åŠ å…¥å°æ‡‰çš„ä½‡åˆ—
                                    if (hasMoveTop) {
                                        moveTopContent.push(...matches);
                                    } else {
                                        moveBottomContent.push(...matches);
                                    }
                                } else {
                                    // [ä¸€èˆ¬æ¨¡å¼] åŸåœ°æ›¿æ›
                                    finalContent = finalContent.replace(regex, function (match, ...args) {
                                        let output = rule.output || '';
                                        const groupCount = args.length - 2;
                                        for (let i = groupCount - 1; i >= 0; i--) {
                                            const varRegex = new RegExp('\\$' + (i + 1) + '(?![0-9])', 'g');
                                            output = output.replace(varRegex, args[i] || '');
                                        }
                                        return output;
                                    });
                                }
                            } catch (e) {
                                console.error(`è¦å‰‡ "${rule.name}" éŒ¯èª¤:`, e.message);
                            }
                        });

                        // [æ–°å¢] çµ„åˆæœ€çµ‚è¼¸å‡ºï¼šmoveTop + ä¸»å…§å®¹ + moveBottom
                        if (moveTopContent.length > 0 || moveBottomContent.length > 0) {
                            finalContent =
                                moveTopContent.join('\n') +
                                (moveTopContent.length > 0 ? '\n' : '') +
                                finalContent.trim() +
                                (moveBottomContent.length > 0 ? '\n' : '') +
                                moveBottomContent.join('\n');
                        }

                        // å¦‚æœæ²’æœ‰å•Ÿç”¨çš„è¦å‰‡
                        if (!regexRules.some(r => r.enabled && r.pattern)) {
                            finalContent = '<div style="color:#6c7086; text-align:center; padding:40px;"><i class="fas fa-info-circle"></i> è«‹åœ¨ Regex Tab æ–°å¢ä¸¦å•Ÿç”¨è¦å‰‡</div>';
                        }
                    } else {
                        finalContent = '<div style="color:#6c7086; text-align:center; padding:40px;"><i class="fas fa-info-circle"></i> è«‹åœ¨åŠ‡æƒ… Tab è¼¸å…¥æ¸¬è©¦å…§å®¹</div>';
                    }
                } catch (e) { finalContent = `Error: ${e.message}`; }
            }

            // Regex æ¨¡å¼ä¸‹ä¸ä½¿ç”¨ CSS Tab çš„æ¨£å¼
            let finalCss = '';
            if (previewMode === 'simple') {
                finalCss = extractedCss;
            } else {
                // Regex æ¨¡å¼ï¼šCSS å·²åŒ…å«åœ¨è¦å‰‡çš„ output ä¸­ï¼ˆ<style>æ¨™ç±¤ï¼‰
                finalCss = '';
            }

            // ğŸ§ª RISU è®Šæ•¸æ¨¡æ“¬è™•ç†
            finalContent = processRisuContent(finalContent);

            const iframeContent = `<!DOCTYPE html><html><head><style>body { margin: 0; padding: 20px; font-family: sans-serif; background-color: ${previewBgColor}; }
/* ğŸ”§ é è¦½å€æº¢å‡ºè™•ç†ï¼šè®“ fixed å½ˆçª—å’Œé•·å…§å®¹å¯æ»¾å‹• */
[style*="position: fixed"], [style*="position:fixed"], .control-panel, .modal, .popup, .dialog {
    max-height: 80vh !important;
    overflow-y: auto !important;
}
${cssVarsBlock}${finalCss}</style></head><body>${finalContent}${selectMode ? getSelectModeScript() : ''}</body></html>`;
            const doc = previewFrame.contentDocument || previewFrame.contentWindow.document;
            if (doc) {
                doc.open(); doc.write(iframeContent); doc.close();
            }
        }

        // ç”Ÿæˆé¸å–æ¨¡å¼çš„äº’å‹•è…³æœ¬ï¼ˆæ³¨å…¥ iframeï¼‰
        function getSelectModeScript() {
            return `
<script>
(function() {
    let selectedElement = null;
    let hoverElement = null;
    
    // è¨ˆç®—å…ƒç´ çš„ CSS é¸æ“‡å™¨
    function getSelector(el) {
        if (!el || el === document.body || el === document.documentElement) return 'body';
        
        // å„ªå…ˆä½¿ç”¨ class
        if (el.classList && el.classList.length > 0) {
            return '.' + [...el.classList].join('.');
        }
        // å…¶æ¬¡ä½¿ç”¨ id
        if (el.id) {
            return '#' + el.id;
        }
        // æœ€å¾Œä½¿ç”¨æ¨™ç±¤å
        return el.tagName.toLowerCase();
    }
    
    // æª¢æ¸¬é»æ“Šä½ç½®æ˜¯å¦åœ¨å½å…ƒç´ å€åŸŸ
    function detectPseudoElement(el, x, y) {
        const rect = el.getBoundingClientRect();
        const beforeStyle = window.getComputedStyle(el, '::before');
        const afterStyle = window.getComputedStyle(el, '::after');
        
        // æª¢æŸ¥ ::before
        if (beforeStyle.content && beforeStyle.content !== 'none') {
            // ç°¡åŒ–åˆ¤æ–·ï¼šå¦‚æœé»æ“Šåœ¨å…ƒç´ çš„ä¸ŠåŠéƒ¨æˆ–å·¦å´ï¼Œå¯èƒ½æ˜¯ ::before
            const relX = x - rect.left;
            const relY = y - rect.top;
            if (relY < rect.height * 0.3 || relX < rect.width * 0.2) {
                return 'before';
            }
        }
        
        // æª¢æŸ¥ ::after
        if (afterStyle.content && afterStyle.content !== 'none') {
            const relX = x - rect.left;
            const relY = y - rect.top;
            if (relY > rect.height * 0.7 || relX > rect.width * 0.8) {
                return 'after';
            }
        }
        
        return null;
    }
    
    // Hover æ•ˆæœï¼ˆåªåœ¨æŒ‰ä½ Ctrl æ™‚é¡¯ç¤ºï¼‰
    document.body.addEventListener('mousemove', function(e) {
        const el = e.target;
        
        // ç§»é™¤ä¹‹å‰çš„ hover æ•ˆæœ
        if (hoverElement && hoverElement !== selectedElement) {
            hoverElement.style.outline = '';
        }
        
        // åªåœ¨æŒ‰ä½ Ctrl æ™‚é¡¯ç¤º hover æ•ˆæœ
        if ((e.ctrlKey || e.metaKey) && el !== selectedElement) {
            el.style.outline = '2px dashed #89b4fa';
        }
        hoverElement = el;
    }, true);
    
    // ç§»é™¤ hover æ•ˆæœï¼ˆç•¶æ»‘é¼ é›¢é–‹ï¼‰
    document.body.addEventListener('mouseleave', function() {
        if (hoverElement && hoverElement !== selectedElement) {
            hoverElement.style.outline = '';
        }
        hoverElement = null;
    }, true);
    
    // ===== è§¸æ§é•·æŒ‰æ”¯æ´ï¼ˆæ‰‹æ©Ÿç‰ˆæ›¿ä»£ Ctrl+é»æ“Šï¼‰=====
    let longPressTimer = null;
    let longPressTarget = null;
    let longPressTriggered = false;
    
    document.body.addEventListener('touchstart', function(e) {
        if (e.touches.length !== 1) return; // åªè™•ç†å–®æŒ‡è§¸æ§
        
        longPressTarget = e.target;
        longPressTriggered = false;
        
        longPressTimer = setTimeout(function() {
            longPressTriggered = true;
            
            // è§¸ç™¼èˆ‡ Ctrl+é»æ“Šç›¸åŒçš„é¸å–é‚è¼¯ï¼ˆå®šä½ CSSï¼‰
            triggerElementSelect(longPressTarget, e.touches[0].clientX, e.touches[0].clientY);
            
            // éœ‡å‹•åé¥‹ï¼ˆå¦‚æœæ”¯æ´ï¼‰
            if (navigator.vibrate) navigator.vibrate(50);
        }, 500); // 500ms é•·æŒ‰
    }, { passive: true });
    
    document.body.addEventListener('touchend', function(e) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
        
        if (longPressTriggered) {
            e.preventDefault();
        }
    });
    
    document.body.addEventListener('touchmove', function() {
        clearTimeout(longPressTimer);
        longPressTimer = null;
    }, { passive: true });
    
    // ===== é›™æ“Šå®šä½ HTMLï¼ˆæ‰‹æ©Ÿç‰ˆæ›¿ä»£ Alt+é»æ“Šï¼‰=====
    let lastTapTime = 0;
    let lastTapTarget = null;
    
    document.body.addEventListener('touchend', function(e) {
        if (longPressTriggered) return; // å¿½ç•¥é•·æŒ‰å¾Œçš„ touchend
        
        const currentTime = Date.now();
        const target = e.target;
        
        // æª¢æ¸¬é›™æ“Šï¼ˆ300ms å…§å…©æ¬¡é»æ“ŠåŒä¸€å…ƒç´ ï¼‰
        if (currentTime - lastTapTime < 300 && target === lastTapTarget) {
            e.preventDefault();
            
            const selector = getSelector(target);
            const outerHtml = target.outerHTML.substring(0, 200);
            
            // ç™¼é€ HTML å®šä½è«‹æ±‚
            parent.postMessage({ 
                type: 'HTML_LOCATE', 
                selector: selector,
                tagName: target.tagName.toLowerCase(),
                classList: [...(target.classList || [])],
                id: target.id || '',
                outerHtml: outerHtml
            }, '*');
            
            // è¦–è¦ºå›é¥‹ï¼šæ©˜è‰²é‚Šæ¡†
            target.style.outline = '3px solid #fab387';
            target.style.outlineOffset = '2px';
            setTimeout(() => { 
                target.style.outline = ''; 
                target.style.outlineOffset = ''; 
            }, 1500);
            
            // éœ‡å‹•åé¥‹
            if (navigator.vibrate) navigator.vibrate([30, 50, 30]);
            
            lastTapTime = 0;
            lastTapTarget = null;
        } else {
            lastTapTime = currentTime;
            lastTapTarget = target;
        }
    });
    
    // å…ƒç´ é¸å–é‚è¼¯ï¼ˆå…±ç”¨æ–¼ Ctrl+é»æ“Š å’Œ é•·æŒ‰ï¼‰
    function triggerElementSelect(el, clientX, clientY) {
        // ç§»é™¤ä¹‹å‰çš„é¸å–æ•ˆæœå’Œæ¨™ç±¤
        if (selectedElement) {
            selectedElement.style.outline = '';
            selectedElement.style.outlineOffset = '';
        }
        const oldLabel = document.getElementById('pseudo-label');
        if (oldLabel) oldLabel.remove();
        
        // æª¢æ¸¬å½å…ƒç´ 
        const pseudoElement = detectPseudoElement(el, clientX, clientY);
        
        // æ ¹æ“šæ˜¯å¦ç‚ºå½å…ƒç´ é¸æ“‡ä¸åŒçš„è¦–è¦ºæ•ˆæœ
        if (pseudoElement) {
            el.style.outline = '3px solid #fab387';
            el.style.outlineOffset = '2px';
            
            const label = document.createElement('div');
            label.id = 'pseudo-label';
            label.textContent = '::' + pseudoElement;
            label.style.cssText = 'position:fixed; top:' + (clientY - 30) + 'px; left:' + clientX + 'px; background:#fab387; color:#11111b; font-size:12px; font-weight:bold; padding:2px 8px; border-radius:4px; z-index:99999; pointer-events:none; font-family:monospace;';
            document.body.appendChild(label);
            setTimeout(function() { if (label.parentNode) label.remove(); }, 3000);
        } else {
            el.style.outline = '3px solid #a6e3a1';
            el.style.outlineOffset = '2px';
        }
        selectedElement = el;
        
        // è¨ˆç®—é¸æ“‡å™¨
        const selector = getSelector(el);
        
        // æª¢æŸ¥æ˜¯å¦æœ‰ inline style
        const hasInlineStyle = el.hasAttribute('style');
        const inlineStylePreview = hasInlineStyle ? el.getAttribute('style').substring(0, 50) : '';
        
        // æ”¶é›† Box Model è³‡è¨Š
        const computed = window.getComputedStyle(el);
        const boxModel = {
            width: el.offsetWidth,
            height: el.offsetHeight,
            marginTop: computed.marginTop,
            marginRight: computed.marginRight,
            marginBottom: computed.marginBottom,
            marginLeft: computed.marginLeft,
            paddingTop: computed.paddingTop,
            paddingRight: computed.paddingRight,
            paddingBottom: computed.paddingBottom,
            paddingLeft: computed.paddingLeft,
            borderRadius: computed.borderRadius,
            position: computed.position
        };
        
        // ç™¼é€çµ¦çˆ¶è¦–çª—
        parent.postMessage({ 
            type: 'ELEMENT_SELECTED', 
            selector: selector,
            tagName: el.tagName,
            classList: [...(el.classList || [])],
            pseudoElement: pseudoElement,
            hasInlineStyle: hasInlineStyle,
            inlineStylePreview: inlineStylePreview,
            boxModel: boxModel
        }, '*');
        
        // é¡¯ç¤ºæ§åˆ¶æŸ„
        showResizeHandles(el);
    }
    
    // é»æ“Šé¸å–ï¼ˆCtrl+é»æ“Š = å®šä½ CSSï¼ŒAlt+é»æ“Š = å®šä½ HTMLï¼Œæ™®é€šé»æ“Š = æ­£å¸¸äº’å‹•ï¼‰
    document.body.addEventListener('click', function(e) {
        // Alt+é»æ“Šï¼šå®šä½ HTML
        if (e.altKey) {
            e.preventDefault();
            e.stopPropagation();
            
            const el = e.target;
            const selector = getSelector(el);
            const outerHtml = el.outerHTML.substring(0, 200);  // å–å‰ 200 å­—å…ƒ
            
            // ç™¼é€ HTML å®šä½è«‹æ±‚
            parent.postMessage({ 
                type: 'HTML_LOCATE', 
                selector: selector,
                tagName: el.tagName.toLowerCase(),
                classList: [...(el.classList || [])],
                id: el.id || '',
                outerHtml: outerHtml
            }, '*');
            
            // è¦–è¦ºå›é¥‹ï¼šæ©˜è‰²é‚Šæ¡†
            el.style.outline = '3px solid #fab387';
            el.style.outlineOffset = '2px';
            setTimeout(() => { 
                el.style.outline = ''; 
                el.style.outlineOffset = ''; 
            }, 1500);
            
            return;
        }
        
        // ğŸ”‘ åªæœ‰ Ctrl+é»æ“Š æ‰è§¸ç™¼ CSS é¸å–æ¨¡å¼
        if (!e.ctrlKey && !e.metaKey) {
            // æ™®é€šé»æ“Šï¼šå…è¨±äº’å‹•å¼ UI æ­£å¸¸é‹ä½œ
            return;
        }
        
        // Ctrl+é»æ“Šï¼šé€²å…¥é¸å–æ¨¡å¼ï¼ˆå®šä½ CSSï¼‰
        e.preventDefault();
        e.stopPropagation();
        
        // ä½¿ç”¨å…±ç”¨çš„é¸å–é‚è¼¯
        triggerElementSelect(e.target, e.clientX, e.clientY);
    }, true);
    
    // ===== æ§åˆ¶æŸ„ç³»çµ± =====
    let handlesContainer = null;
    let isDragging = false;
    let dragHandle = null;
    let startX = 0, startY = 0;
    let startWidth = 0, startHeight = 0;
    let startMargin = { top: 0, right: 0, bottom: 0, left: 0 };
    
    // é¡¯ç¤ºæ§åˆ¶æŸ„
    function showResizeHandles(el) {
        // ç§»é™¤èˆŠçš„æ§åˆ¶æŸ„
        removeResizeHandles();
        
        const rect = el.getBoundingClientRect();
        
        // å»ºç«‹æ§åˆ¶æŸ„å®¹å™¨
        handlesContainer = document.createElement('div');
        handlesContainer.id = 'resize-handles-container';
        handlesContainer.style.cssText = 'position:fixed; pointer-events:none; z-index:99998;';
        
        // æ§åˆ¶æŸ„é…ç½®ï¼š[ä½ç½®å, æ¸¸æ¨™, èª¿æ•´é¡å‹, xåç§», yåç§»]
        const handles = [
            // 4 å€‹è§’è½ï¼ˆèª¿æ•´å¯¬é«˜ï¼‰
            ['nw', 'nwse-resize', 'size', 0, 0],
            ['ne', 'nesw-resize', 'size', 1, 0],
            ['sw', 'nesw-resize', 'size', 0, 1],
            ['se', 'nwse-resize', 'size', 1, 1],
            // 4 å€‹é‚Šç·£ï¼ˆèª¿æ•´ marginï¼‰
            ['n', 'ns-resize', 'margin-top', 0.5, 0],
            ['s', 'ns-resize', 'margin-bottom', 0.5, 1],
            ['w', 'ew-resize', 'margin-left', 0, 0.5],
            ['e', 'ew-resize', 'margin-right', 1, 0.5]
        ];
        
        handles.forEach(([pos, cursor, type, xRatio, yRatio]) => {
            const handle = document.createElement('div');
            handle.className = 'resize-handle';
            handle.dataset.pos = pos;
            handle.dataset.type = type;
            
            const x = rect.left + rect.width * xRatio - 5;
            const y = rect.top + rect.height * yRatio - 5;
            
            // è§’è½ç”¨è—è‰²ï¼Œé‚Šç·£ç”¨ç¶ è‰²
            const isCorner = ['nw', 'ne', 'sw', 'se'].includes(pos);
            const color = isCorner ? '#89b4fa' : '#a6e3a1';
            
            handle.style.cssText = 'position:fixed; width:10px; height:10px; background:' + color + '; border:2px solid #11111b; border-radius:2px; pointer-events:auto; cursor:' + cursor + '; left:' + x + 'px; top:' + y + 'px; transition:transform 0.1s;';
            
            // Hover æ•ˆæœ
            handle.onmouseenter = () => { handle.style.transform = 'scale(1.3)'; };
            handle.onmouseleave = () => { handle.style.transform = 'scale(1)'; };
            
            // æ‹–æ›³é–‹å§‹
            handle.onmousedown = (e) => {
                e.preventDefault();
                e.stopPropagation();
                isDragging = true;
                dragHandle = handle;
                startX = e.clientX;
                startY = e.clientY;
                startWidth = selectedElement.offsetWidth;
                startHeight = selectedElement.offsetHeight;
                
                const cs = window.getComputedStyle(selectedElement);
                startMargin = {
                    top: parseFloat(cs.marginTop) || 0,
                    right: parseFloat(cs.marginRight) || 0,
                    bottom: parseFloat(cs.marginBottom) || 0,
                    left: parseFloat(cs.marginLeft) || 0
                };
            };
            
            handlesContainer.appendChild(handle);
        });
        
        document.body.appendChild(handlesContainer);
    }
    
    // ç§»é™¤æ§åˆ¶æŸ„
    function removeResizeHandles() {
        if (handlesContainer) {
            handlesContainer.remove();
            handlesContainer = null;
        }
    }
    
    // æ‹–æ›³ç§»å‹•
    document.addEventListener('mousemove', (e) => {
        if (!isDragging || !dragHandle || !selectedElement) return;
        
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        const type = dragHandle.dataset.type;
        const pos = dragHandle.dataset.pos;
        
        let updates = {};
        
        if (type === 'size') {
            // èª¿æ•´å°ºå¯¸
            let newWidth = startWidth;
            let newHeight = startHeight;
            
            if (pos.includes('e')) newWidth = Math.max(50, startWidth + deltaX);
            if (pos.includes('w')) newWidth = Math.max(50, startWidth - deltaX);
            if (pos.includes('s')) newHeight = Math.max(30, startHeight + deltaY);
            if (pos.includes('n')) newHeight = Math.max(30, startHeight - deltaY);
            
            selectedElement.style.width = newWidth + 'px';
            selectedElement.style.height = newHeight + 'px';
            
            updates = { width: newWidth + 'px', height: newHeight + 'px' };
        } else if (type.startsWith('margin-')) {
            // èª¿æ•´ margin
            const dir = type.replace('margin-', '');
            let newValue = 0;
            
            if (dir === 'top') newValue = Math.max(0, startMargin.top - deltaY);
            if (dir === 'bottom') newValue = Math.max(0, startMargin.bottom + deltaY);
            if (dir === 'left') newValue = Math.max(0, startMargin.left - deltaX);
            if (dir === 'right') newValue = Math.max(0, startMargin.right + deltaX);
            
            // ä½¿ç”¨æ­£ç¢ºçš„ camelCase å±¬æ€§å
            const propName = 'margin' + dir.charAt(0).toUpperCase() + dir.slice(1);
            selectedElement.style[propName] = newValue + 'px';
            updates[propName] = newValue + 'px';
        }
        
        // æ›´æ–°æ§åˆ¶æŸ„ä½ç½®
        showResizeHandles(selectedElement);
        
        // ç™¼é€æ›´æ–°çµ¦çˆ¶è¦–çª—
        parent.postMessage({
            type: 'STYLE_UPDATE',
            selector: getSelector(selectedElement),
            updates: updates
        }, '*');
    });
    
    // æ‹–æ›³çµæŸ
    document.addEventListener('mouseup', () => {
        if (isDragging && selectedElement) {
            // ç™¼é€æœ€çµ‚æ›´æ–°
            const computed = window.getComputedStyle(selectedElement);
            parent.postMessage({
                type: 'STYLE_COMMIT',
                selector: getSelector(selectedElement),
                boxModel: {
                    width: selectedElement.offsetWidth,
                    height: selectedElement.offsetHeight,
                    marginTop: computed.marginTop,
                    marginRight: computed.marginRight,
                    marginBottom: computed.marginBottom,
                    marginLeft: computed.marginLeft
                }
            }, '*');
        }
        isDragging = false;
        dragHandle = null;
    });
    
    // æ”¹è®Šæ¸¸æ¨™æ¨£å¼
    document.body.style.cursor = 'crosshair';
})();
<\/script>`;
        }

        // Live update for scope selector (Safe listener)
        const scopeSelector = document.getElementById('scopeSelector');
        if (scopeSelector) {
            scopeSelector.addEventListener('input', render);
        }

        function switchTab(tab) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
            document.getElementById(`tab-${tab}`).classList.add('active');
            const btns = document.querySelectorAll('.tab-btn');
            if (tab === 'css') btns[0].classList.add('active');
            else if (tab === 'html') btns[1].classList.add('active');
            else if (tab === 'regex') btns[2].classList.add('active');
            else if (tab === 'story') btns[3].classList.add('active');

            // [å·²ä¿®æ”¹] å…ˆå„²å­˜èˆŠ Tab çš„ CSS è®Šæ•¸åˆ°å°æ‡‰çš„è®Šæ•¸çµ„
            const oldGroupKey = getVarGroupKey(activeEditorTab);
            if (activeEditorTab && tabVariables[oldGroupKey]) {
                tabVariables[oldGroupKey].cssVars = JSON.parse(JSON.stringify(customVars));
            }

            // æ›´æ–°ç•¶å‰æ´»å‹• Tabï¼ˆæ¯å€‹ Tab ç¨ç«‹ï¼‰
            activeEditorTab = tab;

            // [æ–°å¢] æ ¹æ“š Tab è‡ªå‹•åˆ‡æ›é è¦½æ¨¡å¼
            const newGroupKey = getVarGroupKey(tab);
            const newPreviewMode = (newGroupKey === 'simple') ? 'simple' : 'regex';
            if (previewMode !== newPreviewMode) {
                // ä½¿ç”¨ setPreviewMode ç¢ºä¿ UI æŒ‰éˆ•ä¹Ÿæ­£ç¢ºæ›´æ–°
                setPreviewMode(newPreviewMode);
                console.log(`ğŸ”„ å·²è‡ªå‹•åˆ‡æ›è‡³ ${newPreviewMode === 'simple' ? 'ç°¡æ˜“' : 'Regex'} æ¨¡å¼`);
            }

            // è¼‰å…¥æ–° Tab çš„è®Šæ•¸ä¸¦æ¸²æŸ“é¢æ¿
            syncTabVariables();

            // åˆ‡æ› Tab å¾Œåˆ·æ–°é è¦½
            render();
        }

        // Initialization Logic
        function init() {
            // åˆå§‹åŒ–é¦–é å…§å®¹
            if (htmlPages.length > 0 && !htmlPages[0].content) {
                htmlPages[0].content = defaultHtml;
            }

            // åˆå§‹åŒ– CSS åˆ†çµ„å…§å®¹
            if (cssGroups.length > 0 && !cssGroups[0].content) {
                cssGroups[0].content = defaultCss;
            }

            // æ¸²æŸ“é é¢åˆ†é å’Œ CSS åˆ†é å’Œ Regex è¦å‰‡åˆ—è¡¨
            renderPageTabs();
            renderCssTabs();
            renderRuleList();
            loadRuleToEditor(regexRules[0]);

            // ====== è‡ªè¨‚é¡è‰²è£é£¾å™¨ç³»çµ± ======
            let colorPickerWidget = null;
            let activeColorDecoration = null;
            
            // ç‚ºç·¨è¼¯å™¨è¨­ç½®é¡è‰²è£é£¾å™¨
            function setupColorDecorators(editor, editorId) {
                if (!editor) return;
                
                let decorationIds = [];
                let colorWidgets = [];
                
                // é¡è‰²ç¢¼æ­£å‰‡è¡¨é”å¼
                const colorRegex = /#(?:[0-9a-fA-F]{8}|[0-9a-fA-F]{6}|[0-9a-fA-F]{3})\b/g;
                
                // æ›´æ–°é¡è‰²è£é£¾
                function updateColorDecorations() {
                    const model = editor.getModel();
                    if (!model) return;
                    
                    const text = model.getValue();
                    const newDecorations = [];
                    
                    // æ¸…é™¤èˆŠçš„ widget
                    colorWidgets.forEach(w => w.remove());
                    colorWidgets = [];
                    
                    let match;
                    colorRegex.lastIndex = 0;
                    while ((match = colorRegex.exec(text)) !== null) {
                        const startPos = model.getPositionAt(match.index);
                        const endPos = model.getPositionAt(match.index + match[0].length);
                        
                        // æ·»åŠ è£é£¾ï¼ˆåº•ç·šï¼‰
                        newDecorations.push({
                            range: new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column),
                            options: {
                                inlineClassName: 'color-code-decoration',
                                hoverMessage: { value: `ğŸ¨ é»æ“Šè‰²å¡Šå¯é–‹å•Ÿèª¿è‰²ç›¤` }
                            }
                        });
                        
                        // å‰µå»ºè‰²å¡Š widget
                        const colorValue = match[0];
                        const widget = createColorWidget(editor, editorId, startPos, colorValue, match.index);
                        if (widget) colorWidgets.push(widget);
                    }
                    
                    decorationIds = editor.deltaDecorations(decorationIds, newDecorations);
                }
                
                // å‰µå»ºè‰²å¡Š widget
                function createColorWidget(editor, editorId, position, colorValue, index) {
                    const widget = document.createElement('div');
                    widget.className = 'monaco-color-widget';
                    widget.style.cssText = `
                        position: absolute;
                        width: 12px;
                        height: 12px;
                        border-radius: 2px;
                        border: 1px solid rgba(255,255,255,0.5);
                        cursor: pointer;
                        z-index: 100;
                        box-shadow: 0 1px 3px rgba(0,0,0,0.3);
                    `;
                    widget.style.backgroundColor = expandHexColor(colorValue);
                    widget.title = 'é»æ“Šé–‹å•Ÿèª¿è‰²ç›¤';
                    
                    // é»æ“Šé–‹å•Ÿèª¿è‰²ç›¤
                    widget.addEventListener('click', (e) => {
                        e.stopPropagation();
                        openColorPicker(editor, editorId, position, colorValue, index);
                    });
                    
                    // è¨ˆç®—ä½ç½®ä¸¦æ·»åŠ åˆ°ç·¨è¼¯å™¨
                    const domNode = editor.getDomNode();
                    if (domNode) {
                        const coords = editor.getScrolledVisiblePosition(position);
                        if (coords) {
                            widget.style.top = (coords.top + 2) + 'px';
                            widget.style.left = (coords.left - 16) + 'px';
                            domNode.appendChild(widget);
                        }
                    }
                    
                    return widget;
                }
                
                // åˆå§‹åŒ–è£é£¾
                updateColorDecorations();
                
                // å…§å®¹è®Šæ›´æ™‚æ›´æ–°
                editor.onDidChangeModelContent(() => {
                    setTimeout(updateColorDecorations, 100);
                });
                
                // æ»¾å‹•æ™‚æ›´æ–°ä½ç½®
                editor.onDidScrollChange(() => {
                    updateColorWidgetPositions();
                });
                
                function updateColorWidgetPositions() {
                    const model = editor.getModel();
                    if (!model) return;
                    
                    const text = model.getValue();
                    let widgetIndex = 0;
                    
                    colorRegex.lastIndex = 0;
                    let match;
                    while ((match = colorRegex.exec(text)) !== null) {
                        if (widgetIndex < colorWidgets.length) {
                            const startPos = model.getPositionAt(match.index);
                            const coords = editor.getScrolledVisiblePosition(startPos);
                            if (coords) {
                                colorWidgets[widgetIndex].style.top = (coords.top + 2) + 'px';
                                colorWidgets[widgetIndex].style.left = (coords.left - 16) + 'px';
                            }
                        }
                        widgetIndex++;
                    }
                }
            }
            
            // å±•é–‹ 3 ä½ hex ç‚º 6 ä½
            function expandHexColor(hex) {
                if (hex.length === 4) {
                    return '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
                }
                return hex;
            }
            
            // é–‹å•Ÿèª¿è‰²ç›¤
            function openColorPicker(editor, editorId, position, currentColor, index) {
                // ç§»é™¤èˆŠçš„èª¿è‰²ç›¤
                if (colorPickerWidget) colorPickerWidget.remove();
                
                const domNode = editor.getDomNode();
                const coords = editor.getScrolledVisiblePosition(position);
                if (!domNode || !coords) return;
                
                // å»ºç«‹èª¿è‰²ç›¤ widget
                colorPickerWidget = document.createElement('div');
                colorPickerWidget.className = 'monaco-color-picker-popup';
                colorPickerWidget.style.cssText = `
                    position: absolute;
                    top: ${coords.top + 20}px;
                    left: ${coords.left}px;
                    background: #1e1e2e;
                    border: 1px solid #313244;
                    border-radius: 8px;
                    padding: 8px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
                    z-index: 1000;
                `;
                
                // é¡è‰²é¸æ“‡å™¨
                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.value = expandHexColor(currentColor);
                colorInput.style.cssText = `
                    width: 80px;
                    height: 40px;
                    border: none;
                    cursor: pointer;
                    border-radius: 4px;
                `;
                
                // ç¢ºèªæŒ‰éˆ•
                const confirmBtn = document.createElement('button');
                confirmBtn.textContent = 'âœ“';
                confirmBtn.style.cssText = `
                    margin-left: 4px;
                    padding: 8px 12px;
                    background: #a6e3a1;
                    color: #11111b;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                `;
                confirmBtn.onclick = () => {
                    applyColorChange(editor, index, currentColor, colorInput.value);
                    colorPickerWidget.remove();
                    colorPickerWidget = null;
                };
                
                // å–æ¶ˆæŒ‰éˆ•
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'âœ•';
                cancelBtn.style.cssText = `
                    margin-left: 4px;
                    padding: 8px 12px;
                    background: #45475a;
                    color: #cdd6f4;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                `;
                cancelBtn.onclick = () => {
                    colorPickerWidget.remove();
                    colorPickerWidget = null;
                };
                
                colorPickerWidget.appendChild(colorInput);
                colorPickerWidget.appendChild(confirmBtn);
                colorPickerWidget.appendChild(cancelBtn);
                domNode.appendChild(colorPickerWidget);
                
                // é»æ“Šå¤–éƒ¨é—œé–‰
                setTimeout(() => {
                    document.addEventListener('click', closeColorPickerOnOutsideClick);
                }, 100);
                
                function closeColorPickerOnOutsideClick(e) {
                    if (colorPickerWidget && !colorPickerWidget.contains(e.target)) {
                        colorPickerWidget.remove();
                        colorPickerWidget = null;
                        document.removeEventListener('click', closeColorPickerOnOutsideClick);
                    }
                }
            }
            
            // æ‡‰ç”¨é¡è‰²è®Šæ›´
            function applyColorChange(editor, index, oldColor, newColor) {
                const model = editor.getModel();
                if (!model) return;
                
                const text = model.getValue();
                const startPos = model.getPositionAt(index);
                const endPos = model.getPositionAt(index + oldColor.length);
                
                const range = new monaco.Range(
                    startPos.lineNumber, startPos.column,
                    endPos.lineNumber, endPos.column
                );
                
                editor.executeEdits('colorPicker', [{
                    range: range,
                    text: newColor,
                    forceMoveMarkers: true
                }]);
            }

            // åˆå§‹åŒ– Monaco Editor
            require.config({ paths: { 'vs': 'https://unpkg.com/monaco-editor@0.45.0/min/vs' } });
            require(['vs/editor/editor.main'], function () {
                // CSS ç·¨è¼¯å™¨ï¼ˆè¼‰å…¥ç•¶å‰ CSS å…§å®¹ï¼‰
                const currentCss = cssGroups.find(c => c.id === activeCssId);
                cssEditor = monaco.editor.create(document.getElementById('cssEditorContainer'), {
                    value: currentCss ? currentCss.content : defaultCss,
                    language: 'css',
                    theme: 'vs-dark',
                    minimap: { enabled: false },
                    wordWrap: 'on',
                    automaticLayout: true,
                    fontSize: 13,
                    lineNumbers: 'on',
                    scrollBeyondLastLine: false,
                    fontFamily: "'JetBrains Mono', 'Consolas', monospace"
                });

                // HTML ç·¨è¼¯å™¨ï¼ˆè¼‰å…¥ç•¶å‰é é¢å…§å®¹ï¼‰
                const currentPage = htmlPages.find(p => p.id === activePageId);
                htmlEditor = monaco.editor.create(document.getElementById('htmlEditorContainer'), {
                    value: currentPage ? currentPage.content : defaultHtml,
                    language: 'html',
                    theme: 'vs-dark',
                    minimap: { enabled: false },
                    wordWrap: 'on',
                    automaticLayout: true,
                    fontSize: 13,
                    lineNumbers: 'on',
                    scrollBeyondLastLine: false,
                    fontFamily: "'JetBrains Mono', 'Consolas', monospace"
                });

                // Regex Pattern ç·¨è¼¯å™¨ (IN)
                const currentRule = regexRules.find(r => r.id === activeRuleId);
                regexPatternEditor = monaco.editor.create(document.getElementById('regexPatternEditorContainer'), {
                    value: currentRule ? currentRule.pattern : '',
                    language: 'plaintext',  // ä½¿ç”¨ plaintext é¿å…èªæ³•éŒ¯èª¤æç¤º
                    theme: 'vs-dark',
                    minimap: { enabled: false },
                    wordWrap: 'on',
                    automaticLayout: true,
                    fontSize: 13,
                    lineNumbers: 'off',
                    scrollBeyondLastLine: false,
                    fontFamily: "'JetBrains Mono', 'Consolas', monospace"
                });

                // Regex Output ç·¨è¼¯å™¨ (OUT)
                regexOutputEditor = monaco.editor.create(document.getElementById('regexOutputEditorContainer'), {
                    value: currentRule ? currentRule.output : '',
                    language: 'html',
                    theme: 'vs-dark',
                    minimap: { enabled: false },
                    wordWrap: 'on',
                    automaticLayout: true,
                    fontSize: 13,
                    lineNumbers: 'on',
                    scrollBeyondLastLine: false,
                    fontFamily: "'JetBrains Mono', 'Consolas', monospace"
                });

                // åŠ‡æƒ…ç·¨è¼¯å™¨
                storyEditor = monaco.editor.create(document.getElementById('storyEditorContainer'), {
                    value: 'åœ¨æ­¤è¼¸å…¥æ¨¡æ“¬åŠ‡æƒ…...\n\nç¯„ä¾‹æ ¼å¼ï¼š\n[PLOT]\nè§’è‰²èµ°é€²æˆ¿é–“ï¼Œç’°é¡§å››å‘¨ã€‚\n<img="character_smile">\n[/PLOT]\nSTATUS##{æ™‚é–“|å¤©æ°£|æº«åº¦|åœ°é»}',
                    language: 'plaintext',
                    theme: 'vs-dark',
                    minimap: { enabled: false },
                    wordWrap: 'on',
                    automaticLayout: true,
                    fontSize: 13,
                    lineNumbers: 'off',
                    scrollBeyondLastLine: false,
                    fontFamily: "'JetBrains Mono', 'Consolas', monospace"
                });

                // ç·¨è¼¯å™¨å…§å®¹è®Šæ›´æ™‚è§¸ç™¼é è¦½æ›´æ–°
                cssEditor.onDidChangeModelContent(() => {
                    clearTimeout(window.renderTimeout);
                    window.renderTimeout = setTimeout(() => {
                        // è‡ªå‹•å„²å­˜ç•¶å‰ CSS
                        saveCurrentCss();
                        render();
                    }, 300);
                });

                htmlEditor.onDidChangeModelContent(() => {
                    clearTimeout(window.renderTimeout);
                    window.renderTimeout = setTimeout(() => {
                        // è‡ªå‹•å„²å­˜ç•¶å‰é é¢
                        saveCurrentPage();
                        render();
                    }, 300);
                });

                // Regex ç·¨è¼¯å™¨è®Šæ›´ç›£è½
                regexPatternEditor.onDidChangeModelContent(() => {
                    clearTimeout(window.renderTimeout);
                    window.renderTimeout = setTimeout(() => {
                        saveCurrentRule();
                        if (previewMode === 'regex') render();
                    }, 300);
                });

                regexOutputEditor.onDidChangeModelContent(() => {
                    clearTimeout(window.renderTimeout);
                    window.renderTimeout = setTimeout(() => {
                        saveCurrentRule();
                        if (previewMode === 'regex') render();
                    }, 300);
                });

                // åŠ‡æƒ…ç·¨è¼¯å™¨è®Šæ›´ç›£è½
                storyEditor.onDidChangeModelContent(() => {
                    clearTimeout(window.renderTimeout);
                    window.renderTimeout = setTimeout(() => {
                        if (previewMode === 'regex') render();
                    }, 300);
                });

                monacoReady = true;
                render();
                console.log('Monaco Editor åˆå§‹åŒ–å®Œæˆ');

                // ====== ç‚º HTML/OUT ç·¨è¼¯å™¨æ·»åŠ è‡ªè¨‚é¡è‰²è£é£¾å™¨ ======
                setupColorDecorators(htmlEditor, 'html');
                setupColorDecorators(regexOutputEditor, 'regexOutput');

                // ç­‰å¾…å­—é«”è¼‰å…¥å®Œæˆå¾Œå¼·åˆ¶é‡æ–°æ¸¬é‡å­—é«”ï¼ˆä¿®å¾©æ¸¸æ¨™éŒ¯ä½ï¼‰
                if (document.fonts && document.fonts.ready) {
                    document.fonts.ready.then(() => {
                        console.log('å­—é«”è¼‰å…¥å®Œæˆï¼Œé‡æ–°æ¸¬é‡å­—é«”å¯¬åº¦');
                        // ä½¿ç”¨ monaco.editor.remeasureFonts() å¼·åˆ¶é‡æ–°è¨ˆç®—å­—ç¬¦å¯¬åº¦
                        monaco.editor.remeasureFonts();
                        // å»¶é²å†æ¬¡åŸ·è¡Œä»¥ç¢ºä¿å®Œå…¨ç”Ÿæ•ˆ
                        setTimeout(() => {
                            monaco.editor.remeasureFonts();
                        }, 500);
                    });
                }
            });

            // å¯¬åº¦æ»‘æ¡¿
            const wRange = document.getElementById('widthRange');
            if (wRange) {
                wRange.addEventListener('input', (e) => {
                    const display = document.getElementById('widthDisplay');
                    const frame = document.getElementById('previewFrame');
                    if (display) display.textContent = e.target.value + 'px';
                    if (frame) frame.style.width = e.target.value + 'px';
                });
            }

            // é«˜åº¦æ»‘æ¡¿
            const hRange = document.getElementById('heightRange');
            if (hRange) {
                hRange.addEventListener('input', (e) => {
                    const display = document.getElementById('heightDisplay');
                    const frame = document.getElementById('previewFrame');
                    if (display) display.textContent = e.target.value + 'px';
                    if (frame) frame.style.height = e.target.value + 'px';
                });
            }

            loadSnippets();

            // èˆŠç‰ˆ Regex Tab çš„è¼¸å…¥ç›£è½ï¼ˆä¿ç•™å…¼å®¹æ€§ï¼‰
            ['regexInput', 'regexFlags', 'testInput'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', () => {
                        clearTimeout(window.renderTimeout);
                        window.renderTimeout = setTimeout(render, 300);
                    });
                }
            });
        }

        // Execute init on load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

    </script>
</body>

</html>